1000
bloom filter is off, all row groups should be read
expect rows_read = select count()
{
  "data": [
    {
      "string": "AZSR",
      "flba": "WNMM"
    },
    {
      "string": "PFJH",
      "flba": "GKJC"
    }
  ],
  "rows": 2,
  "statistics": {
    "rows_read": 1000,
    "bytes_read": 47419
  }
}
bloom filter is on, some row groups should be skipped
expect rows_read much less than select count()
{
  "data": [
    {
      "string": "AZSR",
      "flba": "WNMM"
    },
    {
      "string": "PFJH",
      "flba": "GKJC"
    }
  ],
  "rows": 2,
  "statistics": {
    "rows_read": 464,
    "bytes_read": 21703
  }
}
bloom filter is on, but where predicate contains data from 2 row groups out of 3.
Rows read should be less than select count, but greater than previous selects
{
  "data": [
    {
      "string": "PFJH",
      "flba": "GKJC"
    },
    {
      "string": "ZHZK",
      "flba": "HRWD"
    }
  ],
  "rows": 2,
  "statistics": {
    "rows_read": 536,
    "bytes_read": 25708
  }
}
bloom filter is on, but where predicate contains data from all row groups
expect rows_read = select count()
{
  "data": [
    {
      "string": "PFJH",
      "flba": "GKJC"
    },
    {
      "string": "OKAI",
      "flba": "UXGT"
    },
    {
      "string": "ZHZK",
      "flba": "HRWD"
    }
  ],
  "rows": 3,
  "statistics": {
    "rows_read": 1000,
    "bytes_read": 47419
  }
}
IN check
{
  "data": [
    {
      "string": "PFJH",
      "flba": "GKJC"
    },
    {
      "string": "ZHZK",
      "flba": "HRWD"
    }
  ],
  "rows": 2,
  "statistics": {
    "rows_read": 536,
    "bytes_read": 25708
  }
}
tuple in case, bf is off.
{
  "data": [
    {
      "string": "PFJH",
      "flba": "GKJC"
    }
  ],
  "rows": 1,
  "statistics": {
    "rows_read": 1000,
    "bytes_read": 47419
  }
}
tuple in case, bf is on.
{
  "data": [
    {
      "string": "PFJH",
      "flba": "GKJC"
    }
  ],
  "rows": 1,
  "statistics": {
    "rows_read": 464,
    "bytes_read": 21703
  }
}
complex tuple in case, bf is off
{
  "data": [
    {
      "string": "PFJH",
      "flba": "GKJC"
    }
  ],
  "rows": 1,
  "statistics": {
    "rows_read": 1000,
    "bytes_read": 47419
  }
}
complex tuple in case, bf is on
{
  "data": [
    {
      "string": "PFJH",
      "flba": "GKJC"
    }
  ],
  "rows": 1,
  "statistics": {
    "rows_read": 464,
    "bytes_read": 21703
  }
}
complex tuple in case, bf is on. Non existent
{
  "data": [],
  "rows": 0,
  "statistics": {
    "rows_read": 0,
    "bytes_read": 0
  }
}
Bloom filter for json column. BF is off
{
  "data": [
    {
      "json": "{\"key\":38, \"value\":\"NXONM\"}"
    }
  ],
  "rows": 1,
  "statistics": {
    "rows_read": 1000,
    "bytes_read": 47419
  }
}
Bloom filter for json column. BF is on
{
  "data": [
    {
      "json": "{\"key\":38, \"value\":\"NXONM\"}"
    }
  ],
  "rows": 1,
  "statistics": {
    "rows_read": 72,
    "bytes_read": 4005
  }
}
Bloom filter for ipv4 column. BF is off
{
  "data": [
    {
      "json": "{\"key\":38, \"value\":\"NXONM\"}"
    }
  ],
  "rows": 1,
  "statistics": {
    "rows_read": 1000,
    "bytes_read": 47419
  }
}
Bloom filter for ipv4 column. BF is on
{
  "data": [
    {
      "json": "{\"key\":38, \"value\":\"NXONM\"}"
    }
  ],
  "rows": 1,
  "statistics": {
    "rows_read": 72,
    "bytes_read": 4005
  }
}
Bloom filter for ipv4 column. BF is on, but toIPv4(ipv4) = toIPv4('0.0.1.143') is not supported. Should read everything
{
  "data": [
    {
      "json": "{\"key\":38, \"value\":\"NXONM\"}"
    }
  ],
  "rows": 1,
  "statistics": {
    "rows_read": 1000,
    "bytes_read": 47419
  }
}
Bloom filter for ipv4 column. BF is on, but (toIPv4(ipv4)) in (toIPv4('0.0.1.143')) is not supported. Should read everything
{
  "data": [
    {
      "json": "{\"key\":38, \"value\":\"NXONM\"}"
    }
  ],
  "rows": 1,
  "statistics": {
    "rows_read": 1000,
    "bytes_read": 47419
  }
}
BF off for parquet uint64 logical type. Should read everything
{
  "data": [
    {
      "json": "{\"key\":683, \"value\":\"YKCPD\"}"
    }
  ],
  "rows": 1,
  "statistics": {
    "rows_read": 1000,
    "bytes_read": 47419
  }
}
BF on for parquet uint64 logical type. Should read everything
{
  "data": [
    {
      "json": "{\"key\":683, \"value\":\"YKCPD\"}"
    }
  ],
  "rows": 1,
  "statistics": {
    "rows_read": 464,
    "bytes_read": 21711
  }
}
