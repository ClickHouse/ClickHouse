import argparse
import json
import os

from contextlib import contextmanager
from pathlib import Path
from typing import Iterator

from git_helper import Git, commit, release_branch, GIT_PREFIX
from lambda_shared_package.lambda_shared.pr import Labels
from report import SUCCESS
from ssh import SSHKey
from env_helper import GITHUB_REPOSITORY
from version_helper import (
    FILE_WITH_VERSION_PATH,
    GENERATED_CONTRIBUTORS,
    ClickHouseVersion,
    VersionType,
    get_abs_path,
    get_version_from_repo,
    update_cmake_version,
    update_contributors,
)
from git_helper import git_runner as runner

CMAKE_PATH = get_abs_path(FILE_WITH_VERSION_PATH)
CONTRIBUTORS_PATH = get_abs_path(GENERATED_CONTRIBUTORS)
TAG_FILE = "./tag.tmp"

def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description="Creates release",
    )
    parser.add_argument(
        "--ref",
        required=True,
        type=str,
        help="the commit hash or branch",
    )
    parser.add_argument(
        "--type",
        required=True,
        choices=("new", "patch"),
        dest="release_type",
        help="a release type to bump the major.minor.patch version part, "
        "new branch is created only for the value 'new'",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="do not make any actual changes in the repo, just show what will be done",
    )

    return parser.parse_args()


@contextmanager
def checkout(ref: str) -> Iterator[None]:
    orig_ref = runner.run(f"{GIT_PREFIX} symbolic-ref --short HEAD")
    rollback_cmd = f"{GIT_PREFIX} checkout {orig_ref}"
    assert orig_ref
    if ref not in (orig_ref,):
        runner.run(f"{GIT_PREFIX} checkout {ref}")
    try:
        yield
    except (Exception, KeyboardInterrupt) as e:
        print(f"ERROR: Exception [{e}]")
        runner.run(rollback_cmd)
        raise
    runner.run(rollback_cmd)


@contextmanager
def checkout_new(ref: str) -> Iterator[None]:
    orig_ref = runner.run(f"{GIT_PREFIX} symbolic-ref --short HEAD")
    rollback_cmd = f"{GIT_PREFIX} checkout {orig_ref}"
    assert orig_ref
    runner.run(f"{GIT_PREFIX} checkout -b {ref}")
    try:
        yield
    except (Exception, KeyboardInterrupt) as e:
        print(f"ERROR: Exception [{e}]")
        runner.run(rollback_cmd)
        raise
    runner.run(rollback_cmd)


def main():
    args = parse_args()
    commit_ref = args.ref
    version = None
    dry_run = args.dry_run
    release_branch = None
    release_type = args.release_type
    release_tag = None
    assert release_type in ("patch",)
    assert dry_run
    Path(TAG_FILE).unlink(missing_ok=True)
    # if release_type == "new":
    #     assert False, "TODO"
    #     git = Git()
    #     version = get_version_from_repo(git=git)
    #     assert runner.check_command(
    #         f"git merge-base --is-ancestor {commit_ref} origin/master"
    #     )
    #     expected_tag = f"v{version.major}.{version.minor}-new"
    #     assert (
    #         git.latest_tag == expected_tag
    #     ), f"BUG: latest tag [{git.latest_tag}], expected [{expected_tag}]"
    #     release_branch = "master"
    if release_type == "patch":
        with checkout(commit_ref):
            # Git() must be inside "with checkout" contextmanager
            git = Git()
            version = get_version_from_repo(git=git)
            version.with_description(version.get_stable_release_type())
            release_branch = f"{version.major}.{version.minor}"
            release_tag = version.describe
        runner.run(f"{GIT_PREFIX} fetch origin {release_branch} --tags")
        assert runner.check_command(
            f"git merge-base --is-ancestor {commit_ref} origin/{release_branch}"
        )
        expected_tag = f"v{version.major}.{version.minor+1}-new"
        if git.latest_tag == expected_tag or (
            git.latest_tag.startswith(f"v{version.major}.{version.minor}.")
            and git.latest_tag.endswith("-stable")
        ):
            pass
        else:
            assert False, f"BUG: Unexpected latest tag [{git.latest_tag}]"

    # Bump version, update contributors list, create PR
    branch_upd_version_contributors = f"bump_version_{version.string}"
    with checkout(release_branch):
        with checkout_new(branch_upd_version_contributors):
            update_cmake_version(version)
            update_contributors(raise_error=True)
            cmd_commit_version_upd = f"{GIT_PREFIX} commit '{CMAKE_PATH}' '{CONTRIBUTORS_PATH}' -m 'Update autogenerated version to {version.string} and contributors'",
            cmd_push_branch = f"{GIT_PREFIX} push --set-upstream origin {branch_upd_version_contributors}"
            body_file = get_abs_path(".github/PULL_REQUEST_TEMPLATE.md")
            actor = os.getenv("GITHUB_ACTOR", "") or "me"
            cmd_create_pr = f"gh pr create --repo {GITHUB_REPOSITORY} --title 'Update version after release' --head {branch_upd_version_contributors} --body-file '{body_file} --label 'do not test' --assignee @{actor}"
            if not dry_run:
                runner.run(cmd_commit_version_upd)
                runner.run(cmd_push_branch)
                runner.run(cmd_create_pr)
            else:
                print("Dry run, would execute:")
                print(f"*    {cmd_commit_version_upd}")
                print(f"*    {cmd_push_branch}")
                print(f"*    {cmd_create_pr}")
                print("Dry run, diff:")
                print(
                    runner.run(
                        f"{GIT_PREFIX} diff '{CMAKE_PATH}' '{CONTRIBUTORS_PATH}'"
                    )
                )
                runner.run(
                    f"{GIT_PREFIX} checkout '{CMAKE_PATH}' '{CONTRIBUTORS_PATH}'"
                )
    assert release_branch and release_tag

    # Create release tag
    print("Create and push release tag")
    tag_message = f"Release {release_tag}"
    runner.run(f"{GIT_PREFIX} tag -a -m '{tag_message}' '{release_tag}' {commit_ref}")
    cmd_push_tag = f"{GIT_PREFIX} push origin {release_tag}:{release_tag}"
    if not dry_run:
        # TODO: cannot push - workflow will start
        #runner.run(cmd_commit_version_upd)
        pass
    else:
        print("Dry run, would execute:")
        print(f"*    {cmd_push_tag}")

    with open(TAG_FILE, "w") as text_file:
        text_file.write(release_tag)


if __name__ == "__main__":
    # assert os.getenv("ROBOT_CLICKHOUSE_SSH_KEY", "")
    if os.getenv("ROBOT_CLICKHOUSE_SSH_KEY", ""):
        with SSHKey("ROBOT_CLICKHOUSE_SSH_KEY"):
            main()
    else:
        main()
