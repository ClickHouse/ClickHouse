#!/usr/bin/env python3

import http.server
import os
import subprocess
import sys
import tempfile
import threading
import time
import unittest
import urllib


config = os.path.join(os.path.dirname(sys.argv[0]), 'config.xml')
test_csv = os.path.join(os.path.dirname(sys.argv[0]), 'test.csv')
format = 'column1 UInt32, column2 UInt32, column3 UInt32'
values = '(1, 2, 3), (3, 2, 1), (78, 43, 45)'
other_values = '(1, 1, 1), (1, 1, 1), (11, 11, 11)'
redirecting_host = '127.0.0.1'
redirecting_to_http_port = 12345
redirecting_to_https_port = 12346
preserving_data_port = 12347
redirecting_preserving_data_port = 12348
fakes3_port = 9990
localhost = '127.0.0.1'
bucket = 'abc'


prepare_put_queries = [
    "insert into table function s3('http://{}:{}/{}/test.csv', 'CSV', '{}') values {}".format(localhost, fakes3_port, bucket, format, values),
]

queries = [
    "select *, column1*column2*column3 from file('{}', 'CSV', '{}')".format(test_csv, format),
    "select *, column1*column2*column3 from url('https://storage.yandexcloud.net/milovidov/test.csv', 'CSV', '{}')".format(format),
    "select *, column1*column2*column3 from s3('http://storage.yandexcloud.net/milovidov/test.csv', 'CSV', '{}')".format(format),
    "select *, column1*column2*column3 from s3('http://{}:{}/{}/test.csv', 'CSV', '{}')".format(localhost, fakes3_port, bucket, format),
    "select *, column1*column2*column3 from s3('https://storage.yandexcloud.net/milovidov/test.csv', 'CSV', '{}')".format(format),
    "select *, column1*column2*column3 from s3('http://{}:{}/', 'CSV', '{}')".format(redirecting_host, redirecting_to_http_port, format),
    "select *, column1*column2*column3 from s3('http://{}:{}/', 'CSV', '{}')".format(redirecting_host, redirecting_to_https_port, format),
]

put_query = "insert into table function s3('http://{}:{}/', 'CSV', '{}') values {}".format(redirecting_host, preserving_data_port, format, values)

redirect_put_query = "insert into table function s3('http://{}:{}/', 'CSV', '{}') values {}".format(redirecting_host, redirecting_preserving_data_port, format, other_values)

check_queries = [
    "select *, column1*column2*column3 from s3('http://{}:{}/{}/test.csv', 'CSV', '{}')".format(localhost, fakes3_port, bucket, format),
]


def run_query(query):
    result = subprocess.run([os.path.expanduser('~/ClickHouse-bin/dbms/programs/clickhouse-local'), '-c', config, '-q', query]
        , stdout=subprocess.PIPE
        , universal_newlines=True)
    result.check_returncode()
    return result.stdout


class RedirectingToHTTPHTTPServer(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(307)
        self.send_header('Content-type', 'text/xml')
        self.send_header('Location', 'http://storage.yandexcloud.net/milovidov/test.csv')
        self.end_headers()
        self.wfile.write(r'''<?xml version="1.0" encoding="UTF-8"?>
<Error>
  <Code>TemporaryRedirect</Code>
  <Message>Please re-send this request to the specified temporary endpoint.
  Continue to use the original request endpoint for future requests.</Message>
  <Endpoint>storage.yandexcloud.net</Endpoint>
</Error>'''.encode())


class RedirectingToHTTPSHTTPServer(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(307)
        self.send_header('Content-type', 'text/xml')
        self.send_header('Location', 'https://storage.yandexcloud.net/milovidov/test.csv')
        self.end_headers()
        self.wfile.write(r'''<?xml version="1.0" encoding="UTF-8"?>
<Error>
  <Code>TemporaryRedirect</Code>
  <Message>Please re-send this request to the specified temporary endpoint.
  Continue to use the original request endpoint for future requests.</Message>
  <Endpoint>storage.yandexcloud.net</Endpoint>
</Error>'''.encode())


received_data = []
received_data_completed = False


class PreservingDataServer(http.server.BaseHTTPRequestHandler):
    protocol_version = 'HTTP/1.1'

    def handle_expect_100(self):
        print('Received Expect-100', file=sys.stderr)
        return True

    def do_POST(self):
        self.send_response(200)
        query = urllib.parse.urlparse(self.path).query
        print('POST', query)
        if query == 'uploads':
            data = r'''<?xml version="1.0" encoding="UTF-8"?>
<hi><UploadId>TEST</UploadId></hi>'''.encode()
            self.send_header('Content-length', str(len(data)))
            self.send_header('Content-type', 'text/plain')
            self.end_headers()
            self.wfile.write(data)
        else:
            data = self.rfile.read(int(self.headers.get('Content-Length')))
            assert query == 'uploadId=TEST'
            assert data == b'<CompleteMultipartUpload><Part><PartNumber>1</PartNumber><ETag>hello-etag</ETag></Part></CompleteMultipartUpload>'
            self.send_header('Content-type', 'text/plain')
            self.end_headers()
            global received_data_completed
            received_data_completed = True
 
    def do_PUT(self):
        self.send_response(200)
        self.send_header('Content-type', 'text/plain')
        self.send_header('ETag', 'hello-etag')
        self.end_headers()
        query = urllib.parse.urlparse(self.path).query
        print('Content-Length =', self.headers.get('Content-Length'), file=sys.stderr)
        print('PUT', query)
        assert self.headers.get('Content-Length')
        assert self.headers['Expect'] == '100-continue'
        received_data.append(self.rfile.read())
        self.wfile.flush()


class RedirectingPreservingDataServer(http.server.BaseHTTPRequestHandler):
    protocol_version = 'HTTP/1.1'

    def handle_expect_100(self):
        print('Received Expect-100', file=sys.stderr)
        query = urllib.parse.urlparse(self.path).query
        if query:
            query = '?{}'.format(query)
        self.send_response(307)
        self.send_header('Content-type', 'text/xml')
        self.send_header('Location', 'http://{host}:{port}/{bucket}/test.csv{query}'.format(host=localhost, port=fakes3_port, bucket=bucket, query=query))
        self.end_headers()
        self.wfile.write(r'''<?xml version="1.0" encoding="UTF-8"?>
<Error>
  <Code>TemporaryRedirect</Code>
  <Message>Please re-send this request to the specified temporary endpoint.
  Continue to use the original request endpoint for future requests.</Message>
  <Endpoint>{host}:{port}</Endpoint>
</Error>'''.encode().format(host=localhost, port=fakes3_port))
        return False

    def do_POST(self):
        assert False

    def do_PUT(self):
        assert False


servers = []
def redirecting_to_https_thread():
    server = http.server.HTTPServer((redirecting_host, redirecting_to_https_port), RedirectingToHTTPSHTTPServer)
    servers.append(server)
    server.handle_request()

def redirecting_to_http_thread():
    server = http.server.HTTPServer((redirecting_host, redirecting_to_http_port), RedirectingToHTTPHTTPServer)
    servers.append(server)
    server.handle_request()

def preserving_thread():
    server = http.server.HTTPServer((redirecting_host, preserving_data_port), PreservingDataServer)
    servers.append(server)
    while True:
        server.handle_request()

def redirecting_preserving_thread():
    server = http.server.HTTPServer((redirecting_host, redirecting_preserving_data_port), RedirectingPreservingDataServer)
    servers.append(server)
    while True:
        server.handle_request()


def run_gofakes3():
    l = threading.Lock()
    l.acquire()

    def gofakes3_thread():
        with tempfile.TemporaryDirectory() as d:
            try:
                subprocess.run(['git', 'clone', 'https://github.com/johannesboyne/gofakes3'], cwd=d).check_returncode()
                repo = os.path.join(d, 'gofakes3')
                subprocess.run(['git', 'checkout', 'd419e1bd286f47170a4f87851a81f5c30107551a'], cwd=repo).check_returncode()
                tool = os.path.join(repo, 'cmd', 'gofakes3', 'main.go')
                subprocess.run(['go', 'build', tool], cwd=repo).check_returncode()
            finally:
                l.release()
            binary = os.path.join(repo, 'main')
            subprocess.run([binary, '-backend', 'memory', '-host', ':{}'.format(fakes3_port), '-initialbucket', bucket]).check_returncode()

    thread = threading.Thread(target=gofakes3_thread)
    thread.start()
    l.acquire()
    time.sleep(0.5)
    l.release()
    return thread


def stop_subprocesses():
    pid = os.getpid()
    result = subprocess.run(['pgrep', '-P', str(pid)], stdout=subprocess.PIPE)
    result.check_returncode()
    for child_pid in result.stdout.splitlines():
        subprocess.run(['kill', child_pid]).check_returncode()


run_gofakes3()

jobs = []
jobs.append(threading.Thread(target=redirecting_to_http_thread))
jobs.append(threading.Thread(target=redirecting_to_https_thread))
jobs.append(threading.Thread(target=preserving_thread))
jobs.append(threading.Thread(target=redirecting_preserving_thread))
[ job.start() for job in jobs ]

for query in prepare_put_queries:
    print(query)
    run_query(query)

for query in queries:
    print(query)
    stdout = run_query(query)
    unittest.TestCase().assertEqual(list(map(str.split, stdout.splitlines())), [
        ['1', '2', '3', '6'],
        ['3', '2', '1', '6'],
        ['78', '43', '45', '150930'],
    ])

query = put_query
print(query)
received_data_completed = False
run_query(query)
unittest.TestCase().assertEqual(received_data[-1].decode(), '1,2,3\n3,2,1\n78,43,45\n')
unittest.TestCase().assertTrue(received_data_completed)

query = redirect_put_query
print(query)
run_query(query)

for query in check_queries:
    print(query)
    stdout = run_query(query)
    unittest.TestCase().assertEqual(list(map(str.split, stdout.splitlines())), [
        ['1', '1', '1', '1'],
        ['1', '1', '1', '1'],
        ['11', '11', '11', '1331'],
    ])

stop_subprocesses()

[ server.socket.close() for server in servers ]
[ job.join() for job in jobs ]
