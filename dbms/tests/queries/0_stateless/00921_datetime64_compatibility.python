#!/usr/bin/env python
# encoding: utf-8

import re
import itertools
import sys

# Create SQL statement to verify dateTime64 is accepted as argument to functions taking DateTime.
functions="""
toTimeZone({datetime}, 'UTC')
toYear({datetime})
toQuarter({datetime})
toMonth({datetime})
toDayOfYear({datetime})
toDayOfMonth({datetime})
toDayOfWeek({datetime})
toHour({datetime})
toMinute({datetime})
toSecond({datetime})
toUnixTimestamp({datetime})
toStartOfYear({datetime})
toStartOfISOYear({datetime})
toStartOfQuarter({datetime})
toStartOfMonth({datetime})
toMonday({datetime})
toStartOfWeek({datetime})
toStartOfDay({datetime})
toStartOfHour({datetime})
toStartOfMinute({datetime})
toStartOfFiveMinute({datetime})
toStartOfTenMinutes({datetime})
toStartOfFifteenMinutes({datetime})
# Do not work with DateTime64
toStartOfInterval({datetime}, INTERVAL 1 year)
toStartOfInterval({datetime}, INTERVAL 1 month)
toStartOfInterval({datetime}, INTERVAL 1 day)
toStartOfInterval({datetime}, INTERVAL 15 minute)
toTime({datetime})
toRelativeYearNum({datetime})
toRelativeQuarterNum({datetime})
toRelativeMonthNum({datetime})
toRelativeWeekNum({datetime})
toRelativeDayNum({datetime})
toRelativeHourNum({datetime})
toRelativeMinuteNum({datetime})
toRelativeSecondNum({datetime})
toISOYear({datetime})
toISOWeek({datetime})
toWeek({datetime})
toYearWeek({datetime})
timeSlot({datetime})
toYYYYMM({datetime})
toYYYYMMDD({datetime})
toYYYYMMDDhhmmss({datetime})
# --  Illegal type DateTime64 of argument of function addYears
addYears({datetime}, 1)
addMonths({datetime}, 1)
addWeeks({datetime}, 1)
addDays({datetime}, 1)
addHours({datetime}, 1)
addMinutes({datetime}, 1)
addSeconds({datetime}, 1)
addQuarters({datetime}, 1)
# -- Illegal type DateTime64 of argument of function subtractYears.
subtractYears({datetime}, 1)
subtractMonths({datetime}, 1)
subtractWeeks({datetime}, 1)
subtractDays({datetime}, 1)
subtractHours({datetime}, 1)
subtractMinutes({datetime}, 1)
subtractSeconds({datetime}, 1)
subtractQuarters({datetime}, 1)
CAST({datetime} as DateTime)
CAST({datetime} as Date)
CAST({datetime} as UInt64)
CAST({datetime} as DateTime64(0))
CAST({datetime} as DateTime64(3))
CAST({datetime} as DateTime64(6))
CAST({datetime} as DateTime64(9))
CAST({datetime} as DateTime64(12))
CAST({datetime} as DateTime64(18))
formatDateTime({datetime}, '%C %d %D %e %F %H %I %j %m %M %n %p %R %S %t %T %u %V %w %y %Y %%')
""".splitlines()

# filter out empty lines and commented out lines
COMMENTED_OUT_LINE_RE = re.compile(r"^\s*#")
functions = list(filter(lambda f: len(f) != 0 and COMMENTED_OUT_LINE_RE.match(f) == None, functions))

# Expanded to cartesian product of all arguments.
# NOTE: {{datetime}} to be turned into {datetime} after str.format() for keys (format string), but not for list of values!
extra_ops =\
[
    # With same type:
    (
        ['{{datetime}} {op} {{datetime}}'],
        {
            'op':
            [
                '- ', # does not work, but should it?
                '+ ', # does not work, but should it?
                '!=', '==', # equality and inequality supposed to take sub-second part in account
                '< ',
                '<=',
                '> ',
                '>='
            ]
        }
    ),
    # With other DateTime types:
    (
        [
            '{{datetime}} {op} {arg}',
            '{arg} {op} {{datetime}}'
        ],
        {
            'op':
            [
                '-', # does not work, but should it?
                '!=', '==',
                # these are naturally expected to work, but they don't:
                '< ',
                '<=',
                '> ',
                '>='
            ],
            'arg': ['now()', 'toDate(now())'],
        }
    ),
    # With arithmetic types
    (
        [
            '{{datetime}} {op} {arg}',
            '{arg} {op} {{datetime}}'
        ],
        {
            'op':
            [
                '+ ',
                '- ',
                '==',
                '!=',
                '< ',
                '<=',
                '> ',
                '>='
            ],
            'arg':
            [
                '1',
                '-1',
                'toInt64(1)',
                'toInt64(-1)'
            ],
        },
    ),
]

# Expand extra_ops here
for funcs, args in extra_ops:
    args_keys = args.keys()
    for args_vals in itertools.product(*args.values()):
        for func in funcs:
            result_func = func.format(**dict(zip(args_keys, args_vals)))
            functions.append(result_func)

datetime64_args = [ #'now64(0)', 'now64(3)', 'now64(6)', 'now64(9)', 'now64(17)']
    'now64(3)']

if sys.version_info[0] > 2:
    escape_string_codec = 'unicode_escape'
else:
    escape_string_codec = 'string-escape'

def escape_string(s):
    return s.encode(escape_string_codec).decode('utf-8')

# TODO: use string.Template here to allow lines that do not contain type, like: SELECT CAST(toDateTime64(1234567890), 'DateTime64')
for func in functions:
    for dt in datetime64_args:
        dt32 = func.format(datetime='now()')
        dt64 = func.format(datetime=dt)
        f = "'values match:', ({dt32}) == ({dt64}), 'types match:', toTypeName({dt32}) == toTypeName({dt64})".format(dt32=dt32, dt64=dt64)
        print("""SELECT 'SELECT {dt64}';""".format(dt64=escape_string(dt64)))    # for debug only
        print("""SELECT toTypeName({dt32}), {dt32};""".format(dt32=dt32)) # for debug only
        print("""SELECT toTypeName({dt64}), {dt64};""".format(dt64=dt64)) # for debug only
        print("""SELECT {f};""".format(f=f))
        print("""SELECT '------------------------------------------';""") # for debug only