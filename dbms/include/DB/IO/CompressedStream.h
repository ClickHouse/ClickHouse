#pragma once

/** Общие дефайны */

#define DBMS_MAX_COMPRESSED_SIZE 0x40000000ULL	/// 1GB

#define QUICKLZ_ADDITIONAL_SPACE 400
#define COMPRESSED_BLOCK_HEADER_SIZE 9


namespace DB
{

/** Метод сжатия */
enum class CompressionMethod
{
	QuickLZ = 0,
	LZ4 = 1,
	LZ4HC = 2,		/// Формат такой же, как у LZ4. Разница только при сжатии.
	ZSTD = 3,		/// Экспериментальный алгоритм: https://github.com/Cyan4973/zstd
};

/** Формат сжатого блока следующий:
  *
  * Первые 16 байт - чексумма от всех остальных байт блока. Сейчас используется только CityHash128.
  * В дальнейшем можно предусмотреть другие чексуммы, хотя сделать их другого размера не получится.
  *
  * Следующий байт определяет алгоритм сжатия. Далее всё зависит от алгоритма.
  *
  * Первые 4 варианта совместимы с QuickLZ level 1.
  * То есть, если значение первого байта < 4, для разжатия достаточно использовать функцию qlz_level1_decompress.
  *
  * 0x00 - несжатые данные, маленький блок. Далее один байт - размер сжатых данных, с учётом заголовка; один байт - размер несжатых данных.
  * 0x01 - сжатые данные, QuickLZ level 1, маленький блок. Далее два байта аналогично.
  * 0x02 - несжатые данные, большой блок. Далее 4 байта - размер сжатых данных, с учётом заголовка; 4 байта - размер несжатых данных.
  * 0x03 - сжатые данные, QuickLZ level 1, большой блок. Далее 8 байт аналогично.
  *
  * 0x82 - LZ4 или LZ4HC (они имеют одинаковый формат).
  *        Далее 4 байта - размер сжатых данных, с учётом заголовка; 4 байта - размер несжатых данных.
  *
  * NOTE: Почему 0x82?
  * Изначально использовался только QuickLZ. Потом был добавлен LZ4.
  * Старший бит выставлен, чтобы отличить от QuickLZ, а второй бит выставлен для совместимости,
  *  чтобы работали функции qlz_size_compressed, qlz_size_decompressed.
  * Хотя сейчас такая совместимость уже не актуальна.
  *
  * 0x90 - ZSTD
  *
  * Все размеры - little endian.
  */

enum class CompressionMethodByte : uint8_t
{
	LZ4 	= 0x82,
	ZSTD 	= 0x90,
};

}
