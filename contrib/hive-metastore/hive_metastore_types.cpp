/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "hive_metastore_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace Apache { namespace Hadoop { namespace Hive {

int _kHiveObjectTypeValues[] = {
  HiveObjectType::GLOBAL,
  HiveObjectType::DATABASE,
  HiveObjectType::TABLE,
  HiveObjectType::PARTITION,
  HiveObjectType::COLUMN
};
const char* _kHiveObjectTypeNames[] = {
  "GLOBAL",
  "DATABASE",
  "TABLE",
  "PARTITION",
  "COLUMN"
};
const std::map<int, const char*> _HiveObjectType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kHiveObjectTypeValues, _kHiveObjectTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const HiveObjectType::type& val) {
  std::map<int, const char*>::const_iterator it = _HiveObjectType_VALUES_TO_NAMES.find(val);
  if (it != _HiveObjectType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const HiveObjectType::type& val) {
  std::map<int, const char*>::const_iterator it = _HiveObjectType_VALUES_TO_NAMES.find(val);
  if (it != _HiveObjectType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kPrincipalTypeValues[] = {
  PrincipalType::USER,
  PrincipalType::ROLE,
  PrincipalType::GROUP
};
const char* _kPrincipalTypeNames[] = {
  "USER",
  "ROLE",
  "GROUP"
};
const std::map<int, const char*> _PrincipalType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kPrincipalTypeValues, _kPrincipalTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const PrincipalType::type& val) {
  std::map<int, const char*>::const_iterator it = _PrincipalType_VALUES_TO_NAMES.find(val);
  if (it != _PrincipalType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const PrincipalType::type& val) {
  std::map<int, const char*>::const_iterator it = _PrincipalType_VALUES_TO_NAMES.find(val);
  if (it != _PrincipalType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kPartitionEventTypeValues[] = {
  PartitionEventType::LOAD_DONE
};
const char* _kPartitionEventTypeNames[] = {
  "LOAD_DONE"
};
const std::map<int, const char*> _PartitionEventType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kPartitionEventTypeValues, _kPartitionEventTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const PartitionEventType::type& val) {
  std::map<int, const char*>::const_iterator it = _PartitionEventType_VALUES_TO_NAMES.find(val);
  if (it != _PartitionEventType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const PartitionEventType::type& val) {
  std::map<int, const char*>::const_iterator it = _PartitionEventType_VALUES_TO_NAMES.find(val);
  if (it != _PartitionEventType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTxnStateValues[] = {
  TxnState::COMMITTED,
  TxnState::ABORTED,
  TxnState::OPEN
};
const char* _kTxnStateNames[] = {
  "COMMITTED",
  "ABORTED",
  "OPEN"
};
const std::map<int, const char*> _TxnState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTxnStateValues, _kTxnStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TxnState::type& val) {
  std::map<int, const char*>::const_iterator it = _TxnState_VALUES_TO_NAMES.find(val);
  if (it != _TxnState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TxnState::type& val) {
  std::map<int, const char*>::const_iterator it = _TxnState_VALUES_TO_NAMES.find(val);
  if (it != _TxnState_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kLockLevelValues[] = {
  LockLevel::DB,
  LockLevel::TABLE,
  LockLevel::PARTITION
};
const char* _kLockLevelNames[] = {
  "DB",
  "TABLE",
  "PARTITION"
};
const std::map<int, const char*> _LockLevel_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kLockLevelValues, _kLockLevelNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const LockLevel::type& val) {
  std::map<int, const char*>::const_iterator it = _LockLevel_VALUES_TO_NAMES.find(val);
  if (it != _LockLevel_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const LockLevel::type& val) {
  std::map<int, const char*>::const_iterator it = _LockLevel_VALUES_TO_NAMES.find(val);
  if (it != _LockLevel_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kLockStateValues[] = {
  LockState::ACQUIRED,
  LockState::WAITING,
  LockState::ABORT,
  LockState::NOT_ACQUIRED
};
const char* _kLockStateNames[] = {
  "ACQUIRED",
  "WAITING",
  "ABORT",
  "NOT_ACQUIRED"
};
const std::map<int, const char*> _LockState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kLockStateValues, _kLockStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const LockState::type& val) {
  std::map<int, const char*>::const_iterator it = _LockState_VALUES_TO_NAMES.find(val);
  if (it != _LockState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const LockState::type& val) {
  std::map<int, const char*>::const_iterator it = _LockState_VALUES_TO_NAMES.find(val);
  if (it != _LockState_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kLockTypeValues[] = {
  LockType::SHARED_READ,
  LockType::SHARED_WRITE,
  LockType::EXCLUSIVE
};
const char* _kLockTypeNames[] = {
  "SHARED_READ",
  "SHARED_WRITE",
  "EXCLUSIVE"
};
const std::map<int, const char*> _LockType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kLockTypeValues, _kLockTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const LockType::type& val) {
  std::map<int, const char*>::const_iterator it = _LockType_VALUES_TO_NAMES.find(val);
  if (it != _LockType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const LockType::type& val) {
  std::map<int, const char*>::const_iterator it = _LockType_VALUES_TO_NAMES.find(val);
  if (it != _LockType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kCompactionTypeValues[] = {
  CompactionType::MINOR,
  CompactionType::MAJOR
};
const char* _kCompactionTypeNames[] = {
  "MINOR",
  "MAJOR"
};
const std::map<int, const char*> _CompactionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kCompactionTypeValues, _kCompactionTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const CompactionType::type& val) {
  std::map<int, const char*>::const_iterator it = _CompactionType_VALUES_TO_NAMES.find(val);
  if (it != _CompactionType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const CompactionType::type& val) {
  std::map<int, const char*>::const_iterator it = _CompactionType_VALUES_TO_NAMES.find(val);
  if (it != _CompactionType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kGrantRevokeTypeValues[] = {
  GrantRevokeType::GRANT,
  GrantRevokeType::REVOKE
};
const char* _kGrantRevokeTypeNames[] = {
  "GRANT",
  "REVOKE"
};
const std::map<int, const char*> _GrantRevokeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kGrantRevokeTypeValues, _kGrantRevokeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const GrantRevokeType::type& val) {
  std::map<int, const char*>::const_iterator it = _GrantRevokeType_VALUES_TO_NAMES.find(val);
  if (it != _GrantRevokeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const GrantRevokeType::type& val) {
  std::map<int, const char*>::const_iterator it = _GrantRevokeType_VALUES_TO_NAMES.find(val);
  if (it != _GrantRevokeType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kDataOperationTypeValues[] = {
  DataOperationType::SELECT,
  DataOperationType::INSERT,
  DataOperationType::UPDATE,
  DataOperationType::DELETE,
  DataOperationType::UNSET,
  DataOperationType::NO_TXN
};
const char* _kDataOperationTypeNames[] = {
  "SELECT",
  "INSERT",
  "UPDATE",
  "DELETE",
  "UNSET",
  "NO_TXN"
};
const std::map<int, const char*> _DataOperationType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kDataOperationTypeValues, _kDataOperationTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const DataOperationType::type& val) {
  std::map<int, const char*>::const_iterator it = _DataOperationType_VALUES_TO_NAMES.find(val);
  if (it != _DataOperationType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const DataOperationType::type& val) {
  std::map<int, const char*>::const_iterator it = _DataOperationType_VALUES_TO_NAMES.find(val);
  if (it != _DataOperationType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kEventRequestTypeValues[] = {
  EventRequestType::INSERT,
  EventRequestType::UPDATE,
  EventRequestType::DELETE
};
const char* _kEventRequestTypeNames[] = {
  "INSERT",
  "UPDATE",
  "DELETE"
};
const std::map<int, const char*> _EventRequestType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kEventRequestTypeValues, _kEventRequestTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const EventRequestType::type& val) {
  std::map<int, const char*>::const_iterator it = _EventRequestType_VALUES_TO_NAMES.find(val);
  if (it != _EventRequestType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const EventRequestType::type& val) {
  std::map<int, const char*>::const_iterator it = _EventRequestType_VALUES_TO_NAMES.find(val);
  if (it != _EventRequestType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kFunctionTypeValues[] = {
  FunctionType::JAVA
};
const char* _kFunctionTypeNames[] = {
  "JAVA"
};
const std::map<int, const char*> _FunctionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kFunctionTypeValues, _kFunctionTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const FunctionType::type& val) {
  std::map<int, const char*>::const_iterator it = _FunctionType_VALUES_TO_NAMES.find(val);
  if (it != _FunctionType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const FunctionType::type& val) {
  std::map<int, const char*>::const_iterator it = _FunctionType_VALUES_TO_NAMES.find(val);
  if (it != _FunctionType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kResourceTypeValues[] = {
  ResourceType::JAR,
  ResourceType::FILE,
  ResourceType::ARCHIVE
};
const char* _kResourceTypeNames[] = {
  "JAR",
  "FILE",
  "ARCHIVE"
};
const std::map<int, const char*> _ResourceType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kResourceTypeValues, _kResourceTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ResourceType::type& val) {
  std::map<int, const char*>::const_iterator it = _ResourceType_VALUES_TO_NAMES.find(val);
  if (it != _ResourceType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ResourceType::type& val) {
  std::map<int, const char*>::const_iterator it = _ResourceType_VALUES_TO_NAMES.find(val);
  if (it != _ResourceType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kFileMetadataExprTypeValues[] = {
  FileMetadataExprType::ORC_SARG
};
const char* _kFileMetadataExprTypeNames[] = {
  "ORC_SARG"
};
const std::map<int, const char*> _FileMetadataExprType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kFileMetadataExprTypeValues, _kFileMetadataExprTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const FileMetadataExprType::type& val) {
  std::map<int, const char*>::const_iterator it = _FileMetadataExprType_VALUES_TO_NAMES.find(val);
  if (it != _FileMetadataExprType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const FileMetadataExprType::type& val) {
  std::map<int, const char*>::const_iterator it = _FileMetadataExprType_VALUES_TO_NAMES.find(val);
  if (it != _FileMetadataExprType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kClientCapabilityValues[] = {
  ClientCapability::TEST_CAPABILITY,
  ClientCapability::INSERT_ONLY_TABLES
};
const char* _kClientCapabilityNames[] = {
  "TEST_CAPABILITY",
  "INSERT_ONLY_TABLES"
};
const std::map<int, const char*> _ClientCapability_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kClientCapabilityValues, _kClientCapabilityNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ClientCapability::type& val) {
  std::map<int, const char*>::const_iterator it = _ClientCapability_VALUES_TO_NAMES.find(val);
  if (it != _ClientCapability_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ClientCapability::type& val) {
  std::map<int, const char*>::const_iterator it = _ClientCapability_VALUES_TO_NAMES.find(val);
  if (it != _ClientCapability_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kWMResourcePlanStatusValues[] = {
  WMResourcePlanStatus::ACTIVE,
  WMResourcePlanStatus::ENABLED,
  WMResourcePlanStatus::DISABLED
};
const char* _kWMResourcePlanStatusNames[] = {
  "ACTIVE",
  "ENABLED",
  "DISABLED"
};
const std::map<int, const char*> _WMResourcePlanStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kWMResourcePlanStatusValues, _kWMResourcePlanStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const WMResourcePlanStatus::type& val) {
  std::map<int, const char*>::const_iterator it = _WMResourcePlanStatus_VALUES_TO_NAMES.find(val);
  if (it != _WMResourcePlanStatus_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const WMResourcePlanStatus::type& val) {
  std::map<int, const char*>::const_iterator it = _WMResourcePlanStatus_VALUES_TO_NAMES.find(val);
  if (it != _WMResourcePlanStatus_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


Version::~Version() noexcept {
}


void Version::__set_version(const std::string& val) {
  this->version = val;
}

void Version::__set_comments(const std::string& val) {
  this->comments = val;
}
std::ostream& operator<<(std::ostream& out, const Version& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Version::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comments);
          this->__isset.comments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Version::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Version");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comments", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->comments);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Version &a, Version &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.comments, b.comments);
  swap(a.__isset, b.__isset);
}

Version::Version(const Version& other0) {
  version = other0.version;
  comments = other0.comments;
  __isset = other0.__isset;
}
Version& Version::operator=(const Version& other1) {
  version = other1.version;
  comments = other1.comments;
  __isset = other1.__isset;
  return *this;
}
void Version::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Version(";
  out << "version=" << to_string(version);
  out << ", " << "comments=" << to_string(comments);
  out << ")";
}


FieldSchema::~FieldSchema() noexcept {
}


void FieldSchema::__set_name(const std::string& val) {
  this->name = val;
}

void FieldSchema::__set_type(const std::string& val) {
  this->type = val;
}

void FieldSchema::__set_comment(const std::string& val) {
  this->comment = val;
}
std::ostream& operator<<(std::ostream& out, const FieldSchema& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FieldSchema::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FieldSchema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FieldSchema");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->comment);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FieldSchema &a, FieldSchema &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

FieldSchema::FieldSchema(const FieldSchema& other2) {
  name = other2.name;
  type = other2.type;
  comment = other2.comment;
  __isset = other2.__isset;
}
FieldSchema& FieldSchema::operator=(const FieldSchema& other3) {
  name = other3.name;
  type = other3.type;
  comment = other3.comment;
  __isset = other3.__isset;
  return *this;
}
void FieldSchema::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FieldSchema(";
  out << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "comment=" << to_string(comment);
  out << ")";
}


SQLPrimaryKey::~SQLPrimaryKey() noexcept {
}


void SQLPrimaryKey::__set_table_db(const std::string& val) {
  this->table_db = val;
}

void SQLPrimaryKey::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void SQLPrimaryKey::__set_column_name(const std::string& val) {
  this->column_name = val;
}

void SQLPrimaryKey::__set_key_seq(const int32_t val) {
  this->key_seq = val;
}

void SQLPrimaryKey::__set_pk_name(const std::string& val) {
  this->pk_name = val;
}

void SQLPrimaryKey::__set_enable_cstr(const bool val) {
  this->enable_cstr = val;
}

void SQLPrimaryKey::__set_validate_cstr(const bool val) {
  this->validate_cstr = val;
}

void SQLPrimaryKey::__set_rely_cstr(const bool val) {
  this->rely_cstr = val;
}
std::ostream& operator<<(std::ostream& out, const SQLPrimaryKey& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SQLPrimaryKey::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_db);
          this->__isset.table_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->key_seq);
          this->__isset.key_seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pk_name);
          this->__isset.pk_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enable_cstr);
          this->__isset.enable_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->validate_cstr);
          this->__isset.validate_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rely_cstr);
          this->__isset.rely_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SQLPrimaryKey::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SQLPrimaryKey");

  xfer += oprot->writeFieldBegin("table_db", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->table_db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_seq", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->key_seq);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pk_name", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->pk_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enable_cstr", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->enable_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validate_cstr", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->validate_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rely_cstr", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->rely_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SQLPrimaryKey &a, SQLPrimaryKey &b) {
  using ::std::swap;
  swap(a.table_db, b.table_db);
  swap(a.table_name, b.table_name);
  swap(a.column_name, b.column_name);
  swap(a.key_seq, b.key_seq);
  swap(a.pk_name, b.pk_name);
  swap(a.enable_cstr, b.enable_cstr);
  swap(a.validate_cstr, b.validate_cstr);
  swap(a.rely_cstr, b.rely_cstr);
  swap(a.__isset, b.__isset);
}

SQLPrimaryKey::SQLPrimaryKey(const SQLPrimaryKey& other4) {
  table_db = other4.table_db;
  table_name = other4.table_name;
  column_name = other4.column_name;
  key_seq = other4.key_seq;
  pk_name = other4.pk_name;
  enable_cstr = other4.enable_cstr;
  validate_cstr = other4.validate_cstr;
  rely_cstr = other4.rely_cstr;
  __isset = other4.__isset;
}
SQLPrimaryKey& SQLPrimaryKey::operator=(const SQLPrimaryKey& other5) {
  table_db = other5.table_db;
  table_name = other5.table_name;
  column_name = other5.column_name;
  key_seq = other5.key_seq;
  pk_name = other5.pk_name;
  enable_cstr = other5.enable_cstr;
  validate_cstr = other5.validate_cstr;
  rely_cstr = other5.rely_cstr;
  __isset = other5.__isset;
  return *this;
}
void SQLPrimaryKey::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SQLPrimaryKey(";
  out << "table_db=" << to_string(table_db);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "column_name=" << to_string(column_name);
  out << ", " << "key_seq=" << to_string(key_seq);
  out << ", " << "pk_name=" << to_string(pk_name);
  out << ", " << "enable_cstr=" << to_string(enable_cstr);
  out << ", " << "validate_cstr=" << to_string(validate_cstr);
  out << ", " << "rely_cstr=" << to_string(rely_cstr);
  out << ")";
}


SQLForeignKey::~SQLForeignKey() noexcept {
}


void SQLForeignKey::__set_pktable_db(const std::string& val) {
  this->pktable_db = val;
}

void SQLForeignKey::__set_pktable_name(const std::string& val) {
  this->pktable_name = val;
}

void SQLForeignKey::__set_pkcolumn_name(const std::string& val) {
  this->pkcolumn_name = val;
}

void SQLForeignKey::__set_fktable_db(const std::string& val) {
  this->fktable_db = val;
}

void SQLForeignKey::__set_fktable_name(const std::string& val) {
  this->fktable_name = val;
}

void SQLForeignKey::__set_fkcolumn_name(const std::string& val) {
  this->fkcolumn_name = val;
}

void SQLForeignKey::__set_key_seq(const int32_t val) {
  this->key_seq = val;
}

void SQLForeignKey::__set_update_rule(const int32_t val) {
  this->update_rule = val;
}

void SQLForeignKey::__set_delete_rule(const int32_t val) {
  this->delete_rule = val;
}

void SQLForeignKey::__set_fk_name(const std::string& val) {
  this->fk_name = val;
}

void SQLForeignKey::__set_pk_name(const std::string& val) {
  this->pk_name = val;
}

void SQLForeignKey::__set_enable_cstr(const bool val) {
  this->enable_cstr = val;
}

void SQLForeignKey::__set_validate_cstr(const bool val) {
  this->validate_cstr = val;
}

void SQLForeignKey::__set_rely_cstr(const bool val) {
  this->rely_cstr = val;
}
std::ostream& operator<<(std::ostream& out, const SQLForeignKey& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SQLForeignKey::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pktable_db);
          this->__isset.pktable_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pktable_name);
          this->__isset.pktable_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pkcolumn_name);
          this->__isset.pkcolumn_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fktable_db);
          this->__isset.fktable_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fktable_name);
          this->__isset.fktable_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fkcolumn_name);
          this->__isset.fkcolumn_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->key_seq);
          this->__isset.key_seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->update_rule);
          this->__isset.update_rule = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->delete_rule);
          this->__isset.delete_rule = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fk_name);
          this->__isset.fk_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pk_name);
          this->__isset.pk_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enable_cstr);
          this->__isset.enable_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->validate_cstr);
          this->__isset.validate_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rely_cstr);
          this->__isset.rely_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SQLForeignKey::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SQLForeignKey");

  xfer += oprot->writeFieldBegin("pktable_db", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->pktable_db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pktable_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->pktable_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pkcolumn_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->pkcolumn_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fktable_db", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->fktable_db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fktable_name", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->fktable_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fkcolumn_name", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->fkcolumn_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_seq", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->key_seq);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_rule", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->update_rule);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delete_rule", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->delete_rule);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fk_name", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->fk_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pk_name", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->pk_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enable_cstr", ::apache::thrift::protocol::T_BOOL, 12);
  xfer += oprot->writeBool(this->enable_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validate_cstr", ::apache::thrift::protocol::T_BOOL, 13);
  xfer += oprot->writeBool(this->validate_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rely_cstr", ::apache::thrift::protocol::T_BOOL, 14);
  xfer += oprot->writeBool(this->rely_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SQLForeignKey &a, SQLForeignKey &b) {
  using ::std::swap;
  swap(a.pktable_db, b.pktable_db);
  swap(a.pktable_name, b.pktable_name);
  swap(a.pkcolumn_name, b.pkcolumn_name);
  swap(a.fktable_db, b.fktable_db);
  swap(a.fktable_name, b.fktable_name);
  swap(a.fkcolumn_name, b.fkcolumn_name);
  swap(a.key_seq, b.key_seq);
  swap(a.update_rule, b.update_rule);
  swap(a.delete_rule, b.delete_rule);
  swap(a.fk_name, b.fk_name);
  swap(a.pk_name, b.pk_name);
  swap(a.enable_cstr, b.enable_cstr);
  swap(a.validate_cstr, b.validate_cstr);
  swap(a.rely_cstr, b.rely_cstr);
  swap(a.__isset, b.__isset);
}

SQLForeignKey::SQLForeignKey(const SQLForeignKey& other6) {
  pktable_db = other6.pktable_db;
  pktable_name = other6.pktable_name;
  pkcolumn_name = other6.pkcolumn_name;
  fktable_db = other6.fktable_db;
  fktable_name = other6.fktable_name;
  fkcolumn_name = other6.fkcolumn_name;
  key_seq = other6.key_seq;
  update_rule = other6.update_rule;
  delete_rule = other6.delete_rule;
  fk_name = other6.fk_name;
  pk_name = other6.pk_name;
  enable_cstr = other6.enable_cstr;
  validate_cstr = other6.validate_cstr;
  rely_cstr = other6.rely_cstr;
  __isset = other6.__isset;
}
SQLForeignKey& SQLForeignKey::operator=(const SQLForeignKey& other7) {
  pktable_db = other7.pktable_db;
  pktable_name = other7.pktable_name;
  pkcolumn_name = other7.pkcolumn_name;
  fktable_db = other7.fktable_db;
  fktable_name = other7.fktable_name;
  fkcolumn_name = other7.fkcolumn_name;
  key_seq = other7.key_seq;
  update_rule = other7.update_rule;
  delete_rule = other7.delete_rule;
  fk_name = other7.fk_name;
  pk_name = other7.pk_name;
  enable_cstr = other7.enable_cstr;
  validate_cstr = other7.validate_cstr;
  rely_cstr = other7.rely_cstr;
  __isset = other7.__isset;
  return *this;
}
void SQLForeignKey::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SQLForeignKey(";
  out << "pktable_db=" << to_string(pktable_db);
  out << ", " << "pktable_name=" << to_string(pktable_name);
  out << ", " << "pkcolumn_name=" << to_string(pkcolumn_name);
  out << ", " << "fktable_db=" << to_string(fktable_db);
  out << ", " << "fktable_name=" << to_string(fktable_name);
  out << ", " << "fkcolumn_name=" << to_string(fkcolumn_name);
  out << ", " << "key_seq=" << to_string(key_seq);
  out << ", " << "update_rule=" << to_string(update_rule);
  out << ", " << "delete_rule=" << to_string(delete_rule);
  out << ", " << "fk_name=" << to_string(fk_name);
  out << ", " << "pk_name=" << to_string(pk_name);
  out << ", " << "enable_cstr=" << to_string(enable_cstr);
  out << ", " << "validate_cstr=" << to_string(validate_cstr);
  out << ", " << "rely_cstr=" << to_string(rely_cstr);
  out << ")";
}


SQLUniqueConstraint::~SQLUniqueConstraint() noexcept {
}


void SQLUniqueConstraint::__set_table_db(const std::string& val) {
  this->table_db = val;
}

void SQLUniqueConstraint::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void SQLUniqueConstraint::__set_column_name(const std::string& val) {
  this->column_name = val;
}

void SQLUniqueConstraint::__set_key_seq(const int32_t val) {
  this->key_seq = val;
}

void SQLUniqueConstraint::__set_uk_name(const std::string& val) {
  this->uk_name = val;
}

void SQLUniqueConstraint::__set_enable_cstr(const bool val) {
  this->enable_cstr = val;
}

void SQLUniqueConstraint::__set_validate_cstr(const bool val) {
  this->validate_cstr = val;
}

void SQLUniqueConstraint::__set_rely_cstr(const bool val) {
  this->rely_cstr = val;
}
std::ostream& operator<<(std::ostream& out, const SQLUniqueConstraint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SQLUniqueConstraint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_db);
          this->__isset.table_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->key_seq);
          this->__isset.key_seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uk_name);
          this->__isset.uk_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enable_cstr);
          this->__isset.enable_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->validate_cstr);
          this->__isset.validate_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rely_cstr);
          this->__isset.rely_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SQLUniqueConstraint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SQLUniqueConstraint");

  xfer += oprot->writeFieldBegin("table_db", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->table_db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_seq", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->key_seq);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uk_name", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->uk_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enable_cstr", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->enable_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validate_cstr", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->validate_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rely_cstr", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->rely_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SQLUniqueConstraint &a, SQLUniqueConstraint &b) {
  using ::std::swap;
  swap(a.table_db, b.table_db);
  swap(a.table_name, b.table_name);
  swap(a.column_name, b.column_name);
  swap(a.key_seq, b.key_seq);
  swap(a.uk_name, b.uk_name);
  swap(a.enable_cstr, b.enable_cstr);
  swap(a.validate_cstr, b.validate_cstr);
  swap(a.rely_cstr, b.rely_cstr);
  swap(a.__isset, b.__isset);
}

SQLUniqueConstraint::SQLUniqueConstraint(const SQLUniqueConstraint& other8) {
  table_db = other8.table_db;
  table_name = other8.table_name;
  column_name = other8.column_name;
  key_seq = other8.key_seq;
  uk_name = other8.uk_name;
  enable_cstr = other8.enable_cstr;
  validate_cstr = other8.validate_cstr;
  rely_cstr = other8.rely_cstr;
  __isset = other8.__isset;
}
SQLUniqueConstraint& SQLUniqueConstraint::operator=(const SQLUniqueConstraint& other9) {
  table_db = other9.table_db;
  table_name = other9.table_name;
  column_name = other9.column_name;
  key_seq = other9.key_seq;
  uk_name = other9.uk_name;
  enable_cstr = other9.enable_cstr;
  validate_cstr = other9.validate_cstr;
  rely_cstr = other9.rely_cstr;
  __isset = other9.__isset;
  return *this;
}
void SQLUniqueConstraint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SQLUniqueConstraint(";
  out << "table_db=" << to_string(table_db);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "column_name=" << to_string(column_name);
  out << ", " << "key_seq=" << to_string(key_seq);
  out << ", " << "uk_name=" << to_string(uk_name);
  out << ", " << "enable_cstr=" << to_string(enable_cstr);
  out << ", " << "validate_cstr=" << to_string(validate_cstr);
  out << ", " << "rely_cstr=" << to_string(rely_cstr);
  out << ")";
}


SQLNotNullConstraint::~SQLNotNullConstraint() noexcept {
}


void SQLNotNullConstraint::__set_table_db(const std::string& val) {
  this->table_db = val;
}

void SQLNotNullConstraint::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void SQLNotNullConstraint::__set_column_name(const std::string& val) {
  this->column_name = val;
}

void SQLNotNullConstraint::__set_nn_name(const std::string& val) {
  this->nn_name = val;
}

void SQLNotNullConstraint::__set_enable_cstr(const bool val) {
  this->enable_cstr = val;
}

void SQLNotNullConstraint::__set_validate_cstr(const bool val) {
  this->validate_cstr = val;
}

void SQLNotNullConstraint::__set_rely_cstr(const bool val) {
  this->rely_cstr = val;
}
std::ostream& operator<<(std::ostream& out, const SQLNotNullConstraint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SQLNotNullConstraint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_db);
          this->__isset.table_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nn_name);
          this->__isset.nn_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enable_cstr);
          this->__isset.enable_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->validate_cstr);
          this->__isset.validate_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rely_cstr);
          this->__isset.rely_cstr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SQLNotNullConstraint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SQLNotNullConstraint");

  xfer += oprot->writeFieldBegin("table_db", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->table_db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nn_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nn_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enable_cstr", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->enable_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validate_cstr", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->validate_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rely_cstr", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->rely_cstr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SQLNotNullConstraint &a, SQLNotNullConstraint &b) {
  using ::std::swap;
  swap(a.table_db, b.table_db);
  swap(a.table_name, b.table_name);
  swap(a.column_name, b.column_name);
  swap(a.nn_name, b.nn_name);
  swap(a.enable_cstr, b.enable_cstr);
  swap(a.validate_cstr, b.validate_cstr);
  swap(a.rely_cstr, b.rely_cstr);
  swap(a.__isset, b.__isset);
}

SQLNotNullConstraint::SQLNotNullConstraint(const SQLNotNullConstraint& other10) {
  table_db = other10.table_db;
  table_name = other10.table_name;
  column_name = other10.column_name;
  nn_name = other10.nn_name;
  enable_cstr = other10.enable_cstr;
  validate_cstr = other10.validate_cstr;
  rely_cstr = other10.rely_cstr;
  __isset = other10.__isset;
}
SQLNotNullConstraint& SQLNotNullConstraint::operator=(const SQLNotNullConstraint& other11) {
  table_db = other11.table_db;
  table_name = other11.table_name;
  column_name = other11.column_name;
  nn_name = other11.nn_name;
  enable_cstr = other11.enable_cstr;
  validate_cstr = other11.validate_cstr;
  rely_cstr = other11.rely_cstr;
  __isset = other11.__isset;
  return *this;
}
void SQLNotNullConstraint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SQLNotNullConstraint(";
  out << "table_db=" << to_string(table_db);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "column_name=" << to_string(column_name);
  out << ", " << "nn_name=" << to_string(nn_name);
  out << ", " << "enable_cstr=" << to_string(enable_cstr);
  out << ", " << "validate_cstr=" << to_string(validate_cstr);
  out << ", " << "rely_cstr=" << to_string(rely_cstr);
  out << ")";
}


Type::~Type() noexcept {
}


void Type::__set_name(const std::string& val) {
  this->name = val;
}

void Type::__set_type1(const std::string& val) {
  this->type1 = val;
__isset.type1 = true;
}

void Type::__set_type2(const std::string& val) {
  this->type2 = val;
__isset.type2 = true;
}

void Type::__set_fields(const std::vector<FieldSchema> & val) {
  this->fields = val;
__isset.fields = true;
}
std::ostream& operator<<(std::ostream& out, const Type& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Type::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type1);
          this->__isset.type1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type2);
          this->__isset.type2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fields.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->fields.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += this->fields[_i16].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Type::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Type");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.type1) {
    xfer += oprot->writeFieldBegin("type1", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->type1);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type2) {
    xfer += oprot->writeFieldBegin("type2", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->type2);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fields) {
    xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fields.size()));
      std::vector<FieldSchema> ::const_iterator _iter17;
      for (_iter17 = this->fields.begin(); _iter17 != this->fields.end(); ++_iter17)
      {
        xfer += (*_iter17).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Type &a, Type &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.type1, b.type1);
  swap(a.type2, b.type2);
  swap(a.fields, b.fields);
  swap(a.__isset, b.__isset);
}

Type::Type(const Type& other18) {
  name = other18.name;
  type1 = other18.type1;
  type2 = other18.type2;
  fields = other18.fields;
  __isset = other18.__isset;
}
Type& Type::operator=(const Type& other19) {
  name = other19.name;
  type1 = other19.type1;
  type2 = other19.type2;
  fields = other19.fields;
  __isset = other19.__isset;
  return *this;
}
void Type::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Type(";
  out << "name=" << to_string(name);
  out << ", " << "type1="; (__isset.type1 ? (out << to_string(type1)) : (out << "<null>"));
  out << ", " << "type2="; (__isset.type2 ? (out << to_string(type2)) : (out << "<null>"));
  out << ", " << "fields="; (__isset.fields ? (out << to_string(fields)) : (out << "<null>"));
  out << ")";
}


HiveObjectRef::~HiveObjectRef() noexcept {
}


void HiveObjectRef::__set_objectType(const HiveObjectType::type val) {
  this->objectType = val;
}

void HiveObjectRef::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void HiveObjectRef::__set_objectName(const std::string& val) {
  this->objectName = val;
}

void HiveObjectRef::__set_partValues(const std::vector<std::string> & val) {
  this->partValues = val;
}

void HiveObjectRef::__set_columnName(const std::string& val) {
  this->columnName = val;
}
std::ostream& operator<<(std::ostream& out, const HiveObjectRef& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HiveObjectRef::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast20;
          xfer += iprot->readI32(ecast20);
          this->objectType = (HiveObjectType::type)ecast20;
          this->__isset.objectType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->objectName);
          this->__isset.objectName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partValues.clear();
            uint32_t _size21;
            ::apache::thrift::protocol::TType _etype24;
            xfer += iprot->readListBegin(_etype24, _size21);
            this->partValues.resize(_size21);
            uint32_t _i25;
            for (_i25 = 0; _i25 < _size21; ++_i25)
            {
              xfer += iprot->readString(this->partValues[_i25]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnName);
          this->__isset.columnName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HiveObjectRef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HiveObjectRef");

  xfer += oprot->writeFieldBegin("objectType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->objectType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("objectName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->objectName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partValues", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partValues.size()));
    std::vector<std::string> ::const_iterator _iter26;
    for (_iter26 = this->partValues.begin(); _iter26 != this->partValues.end(); ++_iter26)
    {
      xfer += oprot->writeString((*_iter26));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columnName", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->columnName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HiveObjectRef &a, HiveObjectRef &b) {
  using ::std::swap;
  swap(a.objectType, b.objectType);
  swap(a.dbName, b.dbName);
  swap(a.objectName, b.objectName);
  swap(a.partValues, b.partValues);
  swap(a.columnName, b.columnName);
  swap(a.__isset, b.__isset);
}

HiveObjectRef::HiveObjectRef(const HiveObjectRef& other27) {
  objectType = other27.objectType;
  dbName = other27.dbName;
  objectName = other27.objectName;
  partValues = other27.partValues;
  columnName = other27.columnName;
  __isset = other27.__isset;
}
HiveObjectRef& HiveObjectRef::operator=(const HiveObjectRef& other28) {
  objectType = other28.objectType;
  dbName = other28.dbName;
  objectName = other28.objectName;
  partValues = other28.partValues;
  columnName = other28.columnName;
  __isset = other28.__isset;
  return *this;
}
void HiveObjectRef::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HiveObjectRef(";
  out << "objectType=" << to_string(objectType);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "objectName=" << to_string(objectName);
  out << ", " << "partValues=" << to_string(partValues);
  out << ", " << "columnName=" << to_string(columnName);
  out << ")";
}


PrivilegeGrantInfo::~PrivilegeGrantInfo() noexcept {
}


void PrivilegeGrantInfo::__set_privilege(const std::string& val) {
  this->privilege = val;
}

void PrivilegeGrantInfo::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void PrivilegeGrantInfo::__set_grantor(const std::string& val) {
  this->grantor = val;
}

void PrivilegeGrantInfo::__set_grantorType(const PrincipalType::type val) {
  this->grantorType = val;
}

void PrivilegeGrantInfo::__set_grantOption(const bool val) {
  this->grantOption = val;
}
std::ostream& operator<<(std::ostream& out, const PrivilegeGrantInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PrivilegeGrantInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->privilege);
          this->__isset.privilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->grantor);
          this->__isset.grantor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast29;
          xfer += iprot->readI32(ecast29);
          this->grantorType = (PrincipalType::type)ecast29;
          this->__isset.grantorType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->grantOption);
          this->__isset.grantOption = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PrivilegeGrantInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PrivilegeGrantInfo");

  xfer += oprot->writeFieldBegin("privilege", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->privilege);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantor", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->grantor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantorType", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->grantorType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantOption", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->grantOption);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PrivilegeGrantInfo &a, PrivilegeGrantInfo &b) {
  using ::std::swap;
  swap(a.privilege, b.privilege);
  swap(a.createTime, b.createTime);
  swap(a.grantor, b.grantor);
  swap(a.grantorType, b.grantorType);
  swap(a.grantOption, b.grantOption);
  swap(a.__isset, b.__isset);
}

PrivilegeGrantInfo::PrivilegeGrantInfo(const PrivilegeGrantInfo& other30) {
  privilege = other30.privilege;
  createTime = other30.createTime;
  grantor = other30.grantor;
  grantorType = other30.grantorType;
  grantOption = other30.grantOption;
  __isset = other30.__isset;
}
PrivilegeGrantInfo& PrivilegeGrantInfo::operator=(const PrivilegeGrantInfo& other31) {
  privilege = other31.privilege;
  createTime = other31.createTime;
  grantor = other31.grantor;
  grantorType = other31.grantorType;
  grantOption = other31.grantOption;
  __isset = other31.__isset;
  return *this;
}
void PrivilegeGrantInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PrivilegeGrantInfo(";
  out << "privilege=" << to_string(privilege);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "grantor=" << to_string(grantor);
  out << ", " << "grantorType=" << to_string(grantorType);
  out << ", " << "grantOption=" << to_string(grantOption);
  out << ")";
}


HiveObjectPrivilege::~HiveObjectPrivilege() noexcept {
}


void HiveObjectPrivilege::__set_hiveObject(const HiveObjectRef& val) {
  this->hiveObject = val;
}

void HiveObjectPrivilege::__set_principalName(const std::string& val) {
  this->principalName = val;
}

void HiveObjectPrivilege::__set_principalType(const PrincipalType::type val) {
  this->principalType = val;
}

void HiveObjectPrivilege::__set_grantInfo(const PrivilegeGrantInfo& val) {
  this->grantInfo = val;
}
std::ostream& operator<<(std::ostream& out, const HiveObjectPrivilege& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HiveObjectPrivilege::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hiveObject.read(iprot);
          this->__isset.hiveObject = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->principalName);
          this->__isset.principalName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast32;
          xfer += iprot->readI32(ecast32);
          this->principalType = (PrincipalType::type)ecast32;
          this->__isset.principalType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->grantInfo.read(iprot);
          this->__isset.grantInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HiveObjectPrivilege::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HiveObjectPrivilege");

  xfer += oprot->writeFieldBegin("hiveObject", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->hiveObject.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->principalName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->principalType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantInfo", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->grantInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HiveObjectPrivilege &a, HiveObjectPrivilege &b) {
  using ::std::swap;
  swap(a.hiveObject, b.hiveObject);
  swap(a.principalName, b.principalName);
  swap(a.principalType, b.principalType);
  swap(a.grantInfo, b.grantInfo);
  swap(a.__isset, b.__isset);
}

HiveObjectPrivilege::HiveObjectPrivilege(const HiveObjectPrivilege& other33) {
  hiveObject = other33.hiveObject;
  principalName = other33.principalName;
  principalType = other33.principalType;
  grantInfo = other33.grantInfo;
  __isset = other33.__isset;
}
HiveObjectPrivilege& HiveObjectPrivilege::operator=(const HiveObjectPrivilege& other34) {
  hiveObject = other34.hiveObject;
  principalName = other34.principalName;
  principalType = other34.principalType;
  grantInfo = other34.grantInfo;
  __isset = other34.__isset;
  return *this;
}
void HiveObjectPrivilege::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HiveObjectPrivilege(";
  out << "hiveObject=" << to_string(hiveObject);
  out << ", " << "principalName=" << to_string(principalName);
  out << ", " << "principalType=" << to_string(principalType);
  out << ", " << "grantInfo=" << to_string(grantInfo);
  out << ")";
}


PrivilegeBag::~PrivilegeBag() noexcept {
}


void PrivilegeBag::__set_privileges(const std::vector<HiveObjectPrivilege> & val) {
  this->privileges = val;
}
std::ostream& operator<<(std::ostream& out, const PrivilegeBag& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PrivilegeBag::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->privileges.clear();
            uint32_t _size35;
            ::apache::thrift::protocol::TType _etype38;
            xfer += iprot->readListBegin(_etype38, _size35);
            this->privileges.resize(_size35);
            uint32_t _i39;
            for (_i39 = 0; _i39 < _size35; ++_i39)
            {
              xfer += this->privileges[_i39].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PrivilegeBag::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PrivilegeBag");

  xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->privileges.size()));
    std::vector<HiveObjectPrivilege> ::const_iterator _iter40;
    for (_iter40 = this->privileges.begin(); _iter40 != this->privileges.end(); ++_iter40)
    {
      xfer += (*_iter40).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PrivilegeBag &a, PrivilegeBag &b) {
  using ::std::swap;
  swap(a.privileges, b.privileges);
  swap(a.__isset, b.__isset);
}

PrivilegeBag::PrivilegeBag(const PrivilegeBag& other41) {
  privileges = other41.privileges;
  __isset = other41.__isset;
}
PrivilegeBag& PrivilegeBag::operator=(const PrivilegeBag& other42) {
  privileges = other42.privileges;
  __isset = other42.__isset;
  return *this;
}
void PrivilegeBag::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PrivilegeBag(";
  out << "privileges=" << to_string(privileges);
  out << ")";
}


PrincipalPrivilegeSet::~PrincipalPrivilegeSet() noexcept {
}


void PrincipalPrivilegeSet::__set_userPrivileges(const std::map<std::string, std::vector<PrivilegeGrantInfo> > & val) {
  this->userPrivileges = val;
}

void PrincipalPrivilegeSet::__set_groupPrivileges(const std::map<std::string, std::vector<PrivilegeGrantInfo> > & val) {
  this->groupPrivileges = val;
}

void PrincipalPrivilegeSet::__set_rolePrivileges(const std::map<std::string, std::vector<PrivilegeGrantInfo> > & val) {
  this->rolePrivileges = val;
}
std::ostream& operator<<(std::ostream& out, const PrincipalPrivilegeSet& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PrincipalPrivilegeSet::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->userPrivileges.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _ktype44;
            ::apache::thrift::protocol::TType _vtype45;
            xfer += iprot->readMapBegin(_ktype44, _vtype45, _size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              std::string _key48;
              xfer += iprot->readString(_key48);
              std::vector<PrivilegeGrantInfo> & _val49 = this->userPrivileges[_key48];
              {
                _val49.clear();
                uint32_t _size50;
                ::apache::thrift::protocol::TType _etype53;
                xfer += iprot->readListBegin(_etype53, _size50);
                _val49.resize(_size50);
                uint32_t _i54;
                for (_i54 = 0; _i54 < _size50; ++_i54)
                {
                  xfer += _val49[_i54].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.userPrivileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->groupPrivileges.clear();
            uint32_t _size55;
            ::apache::thrift::protocol::TType _ktype56;
            ::apache::thrift::protocol::TType _vtype57;
            xfer += iprot->readMapBegin(_ktype56, _vtype57, _size55);
            uint32_t _i59;
            for (_i59 = 0; _i59 < _size55; ++_i59)
            {
              std::string _key60;
              xfer += iprot->readString(_key60);
              std::vector<PrivilegeGrantInfo> & _val61 = this->groupPrivileges[_key60];
              {
                _val61.clear();
                uint32_t _size62;
                ::apache::thrift::protocol::TType _etype65;
                xfer += iprot->readListBegin(_etype65, _size62);
                _val61.resize(_size62);
                uint32_t _i66;
                for (_i66 = 0; _i66 < _size62; ++_i66)
                {
                  xfer += _val61[_i66].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.groupPrivileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->rolePrivileges.clear();
            uint32_t _size67;
            ::apache::thrift::protocol::TType _ktype68;
            ::apache::thrift::protocol::TType _vtype69;
            xfer += iprot->readMapBegin(_ktype68, _vtype69, _size67);
            uint32_t _i71;
            for (_i71 = 0; _i71 < _size67; ++_i71)
            {
              std::string _key72;
              xfer += iprot->readString(_key72);
              std::vector<PrivilegeGrantInfo> & _val73 = this->rolePrivileges[_key72];
              {
                _val73.clear();
                uint32_t _size74;
                ::apache::thrift::protocol::TType _etype77;
                xfer += iprot->readListBegin(_etype77, _size74);
                _val73.resize(_size74);
                uint32_t _i78;
                for (_i78 = 0; _i78 < _size74; ++_i78)
                {
                  xfer += _val73[_i78].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.rolePrivileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PrincipalPrivilegeSet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PrincipalPrivilegeSet");

  xfer += oprot->writeFieldBegin("userPrivileges", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->userPrivileges.size()));
    std::map<std::string, std::vector<PrivilegeGrantInfo> > ::const_iterator _iter79;
    for (_iter79 = this->userPrivileges.begin(); _iter79 != this->userPrivileges.end(); ++_iter79)
    {
      xfer += oprot->writeString(_iter79->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter79->second.size()));
        std::vector<PrivilegeGrantInfo> ::const_iterator _iter80;
        for (_iter80 = _iter79->second.begin(); _iter80 != _iter79->second.end(); ++_iter80)
        {
          xfer += (*_iter80).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groupPrivileges", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->groupPrivileges.size()));
    std::map<std::string, std::vector<PrivilegeGrantInfo> > ::const_iterator _iter81;
    for (_iter81 = this->groupPrivileges.begin(); _iter81 != this->groupPrivileges.end(); ++_iter81)
    {
      xfer += oprot->writeString(_iter81->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter81->second.size()));
        std::vector<PrivilegeGrantInfo> ::const_iterator _iter82;
        for (_iter82 = _iter81->second.begin(); _iter82 != _iter81->second.end(); ++_iter82)
        {
          xfer += (*_iter82).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rolePrivileges", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->rolePrivileges.size()));
    std::map<std::string, std::vector<PrivilegeGrantInfo> > ::const_iterator _iter83;
    for (_iter83 = this->rolePrivileges.begin(); _iter83 != this->rolePrivileges.end(); ++_iter83)
    {
      xfer += oprot->writeString(_iter83->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter83->second.size()));
        std::vector<PrivilegeGrantInfo> ::const_iterator _iter84;
        for (_iter84 = _iter83->second.begin(); _iter84 != _iter83->second.end(); ++_iter84)
        {
          xfer += (*_iter84).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PrincipalPrivilegeSet &a, PrincipalPrivilegeSet &b) {
  using ::std::swap;
  swap(a.userPrivileges, b.userPrivileges);
  swap(a.groupPrivileges, b.groupPrivileges);
  swap(a.rolePrivileges, b.rolePrivileges);
  swap(a.__isset, b.__isset);
}

PrincipalPrivilegeSet::PrincipalPrivilegeSet(const PrincipalPrivilegeSet& other85) {
  userPrivileges = other85.userPrivileges;
  groupPrivileges = other85.groupPrivileges;
  rolePrivileges = other85.rolePrivileges;
  __isset = other85.__isset;
}
PrincipalPrivilegeSet& PrincipalPrivilegeSet::operator=(const PrincipalPrivilegeSet& other86) {
  userPrivileges = other86.userPrivileges;
  groupPrivileges = other86.groupPrivileges;
  rolePrivileges = other86.rolePrivileges;
  __isset = other86.__isset;
  return *this;
}
void PrincipalPrivilegeSet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PrincipalPrivilegeSet(";
  out << "userPrivileges=" << to_string(userPrivileges);
  out << ", " << "groupPrivileges=" << to_string(groupPrivileges);
  out << ", " << "rolePrivileges=" << to_string(rolePrivileges);
  out << ")";
}


GrantRevokePrivilegeRequest::~GrantRevokePrivilegeRequest() noexcept {
}


void GrantRevokePrivilegeRequest::__set_requestType(const GrantRevokeType::type val) {
  this->requestType = val;
}

void GrantRevokePrivilegeRequest::__set_privileges(const PrivilegeBag& val) {
  this->privileges = val;
}

void GrantRevokePrivilegeRequest::__set_revokeGrantOption(const bool val) {
  this->revokeGrantOption = val;
__isset.revokeGrantOption = true;
}
std::ostream& operator<<(std::ostream& out, const GrantRevokePrivilegeRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GrantRevokePrivilegeRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast87;
          xfer += iprot->readI32(ecast87);
          this->requestType = (GrantRevokeType::type)ecast87;
          this->__isset.requestType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privileges.read(iprot);
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->revokeGrantOption);
          this->__isset.revokeGrantOption = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GrantRevokePrivilegeRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GrantRevokePrivilegeRequest");

  xfer += oprot->writeFieldBegin("requestType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->requestType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->privileges.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.revokeGrantOption) {
    xfer += oprot->writeFieldBegin("revokeGrantOption", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->revokeGrantOption);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GrantRevokePrivilegeRequest &a, GrantRevokePrivilegeRequest &b) {
  using ::std::swap;
  swap(a.requestType, b.requestType);
  swap(a.privileges, b.privileges);
  swap(a.revokeGrantOption, b.revokeGrantOption);
  swap(a.__isset, b.__isset);
}

GrantRevokePrivilegeRequest::GrantRevokePrivilegeRequest(const GrantRevokePrivilegeRequest& other88) {
  requestType = other88.requestType;
  privileges = other88.privileges;
  revokeGrantOption = other88.revokeGrantOption;
  __isset = other88.__isset;
}
GrantRevokePrivilegeRequest& GrantRevokePrivilegeRequest::operator=(const GrantRevokePrivilegeRequest& other89) {
  requestType = other89.requestType;
  privileges = other89.privileges;
  revokeGrantOption = other89.revokeGrantOption;
  __isset = other89.__isset;
  return *this;
}
void GrantRevokePrivilegeRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GrantRevokePrivilegeRequest(";
  out << "requestType=" << to_string(requestType);
  out << ", " << "privileges=" << to_string(privileges);
  out << ", " << "revokeGrantOption="; (__isset.revokeGrantOption ? (out << to_string(revokeGrantOption)) : (out << "<null>"));
  out << ")";
}


GrantRevokePrivilegeResponse::~GrantRevokePrivilegeResponse() noexcept {
}


void GrantRevokePrivilegeResponse::__set_success(const bool val) {
  this->success = val;
__isset.success = true;
}
std::ostream& operator<<(std::ostream& out, const GrantRevokePrivilegeResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GrantRevokePrivilegeResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GrantRevokePrivilegeResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GrantRevokePrivilegeResponse");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GrantRevokePrivilegeResponse &a, GrantRevokePrivilegeResponse &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.__isset, b.__isset);
}

GrantRevokePrivilegeResponse::GrantRevokePrivilegeResponse(const GrantRevokePrivilegeResponse& other90) {
  success = other90.success;
  __isset = other90.__isset;
}
GrantRevokePrivilegeResponse& GrantRevokePrivilegeResponse::operator=(const GrantRevokePrivilegeResponse& other91) {
  success = other91.success;
  __isset = other91.__isset;
  return *this;
}
void GrantRevokePrivilegeResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GrantRevokePrivilegeResponse(";
  out << "success="; (__isset.success ? (out << to_string(success)) : (out << "<null>"));
  out << ")";
}


Role::~Role() noexcept {
}


void Role::__set_roleName(const std::string& val) {
  this->roleName = val;
}

void Role::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void Role::__set_ownerName(const std::string& val) {
  this->ownerName = val;
}
std::ostream& operator<<(std::ostream& out, const Role& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Role::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roleName);
          this->__isset.roleName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Role::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Role");

  xfer += oprot->writeFieldBegin("roleName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->roleName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ownerName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Role &a, Role &b) {
  using ::std::swap;
  swap(a.roleName, b.roleName);
  swap(a.createTime, b.createTime);
  swap(a.ownerName, b.ownerName);
  swap(a.__isset, b.__isset);
}

Role::Role(const Role& other92) {
  roleName = other92.roleName;
  createTime = other92.createTime;
  ownerName = other92.ownerName;
  __isset = other92.__isset;
}
Role& Role::operator=(const Role& other93) {
  roleName = other93.roleName;
  createTime = other93.createTime;
  ownerName = other93.ownerName;
  __isset = other93.__isset;
  return *this;
}
void Role::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Role(";
  out << "roleName=" << to_string(roleName);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "ownerName=" << to_string(ownerName);
  out << ")";
}


RolePrincipalGrant::~RolePrincipalGrant() noexcept {
}


void RolePrincipalGrant::__set_roleName(const std::string& val) {
  this->roleName = val;
}

void RolePrincipalGrant::__set_principalName(const std::string& val) {
  this->principalName = val;
}

void RolePrincipalGrant::__set_principalType(const PrincipalType::type val) {
  this->principalType = val;
}

void RolePrincipalGrant::__set_grantOption(const bool val) {
  this->grantOption = val;
}

void RolePrincipalGrant::__set_grantTime(const int32_t val) {
  this->grantTime = val;
}

void RolePrincipalGrant::__set_grantorName(const std::string& val) {
  this->grantorName = val;
}

void RolePrincipalGrant::__set_grantorPrincipalType(const PrincipalType::type val) {
  this->grantorPrincipalType = val;
}
std::ostream& operator<<(std::ostream& out, const RolePrincipalGrant& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RolePrincipalGrant::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roleName);
          this->__isset.roleName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->principalName);
          this->__isset.principalName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast94;
          xfer += iprot->readI32(ecast94);
          this->principalType = (PrincipalType::type)ecast94;
          this->__isset.principalType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->grantOption);
          this->__isset.grantOption = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->grantTime);
          this->__isset.grantTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->grantorName);
          this->__isset.grantorName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast95;
          xfer += iprot->readI32(ecast95);
          this->grantorPrincipalType = (PrincipalType::type)ecast95;
          this->__isset.grantorPrincipalType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RolePrincipalGrant::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RolePrincipalGrant");

  xfer += oprot->writeFieldBegin("roleName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->roleName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->principalName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->principalType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantOption", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->grantOption);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantTime", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->grantTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantorName", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->grantorName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantorPrincipalType", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->grantorPrincipalType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RolePrincipalGrant &a, RolePrincipalGrant &b) {
  using ::std::swap;
  swap(a.roleName, b.roleName);
  swap(a.principalName, b.principalName);
  swap(a.principalType, b.principalType);
  swap(a.grantOption, b.grantOption);
  swap(a.grantTime, b.grantTime);
  swap(a.grantorName, b.grantorName);
  swap(a.grantorPrincipalType, b.grantorPrincipalType);
  swap(a.__isset, b.__isset);
}

RolePrincipalGrant::RolePrincipalGrant(const RolePrincipalGrant& other96) {
  roleName = other96.roleName;
  principalName = other96.principalName;
  principalType = other96.principalType;
  grantOption = other96.grantOption;
  grantTime = other96.grantTime;
  grantorName = other96.grantorName;
  grantorPrincipalType = other96.grantorPrincipalType;
  __isset = other96.__isset;
}
RolePrincipalGrant& RolePrincipalGrant::operator=(const RolePrincipalGrant& other97) {
  roleName = other97.roleName;
  principalName = other97.principalName;
  principalType = other97.principalType;
  grantOption = other97.grantOption;
  grantTime = other97.grantTime;
  grantorName = other97.grantorName;
  grantorPrincipalType = other97.grantorPrincipalType;
  __isset = other97.__isset;
  return *this;
}
void RolePrincipalGrant::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RolePrincipalGrant(";
  out << "roleName=" << to_string(roleName);
  out << ", " << "principalName=" << to_string(principalName);
  out << ", " << "principalType=" << to_string(principalType);
  out << ", " << "grantOption=" << to_string(grantOption);
  out << ", " << "grantTime=" << to_string(grantTime);
  out << ", " << "grantorName=" << to_string(grantorName);
  out << ", " << "grantorPrincipalType=" << to_string(grantorPrincipalType);
  out << ")";
}


GetRoleGrantsForPrincipalRequest::~GetRoleGrantsForPrincipalRequest() noexcept {
}


void GetRoleGrantsForPrincipalRequest::__set_principal_name(const std::string& val) {
  this->principal_name = val;
}

void GetRoleGrantsForPrincipalRequest::__set_principal_type(const PrincipalType::type val) {
  this->principal_type = val;
}
std::ostream& operator<<(std::ostream& out, const GetRoleGrantsForPrincipalRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetRoleGrantsForPrincipalRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_principal_name = false;
  bool isset_principal_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->principal_name);
          isset_principal_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast98;
          xfer += iprot->readI32(ecast98);
          this->principal_type = (PrincipalType::type)ecast98;
          isset_principal_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_principal_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_principal_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetRoleGrantsForPrincipalRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetRoleGrantsForPrincipalRequest");

  xfer += oprot->writeFieldBegin("principal_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->principal_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principal_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->principal_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetRoleGrantsForPrincipalRequest &a, GetRoleGrantsForPrincipalRequest &b) {
  using ::std::swap;
  swap(a.principal_name, b.principal_name);
  swap(a.principal_type, b.principal_type);
}

GetRoleGrantsForPrincipalRequest::GetRoleGrantsForPrincipalRequest(const GetRoleGrantsForPrincipalRequest& other99) {
  principal_name = other99.principal_name;
  principal_type = other99.principal_type;
}
GetRoleGrantsForPrincipalRequest& GetRoleGrantsForPrincipalRequest::operator=(const GetRoleGrantsForPrincipalRequest& other100) {
  principal_name = other100.principal_name;
  principal_type = other100.principal_type;
  return *this;
}
void GetRoleGrantsForPrincipalRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetRoleGrantsForPrincipalRequest(";
  out << "principal_name=" << to_string(principal_name);
  out << ", " << "principal_type=" << to_string(principal_type);
  out << ")";
}


GetRoleGrantsForPrincipalResponse::~GetRoleGrantsForPrincipalResponse() noexcept {
}


void GetRoleGrantsForPrincipalResponse::__set_principalGrants(const std::vector<RolePrincipalGrant> & val) {
  this->principalGrants = val;
}
std::ostream& operator<<(std::ostream& out, const GetRoleGrantsForPrincipalResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetRoleGrantsForPrincipalResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_principalGrants = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->principalGrants.clear();
            uint32_t _size101;
            ::apache::thrift::protocol::TType _etype104;
            xfer += iprot->readListBegin(_etype104, _size101);
            this->principalGrants.resize(_size101);
            uint32_t _i105;
            for (_i105 = 0; _i105 < _size101; ++_i105)
            {
              xfer += this->principalGrants[_i105].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_principalGrants = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_principalGrants)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetRoleGrantsForPrincipalResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetRoleGrantsForPrincipalResponse");

  xfer += oprot->writeFieldBegin("principalGrants", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->principalGrants.size()));
    std::vector<RolePrincipalGrant> ::const_iterator _iter106;
    for (_iter106 = this->principalGrants.begin(); _iter106 != this->principalGrants.end(); ++_iter106)
    {
      xfer += (*_iter106).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetRoleGrantsForPrincipalResponse &a, GetRoleGrantsForPrincipalResponse &b) {
  using ::std::swap;
  swap(a.principalGrants, b.principalGrants);
}

GetRoleGrantsForPrincipalResponse::GetRoleGrantsForPrincipalResponse(const GetRoleGrantsForPrincipalResponse& other107) {
  principalGrants = other107.principalGrants;
}
GetRoleGrantsForPrincipalResponse& GetRoleGrantsForPrincipalResponse::operator=(const GetRoleGrantsForPrincipalResponse& other108) {
  principalGrants = other108.principalGrants;
  return *this;
}
void GetRoleGrantsForPrincipalResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetRoleGrantsForPrincipalResponse(";
  out << "principalGrants=" << to_string(principalGrants);
  out << ")";
}


GetPrincipalsInRoleRequest::~GetPrincipalsInRoleRequest() noexcept {
}


void GetPrincipalsInRoleRequest::__set_roleName(const std::string& val) {
  this->roleName = val;
}
std::ostream& operator<<(std::ostream& out, const GetPrincipalsInRoleRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPrincipalsInRoleRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_roleName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roleName);
          isset_roleName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_roleName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPrincipalsInRoleRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPrincipalsInRoleRequest");

  xfer += oprot->writeFieldBegin("roleName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->roleName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPrincipalsInRoleRequest &a, GetPrincipalsInRoleRequest &b) {
  using ::std::swap;
  swap(a.roleName, b.roleName);
}

GetPrincipalsInRoleRequest::GetPrincipalsInRoleRequest(const GetPrincipalsInRoleRequest& other109) {
  roleName = other109.roleName;
}
GetPrincipalsInRoleRequest& GetPrincipalsInRoleRequest::operator=(const GetPrincipalsInRoleRequest& other110) {
  roleName = other110.roleName;
  return *this;
}
void GetPrincipalsInRoleRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPrincipalsInRoleRequest(";
  out << "roleName=" << to_string(roleName);
  out << ")";
}


GetPrincipalsInRoleResponse::~GetPrincipalsInRoleResponse() noexcept {
}


void GetPrincipalsInRoleResponse::__set_principalGrants(const std::vector<RolePrincipalGrant> & val) {
  this->principalGrants = val;
}
std::ostream& operator<<(std::ostream& out, const GetPrincipalsInRoleResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetPrincipalsInRoleResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_principalGrants = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->principalGrants.clear();
            uint32_t _size111;
            ::apache::thrift::protocol::TType _etype114;
            xfer += iprot->readListBegin(_etype114, _size111);
            this->principalGrants.resize(_size111);
            uint32_t _i115;
            for (_i115 = 0; _i115 < _size111; ++_i115)
            {
              xfer += this->principalGrants[_i115].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_principalGrants = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_principalGrants)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetPrincipalsInRoleResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetPrincipalsInRoleResponse");

  xfer += oprot->writeFieldBegin("principalGrants", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->principalGrants.size()));
    std::vector<RolePrincipalGrant> ::const_iterator _iter116;
    for (_iter116 = this->principalGrants.begin(); _iter116 != this->principalGrants.end(); ++_iter116)
    {
      xfer += (*_iter116).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetPrincipalsInRoleResponse &a, GetPrincipalsInRoleResponse &b) {
  using ::std::swap;
  swap(a.principalGrants, b.principalGrants);
}

GetPrincipalsInRoleResponse::GetPrincipalsInRoleResponse(const GetPrincipalsInRoleResponse& other117) {
  principalGrants = other117.principalGrants;
}
GetPrincipalsInRoleResponse& GetPrincipalsInRoleResponse::operator=(const GetPrincipalsInRoleResponse& other118) {
  principalGrants = other118.principalGrants;
  return *this;
}
void GetPrincipalsInRoleResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetPrincipalsInRoleResponse(";
  out << "principalGrants=" << to_string(principalGrants);
  out << ")";
}


GrantRevokeRoleRequest::~GrantRevokeRoleRequest() noexcept {
}


void GrantRevokeRoleRequest::__set_requestType(const GrantRevokeType::type val) {
  this->requestType = val;
}

void GrantRevokeRoleRequest::__set_roleName(const std::string& val) {
  this->roleName = val;
}

void GrantRevokeRoleRequest::__set_principalName(const std::string& val) {
  this->principalName = val;
}

void GrantRevokeRoleRequest::__set_principalType(const PrincipalType::type val) {
  this->principalType = val;
}

void GrantRevokeRoleRequest::__set_grantor(const std::string& val) {
  this->grantor = val;
__isset.grantor = true;
}

void GrantRevokeRoleRequest::__set_grantorType(const PrincipalType::type val) {
  this->grantorType = val;
__isset.grantorType = true;
}

void GrantRevokeRoleRequest::__set_grantOption(const bool val) {
  this->grantOption = val;
__isset.grantOption = true;
}
std::ostream& operator<<(std::ostream& out, const GrantRevokeRoleRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GrantRevokeRoleRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast119;
          xfer += iprot->readI32(ecast119);
          this->requestType = (GrantRevokeType::type)ecast119;
          this->__isset.requestType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roleName);
          this->__isset.roleName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->principalName);
          this->__isset.principalName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast120;
          xfer += iprot->readI32(ecast120);
          this->principalType = (PrincipalType::type)ecast120;
          this->__isset.principalType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->grantor);
          this->__isset.grantor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast121;
          xfer += iprot->readI32(ecast121);
          this->grantorType = (PrincipalType::type)ecast121;
          this->__isset.grantorType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->grantOption);
          this->__isset.grantOption = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GrantRevokeRoleRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GrantRevokeRoleRequest");

  xfer += oprot->writeFieldBegin("requestType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->requestType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("roleName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->roleName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->principalName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principalType", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->principalType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.grantor) {
    xfer += oprot->writeFieldBegin("grantor", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->grantor);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.grantorType) {
    xfer += oprot->writeFieldBegin("grantorType", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->grantorType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.grantOption) {
    xfer += oprot->writeFieldBegin("grantOption", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->grantOption);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GrantRevokeRoleRequest &a, GrantRevokeRoleRequest &b) {
  using ::std::swap;
  swap(a.requestType, b.requestType);
  swap(a.roleName, b.roleName);
  swap(a.principalName, b.principalName);
  swap(a.principalType, b.principalType);
  swap(a.grantor, b.grantor);
  swap(a.grantorType, b.grantorType);
  swap(a.grantOption, b.grantOption);
  swap(a.__isset, b.__isset);
}

GrantRevokeRoleRequest::GrantRevokeRoleRequest(const GrantRevokeRoleRequest& other122) {
  requestType = other122.requestType;
  roleName = other122.roleName;
  principalName = other122.principalName;
  principalType = other122.principalType;
  grantor = other122.grantor;
  grantorType = other122.grantorType;
  grantOption = other122.grantOption;
  __isset = other122.__isset;
}
GrantRevokeRoleRequest& GrantRevokeRoleRequest::operator=(const GrantRevokeRoleRequest& other123) {
  requestType = other123.requestType;
  roleName = other123.roleName;
  principalName = other123.principalName;
  principalType = other123.principalType;
  grantor = other123.grantor;
  grantorType = other123.grantorType;
  grantOption = other123.grantOption;
  __isset = other123.__isset;
  return *this;
}
void GrantRevokeRoleRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GrantRevokeRoleRequest(";
  out << "requestType=" << to_string(requestType);
  out << ", " << "roleName=" << to_string(roleName);
  out << ", " << "principalName=" << to_string(principalName);
  out << ", " << "principalType=" << to_string(principalType);
  out << ", " << "grantor="; (__isset.grantor ? (out << to_string(grantor)) : (out << "<null>"));
  out << ", " << "grantorType="; (__isset.grantorType ? (out << to_string(grantorType)) : (out << "<null>"));
  out << ", " << "grantOption="; (__isset.grantOption ? (out << to_string(grantOption)) : (out << "<null>"));
  out << ")";
}


GrantRevokeRoleResponse::~GrantRevokeRoleResponse() noexcept {
}


void GrantRevokeRoleResponse::__set_success(const bool val) {
  this->success = val;
__isset.success = true;
}
std::ostream& operator<<(std::ostream& out, const GrantRevokeRoleResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GrantRevokeRoleResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GrantRevokeRoleResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GrantRevokeRoleResponse");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GrantRevokeRoleResponse &a, GrantRevokeRoleResponse &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.__isset, b.__isset);
}

GrantRevokeRoleResponse::GrantRevokeRoleResponse(const GrantRevokeRoleResponse& other124) {
  success = other124.success;
  __isset = other124.__isset;
}
GrantRevokeRoleResponse& GrantRevokeRoleResponse::operator=(const GrantRevokeRoleResponse& other125) {
  success = other125.success;
  __isset = other125.__isset;
  return *this;
}
void GrantRevokeRoleResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GrantRevokeRoleResponse(";
  out << "success="; (__isset.success ? (out << to_string(success)) : (out << "<null>"));
  out << ")";
}


Database::~Database() noexcept {
}


void Database::__set_name(const std::string& val) {
  this->name = val;
}

void Database::__set_description(const std::string& val) {
  this->description = val;
}

void Database::__set_locationUri(const std::string& val) {
  this->locationUri = val;
}

void Database::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void Database::__set_privileges(const PrincipalPrivilegeSet& val) {
  this->privileges = val;
__isset.privileges = true;
}

void Database::__set_ownerName(const std::string& val) {
  this->ownerName = val;
__isset.ownerName = true;
}

void Database::__set_ownerType(const PrincipalType::type val) {
  this->ownerType = val;
__isset.ownerType = true;
}
std::ostream& operator<<(std::ostream& out, const Database& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Database::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->locationUri);
          this->__isset.locationUri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size126;
            ::apache::thrift::protocol::TType _ktype127;
            ::apache::thrift::protocol::TType _vtype128;
            xfer += iprot->readMapBegin(_ktype127, _vtype128, _size126);
            uint32_t _i130;
            for (_i130 = 0; _i130 < _size126; ++_i130)
            {
              std::string _key131;
              xfer += iprot->readString(_key131);
              std::string& _val132 = this->parameters[_key131];
              xfer += iprot->readString(_val132);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privileges.read(iprot);
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast133;
          xfer += iprot->readI32(ecast133);
          this->ownerType = (PrincipalType::type)ecast133;
          this->__isset.ownerType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Database::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Database");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->description);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("locationUri", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->locationUri);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter134;
    for (_iter134 = this->parameters.begin(); _iter134 != this->parameters.end(); ++_iter134)
    {
      xfer += oprot->writeString(_iter134->first);
      xfer += oprot->writeString(_iter134->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.privileges) {
    xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->privileges.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ownerName) {
    xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->ownerName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ownerType) {
    xfer += oprot->writeFieldBegin("ownerType", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->ownerType);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Database &a, Database &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.description, b.description);
  swap(a.locationUri, b.locationUri);
  swap(a.parameters, b.parameters);
  swap(a.privileges, b.privileges);
  swap(a.ownerName, b.ownerName);
  swap(a.ownerType, b.ownerType);
  swap(a.__isset, b.__isset);
}

Database::Database(const Database& other135) {
  name = other135.name;
  description = other135.description;
  locationUri = other135.locationUri;
  parameters = other135.parameters;
  privileges = other135.privileges;
  ownerName = other135.ownerName;
  ownerType = other135.ownerType;
  __isset = other135.__isset;
}
Database& Database::operator=(const Database& other136) {
  name = other136.name;
  description = other136.description;
  locationUri = other136.locationUri;
  parameters = other136.parameters;
  privileges = other136.privileges;
  ownerName = other136.ownerName;
  ownerType = other136.ownerType;
  __isset = other136.__isset;
  return *this;
}
void Database::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Database(";
  out << "name=" << to_string(name);
  out << ", " << "description=" << to_string(description);
  out << ", " << "locationUri=" << to_string(locationUri);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "privileges="; (__isset.privileges ? (out << to_string(privileges)) : (out << "<null>"));
  out << ", " << "ownerName="; (__isset.ownerName ? (out << to_string(ownerName)) : (out << "<null>"));
  out << ", " << "ownerType="; (__isset.ownerType ? (out << to_string(ownerType)) : (out << "<null>"));
  out << ")";
}


SerDeInfo::~SerDeInfo() noexcept {
}


void SerDeInfo::__set_name(const std::string& val) {
  this->name = val;
}

void SerDeInfo::__set_serializationLib(const std::string& val) {
  this->serializationLib = val;
}

void SerDeInfo::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}
std::ostream& operator<<(std::ostream& out, const SerDeInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SerDeInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serializationLib);
          this->__isset.serializationLib = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size137;
            ::apache::thrift::protocol::TType _ktype138;
            ::apache::thrift::protocol::TType _vtype139;
            xfer += iprot->readMapBegin(_ktype138, _vtype139, _size137);
            uint32_t _i141;
            for (_i141 = 0; _i141 < _size137; ++_i141)
            {
              std::string _key142;
              xfer += iprot->readString(_key142);
              std::string& _val143 = this->parameters[_key142];
              xfer += iprot->readString(_val143);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SerDeInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SerDeInfo");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serializationLib", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->serializationLib);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter144;
    for (_iter144 = this->parameters.begin(); _iter144 != this->parameters.end(); ++_iter144)
    {
      xfer += oprot->writeString(_iter144->first);
      xfer += oprot->writeString(_iter144->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SerDeInfo &a, SerDeInfo &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.serializationLib, b.serializationLib);
  swap(a.parameters, b.parameters);
  swap(a.__isset, b.__isset);
}

SerDeInfo::SerDeInfo(const SerDeInfo& other145) {
  name = other145.name;
  serializationLib = other145.serializationLib;
  parameters = other145.parameters;
  __isset = other145.__isset;
}
SerDeInfo& SerDeInfo::operator=(const SerDeInfo& other146) {
  name = other146.name;
  serializationLib = other146.serializationLib;
  parameters = other146.parameters;
  __isset = other146.__isset;
  return *this;
}
void SerDeInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SerDeInfo(";
  out << "name=" << to_string(name);
  out << ", " << "serializationLib=" << to_string(serializationLib);
  out << ", " << "parameters=" << to_string(parameters);
  out << ")";
}


Order::~Order() noexcept {
}


void Order::__set_col(const std::string& val) {
  this->col = val;
}

void Order::__set_order(const int32_t val) {
  this->order = val;
}
std::ostream& operator<<(std::ostream& out, const Order& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Order::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->col);
          this->__isset.col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->order);
          this->__isset.order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Order::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Order");

  xfer += oprot->writeFieldBegin("col", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->col);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("order", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->order);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Order &a, Order &b) {
  using ::std::swap;
  swap(a.col, b.col);
  swap(a.order, b.order);
  swap(a.__isset, b.__isset);
}

Order::Order(const Order& other147) {
  col = other147.col;
  order = other147.order;
  __isset = other147.__isset;
}
Order& Order::operator=(const Order& other148) {
  col = other148.col;
  order = other148.order;
  __isset = other148.__isset;
  return *this;
}
void Order::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Order(";
  out << "col=" << to_string(col);
  out << ", " << "order=" << to_string(order);
  out << ")";
}


SkewedInfo::~SkewedInfo() noexcept {
}


void SkewedInfo::__set_skewedColNames(const std::vector<std::string> & val) {
  this->skewedColNames = val;
}

void SkewedInfo::__set_skewedColValues(const std::vector<std::vector<std::string> > & val) {
  this->skewedColValues = val;
}

void SkewedInfo::__set_skewedColValueLocationMaps(const std::map<std::string, std::string> & val) {
  this->skewedColValueLocationMaps = val;
}
std::ostream& operator<<(std::ostream& out, const SkewedInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SkewedInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->skewedColNames.clear();
            uint32_t _size149;
            ::apache::thrift::protocol::TType _etype152;
            xfer += iprot->readListBegin(_etype152, _size149);
            this->skewedColNames.resize(_size149);
            uint32_t _i153;
            for (_i153 = 0; _i153 < _size149; ++_i153)
            {
              xfer += iprot->readString(this->skewedColNames[_i153]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.skewedColNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->skewedColValues.clear();
            uint32_t _size154;
            ::apache::thrift::protocol::TType _etype157;
            xfer += iprot->readListBegin(_etype157, _size154);
            this->skewedColValues.resize(_size154);
            uint32_t _i158;
            for (_i158 = 0; _i158 < _size154; ++_i158)
            {
              {
                this->skewedColValues[_i158].clear();
                uint32_t _size159;
                ::apache::thrift::protocol::TType _etype162;
                xfer += iprot->readListBegin(_etype162, _size159);
                this->skewedColValues[_i158].resize(_size159);
                uint32_t _i163;
                for (_i163 = 0; _i163 < _size159; ++_i163)
                {
                  xfer += iprot->readString(this->skewedColValues[_i158][_i163]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.skewedColValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->skewedColValueLocationMaps.clear();
            uint32_t _size164;
            ::apache::thrift::protocol::TType _ktype165;
            ::apache::thrift::protocol::TType _vtype166;
            xfer += iprot->readMapBegin(_ktype165, _vtype166, _size164);
            uint32_t _i168;
            for (_i168 = 0; _i168 < _size164; ++_i168)
            {
              std::string _key169;
              xfer += iprot->readString(_key169);
              std::string& _val170 = this->skewedColValueLocationMaps[_key169];
              xfer += iprot->readString(_val170);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.skewedColValueLocationMaps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SkewedInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SkewedInfo");

  xfer += oprot->writeFieldBegin("skewedColNames", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->skewedColNames.size()));
    std::vector<std::string> ::const_iterator _iter171;
    for (_iter171 = this->skewedColNames.begin(); _iter171 != this->skewedColNames.end(); ++_iter171)
    {
      xfer += oprot->writeString((*_iter171));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skewedColValues", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->skewedColValues.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter172;
    for (_iter172 = this->skewedColValues.begin(); _iter172 != this->skewedColValues.end(); ++_iter172)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter172).size()));
        std::vector<std::string> ::const_iterator _iter173;
        for (_iter173 = (*_iter172).begin(); _iter173 != (*_iter172).end(); ++_iter173)
        {
          xfer += oprot->writeString((*_iter173));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skewedColValueLocationMaps", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->skewedColValueLocationMaps.size()));
    std::map<std::string, std::string> ::const_iterator _iter174;
    for (_iter174 = this->skewedColValueLocationMaps.begin(); _iter174 != this->skewedColValueLocationMaps.end(); ++_iter174)
    {
      xfer += oprot->writeString(_iter174->first);
      xfer += oprot->writeString(_iter174->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SkewedInfo &a, SkewedInfo &b) {
  using ::std::swap;
  swap(a.skewedColNames, b.skewedColNames);
  swap(a.skewedColValues, b.skewedColValues);
  swap(a.skewedColValueLocationMaps, b.skewedColValueLocationMaps);
  swap(a.__isset, b.__isset);
}

SkewedInfo::SkewedInfo(const SkewedInfo& other175) {
  skewedColNames = other175.skewedColNames;
  skewedColValues = other175.skewedColValues;
  skewedColValueLocationMaps = other175.skewedColValueLocationMaps;
  __isset = other175.__isset;
}
SkewedInfo& SkewedInfo::operator=(const SkewedInfo& other176) {
  skewedColNames = other176.skewedColNames;
  skewedColValues = other176.skewedColValues;
  skewedColValueLocationMaps = other176.skewedColValueLocationMaps;
  __isset = other176.__isset;
  return *this;
}
void SkewedInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SkewedInfo(";
  out << "skewedColNames=" << to_string(skewedColNames);
  out << ", " << "skewedColValues=" << to_string(skewedColValues);
  out << ", " << "skewedColValueLocationMaps=" << to_string(skewedColValueLocationMaps);
  out << ")";
}


StorageDescriptor::~StorageDescriptor() noexcept {
}


void StorageDescriptor::__set_cols(const std::vector<FieldSchema> & val) {
  this->cols = val;
}

void StorageDescriptor::__set_location(const std::string& val) {
  this->location = val;
}

void StorageDescriptor::__set_inputFormat(const std::string& val) {
  this->inputFormat = val;
}

void StorageDescriptor::__set_outputFormat(const std::string& val) {
  this->outputFormat = val;
}

void StorageDescriptor::__set_compressed(const bool val) {
  this->compressed = val;
}

void StorageDescriptor::__set_numBuckets(const int32_t val) {
  this->numBuckets = val;
}

void StorageDescriptor::__set_serdeInfo(const SerDeInfo& val) {
  this->serdeInfo = val;
}

void StorageDescriptor::__set_bucketCols(const std::vector<std::string> & val) {
  this->bucketCols = val;
}

void StorageDescriptor::__set_sortCols(const std::vector<Order> & val) {
  this->sortCols = val;
}

void StorageDescriptor::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void StorageDescriptor::__set_skewedInfo(const SkewedInfo& val) {
  this->skewedInfo = val;
__isset.skewedInfo = true;
}

void StorageDescriptor::__set_storedAsSubDirectories(const bool val) {
  this->storedAsSubDirectories = val;
__isset.storedAsSubDirectories = true;
}
std::ostream& operator<<(std::ostream& out, const StorageDescriptor& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StorageDescriptor::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cols.clear();
            uint32_t _size177;
            ::apache::thrift::protocol::TType _etype180;
            xfer += iprot->readListBegin(_etype180, _size177);
            this->cols.resize(_size177);
            uint32_t _i181;
            for (_i181 = 0; _i181 < _size177; ++_i181)
            {
              xfer += this->cols[_i181].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->inputFormat);
          this->__isset.inputFormat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->outputFormat);
          this->__isset.outputFormat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->compressed);
          this->__isset.compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numBuckets);
          this->__isset.numBuckets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->serdeInfo.read(iprot);
          this->__isset.serdeInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bucketCols.clear();
            uint32_t _size182;
            ::apache::thrift::protocol::TType _etype185;
            xfer += iprot->readListBegin(_etype185, _size182);
            this->bucketCols.resize(_size182);
            uint32_t _i186;
            for (_i186 = 0; _i186 < _size182; ++_i186)
            {
              xfer += iprot->readString(this->bucketCols[_i186]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.bucketCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sortCols.clear();
            uint32_t _size187;
            ::apache::thrift::protocol::TType _etype190;
            xfer += iprot->readListBegin(_etype190, _size187);
            this->sortCols.resize(_size187);
            uint32_t _i191;
            for (_i191 = 0; _i191 < _size187; ++_i191)
            {
              xfer += this->sortCols[_i191].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sortCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size192;
            ::apache::thrift::protocol::TType _ktype193;
            ::apache::thrift::protocol::TType _vtype194;
            xfer += iprot->readMapBegin(_ktype193, _vtype194, _size192);
            uint32_t _i196;
            for (_i196 = 0; _i196 < _size192; ++_i196)
            {
              std::string _key197;
              xfer += iprot->readString(_key197);
              std::string& _val198 = this->parameters[_key197];
              xfer += iprot->readString(_val198);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->skewedInfo.read(iprot);
          this->__isset.skewedInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->storedAsSubDirectories);
          this->__isset.storedAsSubDirectories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StorageDescriptor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StorageDescriptor");

  xfer += oprot->writeFieldBegin("cols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cols.size()));
    std::vector<FieldSchema> ::const_iterator _iter199;
    for (_iter199 = this->cols.begin(); _iter199 != this->cols.end(); ++_iter199)
    {
      xfer += (*_iter199).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->location);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inputFormat", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->inputFormat);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputFormat", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->outputFormat);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compressed", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->compressed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numBuckets", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->numBuckets);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serdeInfo", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->serdeInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bucketCols", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->bucketCols.size()));
    std::vector<std::string> ::const_iterator _iter200;
    for (_iter200 = this->bucketCols.begin(); _iter200 != this->bucketCols.end(); ++_iter200)
    {
      xfer += oprot->writeString((*_iter200));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sortCols", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->sortCols.size()));
    std::vector<Order> ::const_iterator _iter201;
    for (_iter201 = this->sortCols.begin(); _iter201 != this->sortCols.end(); ++_iter201)
    {
      xfer += (*_iter201).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter202;
    for (_iter202 = this->parameters.begin(); _iter202 != this->parameters.end(); ++_iter202)
    {
      xfer += oprot->writeString(_iter202->first);
      xfer += oprot->writeString(_iter202->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.skewedInfo) {
    xfer += oprot->writeFieldBegin("skewedInfo", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->skewedInfo.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.storedAsSubDirectories) {
    xfer += oprot->writeFieldBegin("storedAsSubDirectories", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->storedAsSubDirectories);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StorageDescriptor &a, StorageDescriptor &b) {
  using ::std::swap;
  swap(a.cols, b.cols);
  swap(a.location, b.location);
  swap(a.inputFormat, b.inputFormat);
  swap(a.outputFormat, b.outputFormat);
  swap(a.compressed, b.compressed);
  swap(a.numBuckets, b.numBuckets);
  swap(a.serdeInfo, b.serdeInfo);
  swap(a.bucketCols, b.bucketCols);
  swap(a.sortCols, b.sortCols);
  swap(a.parameters, b.parameters);
  swap(a.skewedInfo, b.skewedInfo);
  swap(a.storedAsSubDirectories, b.storedAsSubDirectories);
  swap(a.__isset, b.__isset);
}

StorageDescriptor::StorageDescriptor(const StorageDescriptor& other203) {
  cols = other203.cols;
  location = other203.location;
  inputFormat = other203.inputFormat;
  outputFormat = other203.outputFormat;
  compressed = other203.compressed;
  numBuckets = other203.numBuckets;
  serdeInfo = other203.serdeInfo;
  bucketCols = other203.bucketCols;
  sortCols = other203.sortCols;
  parameters = other203.parameters;
  skewedInfo = other203.skewedInfo;
  storedAsSubDirectories = other203.storedAsSubDirectories;
  __isset = other203.__isset;
}
StorageDescriptor& StorageDescriptor::operator=(const StorageDescriptor& other204) {
  cols = other204.cols;
  location = other204.location;
  inputFormat = other204.inputFormat;
  outputFormat = other204.outputFormat;
  compressed = other204.compressed;
  numBuckets = other204.numBuckets;
  serdeInfo = other204.serdeInfo;
  bucketCols = other204.bucketCols;
  sortCols = other204.sortCols;
  parameters = other204.parameters;
  skewedInfo = other204.skewedInfo;
  storedAsSubDirectories = other204.storedAsSubDirectories;
  __isset = other204.__isset;
  return *this;
}
void StorageDescriptor::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StorageDescriptor(";
  out << "cols=" << to_string(cols);
  out << ", " << "location=" << to_string(location);
  out << ", " << "inputFormat=" << to_string(inputFormat);
  out << ", " << "outputFormat=" << to_string(outputFormat);
  out << ", " << "compressed=" << to_string(compressed);
  out << ", " << "numBuckets=" << to_string(numBuckets);
  out << ", " << "serdeInfo=" << to_string(serdeInfo);
  out << ", " << "bucketCols=" << to_string(bucketCols);
  out << ", " << "sortCols=" << to_string(sortCols);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "skewedInfo="; (__isset.skewedInfo ? (out << to_string(skewedInfo)) : (out << "<null>"));
  out << ", " << "storedAsSubDirectories="; (__isset.storedAsSubDirectories ? (out << to_string(storedAsSubDirectories)) : (out << "<null>"));
  out << ")";
}


Table::~Table() noexcept {
}


void Table::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void Table::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void Table::__set_owner(const std::string& val) {
  this->owner = val;
}

void Table::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void Table::__set_lastAccessTime(const int32_t val) {
  this->lastAccessTime = val;
}

void Table::__set_retention(const int32_t val) {
  this->retention = val;
}

void Table::__set_sd(const StorageDescriptor& val) {
  this->sd = val;
}

void Table::__set_partitionKeys(const std::vector<FieldSchema> & val) {
  this->partitionKeys = val;
}

void Table::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void Table::__set_viewOriginalText(const std::string& val) {
  this->viewOriginalText = val;
}

void Table::__set_viewExpandedText(const std::string& val) {
  this->viewExpandedText = val;
}

void Table::__set_tableType(const std::string& val) {
  this->tableType = val;
}

void Table::__set_privileges(const PrincipalPrivilegeSet& val) {
  this->privileges = val;
__isset.privileges = true;
}

void Table::__set_temporary(const bool val) {
  this->temporary = val;
__isset.temporary = true;
}

void Table::__set_rewriteEnabled(const bool val) {
  this->rewriteEnabled = val;
__isset.rewriteEnabled = true;
}
std::ostream& operator<<(std::ostream& out, const Table& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Table::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->owner);
          this->__isset.owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastAccessTime);
          this->__isset.lastAccessTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->retention);
          this->__isset.retention = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sd.read(iprot);
          this->__isset.sd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionKeys.clear();
            uint32_t _size205;
            ::apache::thrift::protocol::TType _etype208;
            xfer += iprot->readListBegin(_etype208, _size205);
            this->partitionKeys.resize(_size205);
            uint32_t _i209;
            for (_i209 = 0; _i209 < _size205; ++_i209)
            {
              xfer += this->partitionKeys[_i209].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitionKeys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size210;
            ::apache::thrift::protocol::TType _ktype211;
            ::apache::thrift::protocol::TType _vtype212;
            xfer += iprot->readMapBegin(_ktype211, _vtype212, _size210);
            uint32_t _i214;
            for (_i214 = 0; _i214 < _size210; ++_i214)
            {
              std::string _key215;
              xfer += iprot->readString(_key215);
              std::string& _val216 = this->parameters[_key215];
              xfer += iprot->readString(_val216);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->viewOriginalText);
          this->__isset.viewOriginalText = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->viewExpandedText);
          this->__isset.viewExpandedText = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableType);
          this->__isset.tableType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privileges.read(iprot);
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->temporary);
          this->__isset.temporary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rewriteEnabled);
          this->__isset.rewriteEnabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Table::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Table");

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->owner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastAccessTime", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->lastAccessTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("retention", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->retention);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sd", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->sd.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partitionKeys", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitionKeys.size()));
    std::vector<FieldSchema> ::const_iterator _iter217;
    for (_iter217 = this->partitionKeys.begin(); _iter217 != this->partitionKeys.end(); ++_iter217)
    {
      xfer += (*_iter217).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 9);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter218;
    for (_iter218 = this->parameters.begin(); _iter218 != this->parameters.end(); ++_iter218)
    {
      xfer += oprot->writeString(_iter218->first);
      xfer += oprot->writeString(_iter218->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("viewOriginalText", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->viewOriginalText);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("viewExpandedText", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->viewExpandedText);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableType", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeString(this->tableType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.privileges) {
    xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->privileges.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.temporary) {
    xfer += oprot->writeFieldBegin("temporary", ::apache::thrift::protocol::T_BOOL, 14);
    xfer += oprot->writeBool(this->temporary);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rewriteEnabled) {
    xfer += oprot->writeFieldBegin("rewriteEnabled", ::apache::thrift::protocol::T_BOOL, 15);
    xfer += oprot->writeBool(this->rewriteEnabled);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Table &a, Table &b) {
  using ::std::swap;
  swap(a.tableName, b.tableName);
  swap(a.dbName, b.dbName);
  swap(a.owner, b.owner);
  swap(a.createTime, b.createTime);
  swap(a.lastAccessTime, b.lastAccessTime);
  swap(a.retention, b.retention);
  swap(a.sd, b.sd);
  swap(a.partitionKeys, b.partitionKeys);
  swap(a.parameters, b.parameters);
  swap(a.viewOriginalText, b.viewOriginalText);
  swap(a.viewExpandedText, b.viewExpandedText);
  swap(a.tableType, b.tableType);
  swap(a.privileges, b.privileges);
  swap(a.temporary, b.temporary);
  swap(a.rewriteEnabled, b.rewriteEnabled);
  swap(a.__isset, b.__isset);
}

Table::Table(const Table& other219) {
  tableName = other219.tableName;
  dbName = other219.dbName;
  owner = other219.owner;
  createTime = other219.createTime;
  lastAccessTime = other219.lastAccessTime;
  retention = other219.retention;
  sd = other219.sd;
  partitionKeys = other219.partitionKeys;
  parameters = other219.parameters;
  viewOriginalText = other219.viewOriginalText;
  viewExpandedText = other219.viewExpandedText;
  tableType = other219.tableType;
  privileges = other219.privileges;
  temporary = other219.temporary;
  rewriteEnabled = other219.rewriteEnabled;
  __isset = other219.__isset;
}
Table& Table::operator=(const Table& other220) {
  tableName = other220.tableName;
  dbName = other220.dbName;
  owner = other220.owner;
  createTime = other220.createTime;
  lastAccessTime = other220.lastAccessTime;
  retention = other220.retention;
  sd = other220.sd;
  partitionKeys = other220.partitionKeys;
  parameters = other220.parameters;
  viewOriginalText = other220.viewOriginalText;
  viewExpandedText = other220.viewExpandedText;
  tableType = other220.tableType;
  privileges = other220.privileges;
  temporary = other220.temporary;
  rewriteEnabled = other220.rewriteEnabled;
  __isset = other220.__isset;
  return *this;
}
void Table::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Table(";
  out << "tableName=" << to_string(tableName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "owner=" << to_string(owner);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "lastAccessTime=" << to_string(lastAccessTime);
  out << ", " << "retention=" << to_string(retention);
  out << ", " << "sd=" << to_string(sd);
  out << ", " << "partitionKeys=" << to_string(partitionKeys);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "viewOriginalText=" << to_string(viewOriginalText);
  out << ", " << "viewExpandedText=" << to_string(viewExpandedText);
  out << ", " << "tableType=" << to_string(tableType);
  out << ", " << "privileges="; (__isset.privileges ? (out << to_string(privileges)) : (out << "<null>"));
  out << ", " << "temporary="; (__isset.temporary ? (out << to_string(temporary)) : (out << "<null>"));
  out << ", " << "rewriteEnabled="; (__isset.rewriteEnabled ? (out << to_string(rewriteEnabled)) : (out << "<null>"));
  out << ")";
}


Partition::~Partition() noexcept {
}


void Partition::__set_values(const std::vector<std::string> & val) {
  this->values = val;
}

void Partition::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void Partition::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void Partition::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void Partition::__set_lastAccessTime(const int32_t val) {
  this->lastAccessTime = val;
}

void Partition::__set_sd(const StorageDescriptor& val) {
  this->sd = val;
}

void Partition::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void Partition::__set_privileges(const PrincipalPrivilegeSet& val) {
  this->privileges = val;
__isset.privileges = true;
}
std::ostream& operator<<(std::ostream& out, const Partition& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Partition::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size221;
            ::apache::thrift::protocol::TType _etype224;
            xfer += iprot->readListBegin(_etype224, _size221);
            this->values.resize(_size221);
            uint32_t _i225;
            for (_i225 = 0; _i225 < _size221; ++_i225)
            {
              xfer += iprot->readString(this->values[_i225]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastAccessTime);
          this->__isset.lastAccessTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sd.read(iprot);
          this->__isset.sd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size226;
            ::apache::thrift::protocol::TType _ktype227;
            ::apache::thrift::protocol::TType _vtype228;
            xfer += iprot->readMapBegin(_ktype227, _vtype228, _size226);
            uint32_t _i230;
            for (_i230 = 0; _i230 < _size226; ++_i230)
            {
              std::string _key231;
              xfer += iprot->readString(_key231);
              std::string& _val232 = this->parameters[_key231];
              xfer += iprot->readString(_val232);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privileges.read(iprot);
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Partition::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Partition");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
    std::vector<std::string> ::const_iterator _iter233;
    for (_iter233 = this->values.begin(); _iter233 != this->values.end(); ++_iter233)
    {
      xfer += oprot->writeString((*_iter233));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastAccessTime", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->lastAccessTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sd", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->sd.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 7);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter234;
    for (_iter234 = this->parameters.begin(); _iter234 != this->parameters.end(); ++_iter234)
    {
      xfer += oprot->writeString(_iter234->first);
      xfer += oprot->writeString(_iter234->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.privileges) {
    xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->privileges.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Partition &a, Partition &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.createTime, b.createTime);
  swap(a.lastAccessTime, b.lastAccessTime);
  swap(a.sd, b.sd);
  swap(a.parameters, b.parameters);
  swap(a.privileges, b.privileges);
  swap(a.__isset, b.__isset);
}

Partition::Partition(const Partition& other235) {
  values = other235.values;
  dbName = other235.dbName;
  tableName = other235.tableName;
  createTime = other235.createTime;
  lastAccessTime = other235.lastAccessTime;
  sd = other235.sd;
  parameters = other235.parameters;
  privileges = other235.privileges;
  __isset = other235.__isset;
}
Partition& Partition::operator=(const Partition& other236) {
  values = other236.values;
  dbName = other236.dbName;
  tableName = other236.tableName;
  createTime = other236.createTime;
  lastAccessTime = other236.lastAccessTime;
  sd = other236.sd;
  parameters = other236.parameters;
  privileges = other236.privileges;
  __isset = other236.__isset;
  return *this;
}
void Partition::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Partition(";
  out << "values=" << to_string(values);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "lastAccessTime=" << to_string(lastAccessTime);
  out << ", " << "sd=" << to_string(sd);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "privileges="; (__isset.privileges ? (out << to_string(privileges)) : (out << "<null>"));
  out << ")";
}


PartitionWithoutSD::~PartitionWithoutSD() noexcept {
}


void PartitionWithoutSD::__set_values(const std::vector<std::string> & val) {
  this->values = val;
}

void PartitionWithoutSD::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void PartitionWithoutSD::__set_lastAccessTime(const int32_t val) {
  this->lastAccessTime = val;
}

void PartitionWithoutSD::__set_relativePath(const std::string& val) {
  this->relativePath = val;
}

void PartitionWithoutSD::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void PartitionWithoutSD::__set_privileges(const PrincipalPrivilegeSet& val) {
  this->privileges = val;
__isset.privileges = true;
}
std::ostream& operator<<(std::ostream& out, const PartitionWithoutSD& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionWithoutSD::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size237;
            ::apache::thrift::protocol::TType _etype240;
            xfer += iprot->readListBegin(_etype240, _size237);
            this->values.resize(_size237);
            uint32_t _i241;
            for (_i241 = 0; _i241 < _size237; ++_i241)
            {
              xfer += iprot->readString(this->values[_i241]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastAccessTime);
          this->__isset.lastAccessTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->relativePath);
          this->__isset.relativePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size242;
            ::apache::thrift::protocol::TType _ktype243;
            ::apache::thrift::protocol::TType _vtype244;
            xfer += iprot->readMapBegin(_ktype243, _vtype244, _size242);
            uint32_t _i246;
            for (_i246 = 0; _i246 < _size242; ++_i246)
            {
              std::string _key247;
              xfer += iprot->readString(_key247);
              std::string& _val248 = this->parameters[_key247];
              xfer += iprot->readString(_val248);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privileges.read(iprot);
          this->__isset.privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PartitionWithoutSD::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionWithoutSD");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
    std::vector<std::string> ::const_iterator _iter249;
    for (_iter249 = this->values.begin(); _iter249 != this->values.end(); ++_iter249)
    {
      xfer += oprot->writeString((*_iter249));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastAccessTime", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->lastAccessTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("relativePath", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->relativePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter250;
    for (_iter250 = this->parameters.begin(); _iter250 != this->parameters.end(); ++_iter250)
    {
      xfer += oprot->writeString(_iter250->first);
      xfer += oprot->writeString(_iter250->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.privileges) {
    xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->privileges.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionWithoutSD &a, PartitionWithoutSD &b) {
  using ::std::swap;
  swap(a.values, b.values);
  swap(a.createTime, b.createTime);
  swap(a.lastAccessTime, b.lastAccessTime);
  swap(a.relativePath, b.relativePath);
  swap(a.parameters, b.parameters);
  swap(a.privileges, b.privileges);
  swap(a.__isset, b.__isset);
}

PartitionWithoutSD::PartitionWithoutSD(const PartitionWithoutSD& other251) {
  values = other251.values;
  createTime = other251.createTime;
  lastAccessTime = other251.lastAccessTime;
  relativePath = other251.relativePath;
  parameters = other251.parameters;
  privileges = other251.privileges;
  __isset = other251.__isset;
}
PartitionWithoutSD& PartitionWithoutSD::operator=(const PartitionWithoutSD& other252) {
  values = other252.values;
  createTime = other252.createTime;
  lastAccessTime = other252.lastAccessTime;
  relativePath = other252.relativePath;
  parameters = other252.parameters;
  privileges = other252.privileges;
  __isset = other252.__isset;
  return *this;
}
void PartitionWithoutSD::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionWithoutSD(";
  out << "values=" << to_string(values);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "lastAccessTime=" << to_string(lastAccessTime);
  out << ", " << "relativePath=" << to_string(relativePath);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "privileges="; (__isset.privileges ? (out << to_string(privileges)) : (out << "<null>"));
  out << ")";
}


PartitionSpecWithSharedSD::~PartitionSpecWithSharedSD() noexcept {
}


void PartitionSpecWithSharedSD::__set_partitions(const std::vector<PartitionWithoutSD> & val) {
  this->partitions = val;
}

void PartitionSpecWithSharedSD::__set_sd(const StorageDescriptor& val) {
  this->sd = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionSpecWithSharedSD& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionSpecWithSharedSD::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size253;
            ::apache::thrift::protocol::TType _etype256;
            xfer += iprot->readListBegin(_etype256, _size253);
            this->partitions.resize(_size253);
            uint32_t _i257;
            for (_i257 = 0; _i257 < _size253; ++_i257)
            {
              xfer += this->partitions[_i257].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sd.read(iprot);
          this->__isset.sd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PartitionSpecWithSharedSD::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionSpecWithSharedSD");

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<PartitionWithoutSD> ::const_iterator _iter258;
    for (_iter258 = this->partitions.begin(); _iter258 != this->partitions.end(); ++_iter258)
    {
      xfer += (*_iter258).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sd", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->sd.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionSpecWithSharedSD &a, PartitionSpecWithSharedSD &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
  swap(a.sd, b.sd);
  swap(a.__isset, b.__isset);
}

PartitionSpecWithSharedSD::PartitionSpecWithSharedSD(const PartitionSpecWithSharedSD& other259) {
  partitions = other259.partitions;
  sd = other259.sd;
  __isset = other259.__isset;
}
PartitionSpecWithSharedSD& PartitionSpecWithSharedSD::operator=(const PartitionSpecWithSharedSD& other260) {
  partitions = other260.partitions;
  sd = other260.sd;
  __isset = other260.__isset;
  return *this;
}
void PartitionSpecWithSharedSD::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionSpecWithSharedSD(";
  out << "partitions=" << to_string(partitions);
  out << ", " << "sd=" << to_string(sd);
  out << ")";
}


PartitionListComposingSpec::~PartitionListComposingSpec() noexcept {
}


void PartitionListComposingSpec::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionListComposingSpec& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionListComposingSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size261;
            ::apache::thrift::protocol::TType _etype264;
            xfer += iprot->readListBegin(_etype264, _size261);
            this->partitions.resize(_size261);
            uint32_t _i265;
            for (_i265 = 0; _i265 < _size261; ++_i265)
            {
              xfer += this->partitions[_i265].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PartitionListComposingSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionListComposingSpec");

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<Partition> ::const_iterator _iter266;
    for (_iter266 = this->partitions.begin(); _iter266 != this->partitions.end(); ++_iter266)
    {
      xfer += (*_iter266).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionListComposingSpec &a, PartitionListComposingSpec &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
  swap(a.__isset, b.__isset);
}

PartitionListComposingSpec::PartitionListComposingSpec(const PartitionListComposingSpec& other267) {
  partitions = other267.partitions;
  __isset = other267.__isset;
}
PartitionListComposingSpec& PartitionListComposingSpec::operator=(const PartitionListComposingSpec& other268) {
  partitions = other268.partitions;
  __isset = other268.__isset;
  return *this;
}
void PartitionListComposingSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionListComposingSpec(";
  out << "partitions=" << to_string(partitions);
  out << ")";
}


PartitionSpec::~PartitionSpec() noexcept {
}


void PartitionSpec::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void PartitionSpec::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void PartitionSpec::__set_rootPath(const std::string& val) {
  this->rootPath = val;
}

void PartitionSpec::__set_sharedSDPartitionSpec(const PartitionSpecWithSharedSD& val) {
  this->sharedSDPartitionSpec = val;
__isset.sharedSDPartitionSpec = true;
}

void PartitionSpec::__set_partitionList(const PartitionListComposingSpec& val) {
  this->partitionList = val;
__isset.partitionList = true;
}
std::ostream& operator<<(std::ostream& out, const PartitionSpec& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rootPath);
          this->__isset.rootPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sharedSDPartitionSpec.read(iprot);
          this->__isset.sharedSDPartitionSpec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->partitionList.read(iprot);
          this->__isset.partitionList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PartitionSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionSpec");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rootPath", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->rootPath);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sharedSDPartitionSpec) {
    xfer += oprot->writeFieldBegin("sharedSDPartitionSpec", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->sharedSDPartitionSpec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitionList) {
    xfer += oprot->writeFieldBegin("partitionList", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->partitionList.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionSpec &a, PartitionSpec &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.rootPath, b.rootPath);
  swap(a.sharedSDPartitionSpec, b.sharedSDPartitionSpec);
  swap(a.partitionList, b.partitionList);
  swap(a.__isset, b.__isset);
}

PartitionSpec::PartitionSpec(const PartitionSpec& other269) {
  dbName = other269.dbName;
  tableName = other269.tableName;
  rootPath = other269.rootPath;
  sharedSDPartitionSpec = other269.sharedSDPartitionSpec;
  partitionList = other269.partitionList;
  __isset = other269.__isset;
}
PartitionSpec& PartitionSpec::operator=(const PartitionSpec& other270) {
  dbName = other270.dbName;
  tableName = other270.tableName;
  rootPath = other270.rootPath;
  sharedSDPartitionSpec = other270.sharedSDPartitionSpec;
  partitionList = other270.partitionList;
  __isset = other270.__isset;
  return *this;
}
void PartitionSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionSpec(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "rootPath=" << to_string(rootPath);
  out << ", " << "sharedSDPartitionSpec="; (__isset.sharedSDPartitionSpec ? (out << to_string(sharedSDPartitionSpec)) : (out << "<null>"));
  out << ", " << "partitionList="; (__isset.partitionList ? (out << to_string(partitionList)) : (out << "<null>"));
  out << ")";
}


Index::~Index() noexcept {
}


void Index::__set_indexName(const std::string& val) {
  this->indexName = val;
}

void Index::__set_indexHandlerClass(const std::string& val) {
  this->indexHandlerClass = val;
}

void Index::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void Index::__set_origTableName(const std::string& val) {
  this->origTableName = val;
}

void Index::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void Index::__set_lastAccessTime(const int32_t val) {
  this->lastAccessTime = val;
}

void Index::__set_indexTableName(const std::string& val) {
  this->indexTableName = val;
}

void Index::__set_sd(const StorageDescriptor& val) {
  this->sd = val;
}

void Index::__set_parameters(const std::map<std::string, std::string> & val) {
  this->parameters = val;
}

void Index::__set_deferredRebuild(const bool val) {
  this->deferredRebuild = val;
}
std::ostream& operator<<(std::ostream& out, const Index& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Index::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->indexName);
          this->__isset.indexName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->indexHandlerClass);
          this->__isset.indexHandlerClass = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->origTableName);
          this->__isset.origTableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastAccessTime);
          this->__isset.lastAccessTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->indexTableName);
          this->__isset.indexTableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sd.read(iprot);
          this->__isset.sd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parameters.clear();
            uint32_t _size271;
            ::apache::thrift::protocol::TType _ktype272;
            ::apache::thrift::protocol::TType _vtype273;
            xfer += iprot->readMapBegin(_ktype272, _vtype273, _size271);
            uint32_t _i275;
            for (_i275 = 0; _i275 < _size271; ++_i275)
            {
              std::string _key276;
              xfer += iprot->readString(_key276);
              std::string& _val277 = this->parameters[_key276];
              xfer += iprot->readString(_val277);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->deferredRebuild);
          this->__isset.deferredRebuild = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Index::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Index");

  xfer += oprot->writeFieldBegin("indexName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->indexName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("indexHandlerClass", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->indexHandlerClass);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("origTableName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->origTableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastAccessTime", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->lastAccessTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("indexTableName", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->indexTableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sd", ::apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->sd.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_MAP, 9);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parameters.size()));
    std::map<std::string, std::string> ::const_iterator _iter278;
    for (_iter278 = this->parameters.begin(); _iter278 != this->parameters.end(); ++_iter278)
    {
      xfer += oprot->writeString(_iter278->first);
      xfer += oprot->writeString(_iter278->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deferredRebuild", ::apache::thrift::protocol::T_BOOL, 10);
  xfer += oprot->writeBool(this->deferredRebuild);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Index &a, Index &b) {
  using ::std::swap;
  swap(a.indexName, b.indexName);
  swap(a.indexHandlerClass, b.indexHandlerClass);
  swap(a.dbName, b.dbName);
  swap(a.origTableName, b.origTableName);
  swap(a.createTime, b.createTime);
  swap(a.lastAccessTime, b.lastAccessTime);
  swap(a.indexTableName, b.indexTableName);
  swap(a.sd, b.sd);
  swap(a.parameters, b.parameters);
  swap(a.deferredRebuild, b.deferredRebuild);
  swap(a.__isset, b.__isset);
}

Index::Index(const Index& other279) {
  indexName = other279.indexName;
  indexHandlerClass = other279.indexHandlerClass;
  dbName = other279.dbName;
  origTableName = other279.origTableName;
  createTime = other279.createTime;
  lastAccessTime = other279.lastAccessTime;
  indexTableName = other279.indexTableName;
  sd = other279.sd;
  parameters = other279.parameters;
  deferredRebuild = other279.deferredRebuild;
  __isset = other279.__isset;
}
Index& Index::operator=(const Index& other280) {
  indexName = other280.indexName;
  indexHandlerClass = other280.indexHandlerClass;
  dbName = other280.dbName;
  origTableName = other280.origTableName;
  createTime = other280.createTime;
  lastAccessTime = other280.lastAccessTime;
  indexTableName = other280.indexTableName;
  sd = other280.sd;
  parameters = other280.parameters;
  deferredRebuild = other280.deferredRebuild;
  __isset = other280.__isset;
  return *this;
}
void Index::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Index(";
  out << "indexName=" << to_string(indexName);
  out << ", " << "indexHandlerClass=" << to_string(indexHandlerClass);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "origTableName=" << to_string(origTableName);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "lastAccessTime=" << to_string(lastAccessTime);
  out << ", " << "indexTableName=" << to_string(indexTableName);
  out << ", " << "sd=" << to_string(sd);
  out << ", " << "parameters=" << to_string(parameters);
  out << ", " << "deferredRebuild=" << to_string(deferredRebuild);
  out << ")";
}


BooleanColumnStatsData::~BooleanColumnStatsData() noexcept {
}


void BooleanColumnStatsData::__set_numTrues(const int64_t val) {
  this->numTrues = val;
}

void BooleanColumnStatsData::__set_numFalses(const int64_t val) {
  this->numFalses = val;
}

void BooleanColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void BooleanColumnStatsData::__set_bitVectors(const std::string& val) {
  this->bitVectors = val;
__isset.bitVectors = true;
}
std::ostream& operator<<(std::ostream& out, const BooleanColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BooleanColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_numTrues = false;
  bool isset_numFalses = false;
  bool isset_numNulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numTrues);
          isset_numTrues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numFalses);
          isset_numFalses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitVectors);
          this->__isset.bitVectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_numTrues)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numFalses)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t BooleanColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BooleanColumnStatsData");

  xfer += oprot->writeFieldBegin("numTrues", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->numTrues);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numFalses", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->numFalses);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitVectors) {
    xfer += oprot->writeFieldBegin("bitVectors", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeBinary(this->bitVectors);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BooleanColumnStatsData &a, BooleanColumnStatsData &b) {
  using ::std::swap;
  swap(a.numTrues, b.numTrues);
  swap(a.numFalses, b.numFalses);
  swap(a.numNulls, b.numNulls);
  swap(a.bitVectors, b.bitVectors);
  swap(a.__isset, b.__isset);
}

BooleanColumnStatsData::BooleanColumnStatsData(const BooleanColumnStatsData& other281) {
  numTrues = other281.numTrues;
  numFalses = other281.numFalses;
  numNulls = other281.numNulls;
  bitVectors = other281.bitVectors;
  __isset = other281.__isset;
}
BooleanColumnStatsData& BooleanColumnStatsData::operator=(const BooleanColumnStatsData& other282) {
  numTrues = other282.numTrues;
  numFalses = other282.numFalses;
  numNulls = other282.numNulls;
  bitVectors = other282.bitVectors;
  __isset = other282.__isset;
  return *this;
}
void BooleanColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BooleanColumnStatsData(";
  out << "numTrues=" << to_string(numTrues);
  out << ", " << "numFalses=" << to_string(numFalses);
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "bitVectors="; (__isset.bitVectors ? (out << to_string(bitVectors)) : (out << "<null>"));
  out << ")";
}


DoubleColumnStatsData::~DoubleColumnStatsData() noexcept {
}


void DoubleColumnStatsData::__set_lowValue(const double val) {
  this->lowValue = val;
__isset.lowValue = true;
}

void DoubleColumnStatsData::__set_highValue(const double val) {
  this->highValue = val;
__isset.highValue = true;
}

void DoubleColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void DoubleColumnStatsData::__set_numDVs(const int64_t val) {
  this->numDVs = val;
}

void DoubleColumnStatsData::__set_bitVectors(const std::string& val) {
  this->bitVectors = val;
__isset.bitVectors = true;
}
std::ostream& operator<<(std::ostream& out, const DoubleColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DoubleColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_numNulls = false;
  bool isset_numDVs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->lowValue);
          this->__isset.lowValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->highValue);
          this->__isset.highValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numDVs);
          isset_numDVs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitVectors);
          this->__isset.bitVectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numDVs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DoubleColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DoubleColumnStatsData");

  if (this->__isset.lowValue) {
    xfer += oprot->writeFieldBegin("lowValue", ::apache::thrift::protocol::T_DOUBLE, 1);
    xfer += oprot->writeDouble(this->lowValue);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.highValue) {
    xfer += oprot->writeFieldBegin("highValue", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->highValue);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numDVs", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->numDVs);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitVectors) {
    xfer += oprot->writeFieldBegin("bitVectors", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->bitVectors);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DoubleColumnStatsData &a, DoubleColumnStatsData &b) {
  using ::std::swap;
  swap(a.lowValue, b.lowValue);
  swap(a.highValue, b.highValue);
  swap(a.numNulls, b.numNulls);
  swap(a.numDVs, b.numDVs);
  swap(a.bitVectors, b.bitVectors);
  swap(a.__isset, b.__isset);
}

DoubleColumnStatsData::DoubleColumnStatsData(const DoubleColumnStatsData& other283) {
  lowValue = other283.lowValue;
  highValue = other283.highValue;
  numNulls = other283.numNulls;
  numDVs = other283.numDVs;
  bitVectors = other283.bitVectors;
  __isset = other283.__isset;
}
DoubleColumnStatsData& DoubleColumnStatsData::operator=(const DoubleColumnStatsData& other284) {
  lowValue = other284.lowValue;
  highValue = other284.highValue;
  numNulls = other284.numNulls;
  numDVs = other284.numDVs;
  bitVectors = other284.bitVectors;
  __isset = other284.__isset;
  return *this;
}
void DoubleColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DoubleColumnStatsData(";
  out << "lowValue="; (__isset.lowValue ? (out << to_string(lowValue)) : (out << "<null>"));
  out << ", " << "highValue="; (__isset.highValue ? (out << to_string(highValue)) : (out << "<null>"));
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "numDVs=" << to_string(numDVs);
  out << ", " << "bitVectors="; (__isset.bitVectors ? (out << to_string(bitVectors)) : (out << "<null>"));
  out << ")";
}


LongColumnStatsData::~LongColumnStatsData() noexcept {
}


void LongColumnStatsData::__set_lowValue(const int64_t val) {
  this->lowValue = val;
__isset.lowValue = true;
}

void LongColumnStatsData::__set_highValue(const int64_t val) {
  this->highValue = val;
__isset.highValue = true;
}

void LongColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void LongColumnStatsData::__set_numDVs(const int64_t val) {
  this->numDVs = val;
}

void LongColumnStatsData::__set_bitVectors(const std::string& val) {
  this->bitVectors = val;
__isset.bitVectors = true;
}
std::ostream& operator<<(std::ostream& out, const LongColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LongColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_numNulls = false;
  bool isset_numDVs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lowValue);
          this->__isset.lowValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->highValue);
          this->__isset.highValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numDVs);
          isset_numDVs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitVectors);
          this->__isset.bitVectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numDVs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LongColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LongColumnStatsData");

  if (this->__isset.lowValue) {
    xfer += oprot->writeFieldBegin("lowValue", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->lowValue);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.highValue) {
    xfer += oprot->writeFieldBegin("highValue", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->highValue);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numDVs", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->numDVs);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitVectors) {
    xfer += oprot->writeFieldBegin("bitVectors", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->bitVectors);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LongColumnStatsData &a, LongColumnStatsData &b) {
  using ::std::swap;
  swap(a.lowValue, b.lowValue);
  swap(a.highValue, b.highValue);
  swap(a.numNulls, b.numNulls);
  swap(a.numDVs, b.numDVs);
  swap(a.bitVectors, b.bitVectors);
  swap(a.__isset, b.__isset);
}

LongColumnStatsData::LongColumnStatsData(const LongColumnStatsData& other285) {
  lowValue = other285.lowValue;
  highValue = other285.highValue;
  numNulls = other285.numNulls;
  numDVs = other285.numDVs;
  bitVectors = other285.bitVectors;
  __isset = other285.__isset;
}
LongColumnStatsData& LongColumnStatsData::operator=(const LongColumnStatsData& other286) {
  lowValue = other286.lowValue;
  highValue = other286.highValue;
  numNulls = other286.numNulls;
  numDVs = other286.numDVs;
  bitVectors = other286.bitVectors;
  __isset = other286.__isset;
  return *this;
}
void LongColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LongColumnStatsData(";
  out << "lowValue="; (__isset.lowValue ? (out << to_string(lowValue)) : (out << "<null>"));
  out << ", " << "highValue="; (__isset.highValue ? (out << to_string(highValue)) : (out << "<null>"));
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "numDVs=" << to_string(numDVs);
  out << ", " << "bitVectors="; (__isset.bitVectors ? (out << to_string(bitVectors)) : (out << "<null>"));
  out << ")";
}


StringColumnStatsData::~StringColumnStatsData() noexcept {
}


void StringColumnStatsData::__set_maxColLen(const int64_t val) {
  this->maxColLen = val;
}

void StringColumnStatsData::__set_avgColLen(const double val) {
  this->avgColLen = val;
}

void StringColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void StringColumnStatsData::__set_numDVs(const int64_t val) {
  this->numDVs = val;
}

void StringColumnStatsData::__set_bitVectors(const std::string& val) {
  this->bitVectors = val;
__isset.bitVectors = true;
}
std::ostream& operator<<(std::ostream& out, const StringColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StringColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_maxColLen = false;
  bool isset_avgColLen = false;
  bool isset_numNulls = false;
  bool isset_numDVs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxColLen);
          isset_maxColLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->avgColLen);
          isset_avgColLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numDVs);
          isset_numDVs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitVectors);
          this->__isset.bitVectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_maxColLen)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_avgColLen)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numDVs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t StringColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StringColumnStatsData");

  xfer += oprot->writeFieldBegin("maxColLen", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->maxColLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("avgColLen", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->avgColLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numDVs", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->numDVs);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitVectors) {
    xfer += oprot->writeFieldBegin("bitVectors", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->bitVectors);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StringColumnStatsData &a, StringColumnStatsData &b) {
  using ::std::swap;
  swap(a.maxColLen, b.maxColLen);
  swap(a.avgColLen, b.avgColLen);
  swap(a.numNulls, b.numNulls);
  swap(a.numDVs, b.numDVs);
  swap(a.bitVectors, b.bitVectors);
  swap(a.__isset, b.__isset);
}

StringColumnStatsData::StringColumnStatsData(const StringColumnStatsData& other287) {
  maxColLen = other287.maxColLen;
  avgColLen = other287.avgColLen;
  numNulls = other287.numNulls;
  numDVs = other287.numDVs;
  bitVectors = other287.bitVectors;
  __isset = other287.__isset;
}
StringColumnStatsData& StringColumnStatsData::operator=(const StringColumnStatsData& other288) {
  maxColLen = other288.maxColLen;
  avgColLen = other288.avgColLen;
  numNulls = other288.numNulls;
  numDVs = other288.numDVs;
  bitVectors = other288.bitVectors;
  __isset = other288.__isset;
  return *this;
}
void StringColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StringColumnStatsData(";
  out << "maxColLen=" << to_string(maxColLen);
  out << ", " << "avgColLen=" << to_string(avgColLen);
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "numDVs=" << to_string(numDVs);
  out << ", " << "bitVectors="; (__isset.bitVectors ? (out << to_string(bitVectors)) : (out << "<null>"));
  out << ")";
}


BinaryColumnStatsData::~BinaryColumnStatsData() noexcept {
}


void BinaryColumnStatsData::__set_maxColLen(const int64_t val) {
  this->maxColLen = val;
}

void BinaryColumnStatsData::__set_avgColLen(const double val) {
  this->avgColLen = val;
}

void BinaryColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void BinaryColumnStatsData::__set_bitVectors(const std::string& val) {
  this->bitVectors = val;
__isset.bitVectors = true;
}
std::ostream& operator<<(std::ostream& out, const BinaryColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BinaryColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_maxColLen = false;
  bool isset_avgColLen = false;
  bool isset_numNulls = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxColLen);
          isset_maxColLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->avgColLen);
          isset_avgColLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitVectors);
          this->__isset.bitVectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_maxColLen)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_avgColLen)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t BinaryColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BinaryColumnStatsData");

  xfer += oprot->writeFieldBegin("maxColLen", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->maxColLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("avgColLen", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->avgColLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitVectors) {
    xfer += oprot->writeFieldBegin("bitVectors", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeBinary(this->bitVectors);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BinaryColumnStatsData &a, BinaryColumnStatsData &b) {
  using ::std::swap;
  swap(a.maxColLen, b.maxColLen);
  swap(a.avgColLen, b.avgColLen);
  swap(a.numNulls, b.numNulls);
  swap(a.bitVectors, b.bitVectors);
  swap(a.__isset, b.__isset);
}

BinaryColumnStatsData::BinaryColumnStatsData(const BinaryColumnStatsData& other289) {
  maxColLen = other289.maxColLen;
  avgColLen = other289.avgColLen;
  numNulls = other289.numNulls;
  bitVectors = other289.bitVectors;
  __isset = other289.__isset;
}
BinaryColumnStatsData& BinaryColumnStatsData::operator=(const BinaryColumnStatsData& other290) {
  maxColLen = other290.maxColLen;
  avgColLen = other290.avgColLen;
  numNulls = other290.numNulls;
  bitVectors = other290.bitVectors;
  __isset = other290.__isset;
  return *this;
}
void BinaryColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BinaryColumnStatsData(";
  out << "maxColLen=" << to_string(maxColLen);
  out << ", " << "avgColLen=" << to_string(avgColLen);
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "bitVectors="; (__isset.bitVectors ? (out << to_string(bitVectors)) : (out << "<null>"));
  out << ")";
}


Decimal::~Decimal() noexcept {
}


void Decimal::__set_unscaled(const std::string& val) {
  this->unscaled = val;
}

void Decimal::__set_scale(const int16_t val) {
  this->scale = val;
}
std::ostream& operator<<(std::ostream& out, const Decimal& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Decimal::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_unscaled = false;
  bool isset_scale = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->unscaled);
          isset_unscaled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->scale);
          isset_scale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_unscaled)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_scale)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Decimal::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Decimal");

  xfer += oprot->writeFieldBegin("unscaled", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->unscaled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scale", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->scale);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Decimal &a, Decimal &b) {
  using ::std::swap;
  swap(a.unscaled, b.unscaled);
  swap(a.scale, b.scale);
}

Decimal::Decimal(const Decimal& other291) {
  unscaled = other291.unscaled;
  scale = other291.scale;
}
Decimal& Decimal::operator=(const Decimal& other292) {
  unscaled = other292.unscaled;
  scale = other292.scale;
  return *this;
}
void Decimal::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Decimal(";
  out << "unscaled=" << to_string(unscaled);
  out << ", " << "scale=" << to_string(scale);
  out << ")";
}


DecimalColumnStatsData::~DecimalColumnStatsData() noexcept {
}


void DecimalColumnStatsData::__set_lowValue(const Decimal& val) {
  this->lowValue = val;
__isset.lowValue = true;
}

void DecimalColumnStatsData::__set_highValue(const Decimal& val) {
  this->highValue = val;
__isset.highValue = true;
}

void DecimalColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void DecimalColumnStatsData::__set_numDVs(const int64_t val) {
  this->numDVs = val;
}

void DecimalColumnStatsData::__set_bitVectors(const std::string& val) {
  this->bitVectors = val;
__isset.bitVectors = true;
}
std::ostream& operator<<(std::ostream& out, const DecimalColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DecimalColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_numNulls = false;
  bool isset_numDVs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lowValue.read(iprot);
          this->__isset.lowValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->highValue.read(iprot);
          this->__isset.highValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numDVs);
          isset_numDVs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitVectors);
          this->__isset.bitVectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numDVs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DecimalColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DecimalColumnStatsData");

  if (this->__isset.lowValue) {
    xfer += oprot->writeFieldBegin("lowValue", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->lowValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.highValue) {
    xfer += oprot->writeFieldBegin("highValue", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->highValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numDVs", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->numDVs);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitVectors) {
    xfer += oprot->writeFieldBegin("bitVectors", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->bitVectors);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DecimalColumnStatsData &a, DecimalColumnStatsData &b) {
  using ::std::swap;
  swap(a.lowValue, b.lowValue);
  swap(a.highValue, b.highValue);
  swap(a.numNulls, b.numNulls);
  swap(a.numDVs, b.numDVs);
  swap(a.bitVectors, b.bitVectors);
  swap(a.__isset, b.__isset);
}

DecimalColumnStatsData::DecimalColumnStatsData(const DecimalColumnStatsData& other293) {
  lowValue = other293.lowValue;
  highValue = other293.highValue;
  numNulls = other293.numNulls;
  numDVs = other293.numDVs;
  bitVectors = other293.bitVectors;
  __isset = other293.__isset;
}
DecimalColumnStatsData& DecimalColumnStatsData::operator=(const DecimalColumnStatsData& other294) {
  lowValue = other294.lowValue;
  highValue = other294.highValue;
  numNulls = other294.numNulls;
  numDVs = other294.numDVs;
  bitVectors = other294.bitVectors;
  __isset = other294.__isset;
  return *this;
}
void DecimalColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DecimalColumnStatsData(";
  out << "lowValue="; (__isset.lowValue ? (out << to_string(lowValue)) : (out << "<null>"));
  out << ", " << "highValue="; (__isset.highValue ? (out << to_string(highValue)) : (out << "<null>"));
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "numDVs=" << to_string(numDVs);
  out << ", " << "bitVectors="; (__isset.bitVectors ? (out << to_string(bitVectors)) : (out << "<null>"));
  out << ")";
}


Date::~Date() noexcept {
}


void Date::__set_daysSinceEpoch(const int64_t val) {
  this->daysSinceEpoch = val;
}
std::ostream& operator<<(std::ostream& out, const Date& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Date::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_daysSinceEpoch = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->daysSinceEpoch);
          isset_daysSinceEpoch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_daysSinceEpoch)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Date::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Date");

  xfer += oprot->writeFieldBegin("daysSinceEpoch", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->daysSinceEpoch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Date &a, Date &b) {
  using ::std::swap;
  swap(a.daysSinceEpoch, b.daysSinceEpoch);
}

Date::Date(const Date& other295) {
  daysSinceEpoch = other295.daysSinceEpoch;
}
Date& Date::operator=(const Date& other296) {
  daysSinceEpoch = other296.daysSinceEpoch;
  return *this;
}
void Date::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Date(";
  out << "daysSinceEpoch=" << to_string(daysSinceEpoch);
  out << ")";
}


DateColumnStatsData::~DateColumnStatsData() noexcept {
}


void DateColumnStatsData::__set_lowValue(const Date& val) {
  this->lowValue = val;
__isset.lowValue = true;
}

void DateColumnStatsData::__set_highValue(const Date& val) {
  this->highValue = val;
__isset.highValue = true;
}

void DateColumnStatsData::__set_numNulls(const int64_t val) {
  this->numNulls = val;
}

void DateColumnStatsData::__set_numDVs(const int64_t val) {
  this->numDVs = val;
}

void DateColumnStatsData::__set_bitVectors(const std::string& val) {
  this->bitVectors = val;
__isset.bitVectors = true;
}
std::ostream& operator<<(std::ostream& out, const DateColumnStatsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DateColumnStatsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_numNulls = false;
  bool isset_numDVs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lowValue.read(iprot);
          this->__isset.lowValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->highValue.read(iprot);
          this->__isset.highValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numNulls);
          isset_numNulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->numDVs);
          isset_numDVs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bitVectors);
          this->__isset.bitVectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_numNulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numDVs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DateColumnStatsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DateColumnStatsData");

  if (this->__isset.lowValue) {
    xfer += oprot->writeFieldBegin("lowValue", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->lowValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.highValue) {
    xfer += oprot->writeFieldBegin("highValue", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->highValue.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("numNulls", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->numNulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numDVs", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->numDVs);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitVectors) {
    xfer += oprot->writeFieldBegin("bitVectors", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->bitVectors);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DateColumnStatsData &a, DateColumnStatsData &b) {
  using ::std::swap;
  swap(a.lowValue, b.lowValue);
  swap(a.highValue, b.highValue);
  swap(a.numNulls, b.numNulls);
  swap(a.numDVs, b.numDVs);
  swap(a.bitVectors, b.bitVectors);
  swap(a.__isset, b.__isset);
}

DateColumnStatsData::DateColumnStatsData(const DateColumnStatsData& other297) {
  lowValue = other297.lowValue;
  highValue = other297.highValue;
  numNulls = other297.numNulls;
  numDVs = other297.numDVs;
  bitVectors = other297.bitVectors;
  __isset = other297.__isset;
}
DateColumnStatsData& DateColumnStatsData::operator=(const DateColumnStatsData& other298) {
  lowValue = other298.lowValue;
  highValue = other298.highValue;
  numNulls = other298.numNulls;
  numDVs = other298.numDVs;
  bitVectors = other298.bitVectors;
  __isset = other298.__isset;
  return *this;
}
void DateColumnStatsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DateColumnStatsData(";
  out << "lowValue="; (__isset.lowValue ? (out << to_string(lowValue)) : (out << "<null>"));
  out << ", " << "highValue="; (__isset.highValue ? (out << to_string(highValue)) : (out << "<null>"));
  out << ", " << "numNulls=" << to_string(numNulls);
  out << ", " << "numDVs=" << to_string(numDVs);
  out << ", " << "bitVectors="; (__isset.bitVectors ? (out << to_string(bitVectors)) : (out << "<null>"));
  out << ")";
}


ColumnStatisticsData::~ColumnStatisticsData() noexcept {
}


void ColumnStatisticsData::__set_booleanStats(const BooleanColumnStatsData& val) {
  this->booleanStats = val;
__isset.booleanStats = true;
}

void ColumnStatisticsData::__set_longStats(const LongColumnStatsData& val) {
  this->longStats = val;
__isset.longStats = true;
}

void ColumnStatisticsData::__set_doubleStats(const DoubleColumnStatsData& val) {
  this->doubleStats = val;
__isset.doubleStats = true;
}

void ColumnStatisticsData::__set_stringStats(const StringColumnStatsData& val) {
  this->stringStats = val;
__isset.stringStats = true;
}

void ColumnStatisticsData::__set_binaryStats(const BinaryColumnStatsData& val) {
  this->binaryStats = val;
__isset.binaryStats = true;
}

void ColumnStatisticsData::__set_decimalStats(const DecimalColumnStatsData& val) {
  this->decimalStats = val;
__isset.decimalStats = true;
}

void ColumnStatisticsData::__set_dateStats(const DateColumnStatsData& val) {
  this->dateStats = val;
__isset.dateStats = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnStatisticsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnStatisticsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->booleanStats.read(iprot);
          this->__isset.booleanStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->longStats.read(iprot);
          this->__isset.longStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->doubleStats.read(iprot);
          this->__isset.doubleStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stringStats.read(iprot);
          this->__isset.stringStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->binaryStats.read(iprot);
          this->__isset.binaryStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->decimalStats.read(iprot);
          this->__isset.decimalStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dateStats.read(iprot);
          this->__isset.dateStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnStatisticsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnStatisticsData");

  if (this->__isset.booleanStats) {
    xfer += oprot->writeFieldBegin("booleanStats", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->booleanStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.longStats) {
    xfer += oprot->writeFieldBegin("longStats", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->longStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.doubleStats) {
    xfer += oprot->writeFieldBegin("doubleStats", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->doubleStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stringStats) {
    xfer += oprot->writeFieldBegin("stringStats", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->stringStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.binaryStats) {
    xfer += oprot->writeFieldBegin("binaryStats", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->binaryStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.decimalStats) {
    xfer += oprot->writeFieldBegin("decimalStats", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->decimalStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dateStats) {
    xfer += oprot->writeFieldBegin("dateStats", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->dateStats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnStatisticsData &a, ColumnStatisticsData &b) {
  using ::std::swap;
  swap(a.booleanStats, b.booleanStats);
  swap(a.longStats, b.longStats);
  swap(a.doubleStats, b.doubleStats);
  swap(a.stringStats, b.stringStats);
  swap(a.binaryStats, b.binaryStats);
  swap(a.decimalStats, b.decimalStats);
  swap(a.dateStats, b.dateStats);
  swap(a.__isset, b.__isset);
}

ColumnStatisticsData::ColumnStatisticsData(const ColumnStatisticsData& other299) {
  booleanStats = other299.booleanStats;
  longStats = other299.longStats;
  doubleStats = other299.doubleStats;
  stringStats = other299.stringStats;
  binaryStats = other299.binaryStats;
  decimalStats = other299.decimalStats;
  dateStats = other299.dateStats;
  __isset = other299.__isset;
}
ColumnStatisticsData& ColumnStatisticsData::operator=(const ColumnStatisticsData& other300) {
  booleanStats = other300.booleanStats;
  longStats = other300.longStats;
  doubleStats = other300.doubleStats;
  stringStats = other300.stringStats;
  binaryStats = other300.binaryStats;
  decimalStats = other300.decimalStats;
  dateStats = other300.dateStats;
  __isset = other300.__isset;
  return *this;
}
void ColumnStatisticsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnStatisticsData(";
  out << "booleanStats="; (__isset.booleanStats ? (out << to_string(booleanStats)) : (out << "<null>"));
  out << ", " << "longStats="; (__isset.longStats ? (out << to_string(longStats)) : (out << "<null>"));
  out << ", " << "doubleStats="; (__isset.doubleStats ? (out << to_string(doubleStats)) : (out << "<null>"));
  out << ", " << "stringStats="; (__isset.stringStats ? (out << to_string(stringStats)) : (out << "<null>"));
  out << ", " << "binaryStats="; (__isset.binaryStats ? (out << to_string(binaryStats)) : (out << "<null>"));
  out << ", " << "decimalStats="; (__isset.decimalStats ? (out << to_string(decimalStats)) : (out << "<null>"));
  out << ", " << "dateStats="; (__isset.dateStats ? (out << to_string(dateStats)) : (out << "<null>"));
  out << ")";
}


ColumnStatisticsObj::~ColumnStatisticsObj() noexcept {
}


void ColumnStatisticsObj::__set_colName(const std::string& val) {
  this->colName = val;
}

void ColumnStatisticsObj::__set_colType(const std::string& val) {
  this->colType = val;
}

void ColumnStatisticsObj::__set_statsData(const ColumnStatisticsData& val) {
  this->statsData = val;
}
std::ostream& operator<<(std::ostream& out, const ColumnStatisticsObj& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnStatisticsObj::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_colName = false;
  bool isset_colType = false;
  bool isset_statsData = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->colName);
          isset_colName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->colType);
          isset_colType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->statsData.read(iprot);
          isset_statsData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_colName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_colType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statsData)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnStatisticsObj::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnStatisticsObj");

  xfer += oprot->writeFieldBegin("colName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->colName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colType", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->colType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statsData", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->statsData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnStatisticsObj &a, ColumnStatisticsObj &b) {
  using ::std::swap;
  swap(a.colName, b.colName);
  swap(a.colType, b.colType);
  swap(a.statsData, b.statsData);
}

ColumnStatisticsObj::ColumnStatisticsObj(const ColumnStatisticsObj& other301) {
  colName = other301.colName;
  colType = other301.colType;
  statsData = other301.statsData;
}
ColumnStatisticsObj& ColumnStatisticsObj::operator=(const ColumnStatisticsObj& other302) {
  colName = other302.colName;
  colType = other302.colType;
  statsData = other302.statsData;
  return *this;
}
void ColumnStatisticsObj::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnStatisticsObj(";
  out << "colName=" << to_string(colName);
  out << ", " << "colType=" << to_string(colType);
  out << ", " << "statsData=" << to_string(statsData);
  out << ")";
}


ColumnStatisticsDesc::~ColumnStatisticsDesc() noexcept {
}


void ColumnStatisticsDesc::__set_isTblLevel(const bool val) {
  this->isTblLevel = val;
}

void ColumnStatisticsDesc::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void ColumnStatisticsDesc::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void ColumnStatisticsDesc::__set_partName(const std::string& val) {
  this->partName = val;
__isset.partName = true;
}

void ColumnStatisticsDesc::__set_lastAnalyzed(const int64_t val) {
  this->lastAnalyzed = val;
__isset.lastAnalyzed = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnStatisticsDesc& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnStatisticsDesc::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_isTblLevel = false;
  bool isset_dbName = false;
  bool isset_tableName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isTblLevel);
          isset_isTblLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partName);
          this->__isset.partName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastAnalyzed);
          this->__isset.lastAnalyzed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_isTblLevel)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnStatisticsDesc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnStatisticsDesc");

  xfer += oprot->writeFieldBegin("isTblLevel", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->isTblLevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partName) {
    xfer += oprot->writeFieldBegin("partName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->partName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastAnalyzed) {
    xfer += oprot->writeFieldBegin("lastAnalyzed", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->lastAnalyzed);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnStatisticsDesc &a, ColumnStatisticsDesc &b) {
  using ::std::swap;
  swap(a.isTblLevel, b.isTblLevel);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.partName, b.partName);
  swap(a.lastAnalyzed, b.lastAnalyzed);
  swap(a.__isset, b.__isset);
}

ColumnStatisticsDesc::ColumnStatisticsDesc(const ColumnStatisticsDesc& other303) {
  isTblLevel = other303.isTblLevel;
  dbName = other303.dbName;
  tableName = other303.tableName;
  partName = other303.partName;
  lastAnalyzed = other303.lastAnalyzed;
  __isset = other303.__isset;
}
ColumnStatisticsDesc& ColumnStatisticsDesc::operator=(const ColumnStatisticsDesc& other304) {
  isTblLevel = other304.isTblLevel;
  dbName = other304.dbName;
  tableName = other304.tableName;
  partName = other304.partName;
  lastAnalyzed = other304.lastAnalyzed;
  __isset = other304.__isset;
  return *this;
}
void ColumnStatisticsDesc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnStatisticsDesc(";
  out << "isTblLevel=" << to_string(isTblLevel);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "partName="; (__isset.partName ? (out << to_string(partName)) : (out << "<null>"));
  out << ", " << "lastAnalyzed="; (__isset.lastAnalyzed ? (out << to_string(lastAnalyzed)) : (out << "<null>"));
  out << ")";
}


ColumnStatistics::~ColumnStatistics() noexcept {
}


void ColumnStatistics::__set_statsDesc(const ColumnStatisticsDesc& val) {
  this->statsDesc = val;
}

void ColumnStatistics::__set_statsObj(const std::vector<ColumnStatisticsObj> & val) {
  this->statsObj = val;
}
std::ostream& operator<<(std::ostream& out, const ColumnStatistics& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnStatistics::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_statsDesc = false;
  bool isset_statsObj = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->statsDesc.read(iprot);
          isset_statsDesc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->statsObj.clear();
            uint32_t _size305;
            ::apache::thrift::protocol::TType _etype308;
            xfer += iprot->readListBegin(_etype308, _size305);
            this->statsObj.resize(_size305);
            uint32_t _i309;
            for (_i309 = 0; _i309 < _size305; ++_i309)
            {
              xfer += this->statsObj[_i309].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_statsObj = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_statsDesc)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statsObj)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnStatistics::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnStatistics");

  xfer += oprot->writeFieldBegin("statsDesc", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->statsDesc.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statsObj", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->statsObj.size()));
    std::vector<ColumnStatisticsObj> ::const_iterator _iter310;
    for (_iter310 = this->statsObj.begin(); _iter310 != this->statsObj.end(); ++_iter310)
    {
      xfer += (*_iter310).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnStatistics &a, ColumnStatistics &b) {
  using ::std::swap;
  swap(a.statsDesc, b.statsDesc);
  swap(a.statsObj, b.statsObj);
}

ColumnStatistics::ColumnStatistics(const ColumnStatistics& other311) {
  statsDesc = other311.statsDesc;
  statsObj = other311.statsObj;
}
ColumnStatistics& ColumnStatistics::operator=(const ColumnStatistics& other312) {
  statsDesc = other312.statsDesc;
  statsObj = other312.statsObj;
  return *this;
}
void ColumnStatistics::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnStatistics(";
  out << "statsDesc=" << to_string(statsDesc);
  out << ", " << "statsObj=" << to_string(statsObj);
  out << ")";
}


AggrStats::~AggrStats() noexcept {
}


void AggrStats::__set_colStats(const std::vector<ColumnStatisticsObj> & val) {
  this->colStats = val;
}

void AggrStats::__set_partsFound(const int64_t val) {
  this->partsFound = val;
}
std::ostream& operator<<(std::ostream& out, const AggrStats& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AggrStats::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_colStats = false;
  bool isset_partsFound = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colStats.clear();
            uint32_t _size313;
            ::apache::thrift::protocol::TType _etype316;
            xfer += iprot->readListBegin(_etype316, _size313);
            this->colStats.resize(_size313);
            uint32_t _i317;
            for (_i317 = 0; _i317 < _size313; ++_i317)
            {
              xfer += this->colStats[_i317].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_colStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->partsFound);
          isset_partsFound = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_colStats)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partsFound)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AggrStats::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AggrStats");

  xfer += oprot->writeFieldBegin("colStats", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->colStats.size()));
    std::vector<ColumnStatisticsObj> ::const_iterator _iter318;
    for (_iter318 = this->colStats.begin(); _iter318 != this->colStats.end(); ++_iter318)
    {
      xfer += (*_iter318).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partsFound", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->partsFound);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AggrStats &a, AggrStats &b) {
  using ::std::swap;
  swap(a.colStats, b.colStats);
  swap(a.partsFound, b.partsFound);
}

AggrStats::AggrStats(const AggrStats& other319) {
  colStats = other319.colStats;
  partsFound = other319.partsFound;
}
AggrStats& AggrStats::operator=(const AggrStats& other320) {
  colStats = other320.colStats;
  partsFound = other320.partsFound;
  return *this;
}
void AggrStats::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AggrStats(";
  out << "colStats=" << to_string(colStats);
  out << ", " << "partsFound=" << to_string(partsFound);
  out << ")";
}


SetPartitionsStatsRequest::~SetPartitionsStatsRequest() noexcept {
}


void SetPartitionsStatsRequest::__set_colStats(const std::vector<ColumnStatistics> & val) {
  this->colStats = val;
}

void SetPartitionsStatsRequest::__set_needMerge(const bool val) {
  this->needMerge = val;
__isset.needMerge = true;
}
std::ostream& operator<<(std::ostream& out, const SetPartitionsStatsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SetPartitionsStatsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_colStats = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colStats.clear();
            uint32_t _size321;
            ::apache::thrift::protocol::TType _etype324;
            xfer += iprot->readListBegin(_etype324, _size321);
            this->colStats.resize(_size321);
            uint32_t _i325;
            for (_i325 = 0; _i325 < _size321; ++_i325)
            {
              xfer += this->colStats[_i325].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_colStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->needMerge);
          this->__isset.needMerge = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_colStats)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SetPartitionsStatsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SetPartitionsStatsRequest");

  xfer += oprot->writeFieldBegin("colStats", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->colStats.size()));
    std::vector<ColumnStatistics> ::const_iterator _iter326;
    for (_iter326 = this->colStats.begin(); _iter326 != this->colStats.end(); ++_iter326)
    {
      xfer += (*_iter326).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.needMerge) {
    xfer += oprot->writeFieldBegin("needMerge", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->needMerge);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SetPartitionsStatsRequest &a, SetPartitionsStatsRequest &b) {
  using ::std::swap;
  swap(a.colStats, b.colStats);
  swap(a.needMerge, b.needMerge);
  swap(a.__isset, b.__isset);
}

SetPartitionsStatsRequest::SetPartitionsStatsRequest(const SetPartitionsStatsRequest& other327) {
  colStats = other327.colStats;
  needMerge = other327.needMerge;
  __isset = other327.__isset;
}
SetPartitionsStatsRequest& SetPartitionsStatsRequest::operator=(const SetPartitionsStatsRequest& other328) {
  colStats = other328.colStats;
  needMerge = other328.needMerge;
  __isset = other328.__isset;
  return *this;
}
void SetPartitionsStatsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SetPartitionsStatsRequest(";
  out << "colStats=" << to_string(colStats);
  out << ", " << "needMerge="; (__isset.needMerge ? (out << to_string(needMerge)) : (out << "<null>"));
  out << ")";
}


Schema::~Schema() noexcept {
}


void Schema::__set_fieldSchemas(const std::vector<FieldSchema> & val) {
  this->fieldSchemas = val;
}

void Schema::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
}
std::ostream& operator<<(std::ostream& out, const Schema& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Schema::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fieldSchemas.clear();
            uint32_t _size329;
            ::apache::thrift::protocol::TType _etype332;
            xfer += iprot->readListBegin(_etype332, _size329);
            this->fieldSchemas.resize(_size329);
            uint32_t _i333;
            for (_i333 = 0; _i333 < _size329; ++_i333)
            {
              xfer += this->fieldSchemas[_i333].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fieldSchemas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size334;
            ::apache::thrift::protocol::TType _ktype335;
            ::apache::thrift::protocol::TType _vtype336;
            xfer += iprot->readMapBegin(_ktype335, _vtype336, _size334);
            uint32_t _i338;
            for (_i338 = 0; _i338 < _size334; ++_i338)
            {
              std::string _key339;
              xfer += iprot->readString(_key339);
              std::string& _val340 = this->properties[_key339];
              xfer += iprot->readString(_val340);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Schema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Schema");

  xfer += oprot->writeFieldBegin("fieldSchemas", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fieldSchemas.size()));
    std::vector<FieldSchema> ::const_iterator _iter341;
    for (_iter341 = this->fieldSchemas.begin(); _iter341 != this->fieldSchemas.end(); ++_iter341)
    {
      xfer += (*_iter341).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
    std::map<std::string, std::string> ::const_iterator _iter342;
    for (_iter342 = this->properties.begin(); _iter342 != this->properties.end(); ++_iter342)
    {
      xfer += oprot->writeString(_iter342->first);
      xfer += oprot->writeString(_iter342->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Schema &a, Schema &b) {
  using ::std::swap;
  swap(a.fieldSchemas, b.fieldSchemas);
  swap(a.properties, b.properties);
  swap(a.__isset, b.__isset);
}

Schema::Schema(const Schema& other343) {
  fieldSchemas = other343.fieldSchemas;
  properties = other343.properties;
  __isset = other343.__isset;
}
Schema& Schema::operator=(const Schema& other344) {
  fieldSchemas = other344.fieldSchemas;
  properties = other344.properties;
  __isset = other344.__isset;
  return *this;
}
void Schema::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Schema(";
  out << "fieldSchemas=" << to_string(fieldSchemas);
  out << ", " << "properties=" << to_string(properties);
  out << ")";
}


EnvironmentContext::~EnvironmentContext() noexcept {
}


void EnvironmentContext::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
}
std::ostream& operator<<(std::ostream& out, const EnvironmentContext& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t EnvironmentContext::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size345;
            ::apache::thrift::protocol::TType _ktype346;
            ::apache::thrift::protocol::TType _vtype347;
            xfer += iprot->readMapBegin(_ktype346, _vtype347, _size345);
            uint32_t _i349;
            for (_i349 = 0; _i349 < _size345; ++_i349)
            {
              std::string _key350;
              xfer += iprot->readString(_key350);
              std::string& _val351 = this->properties[_key350];
              xfer += iprot->readString(_val351);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EnvironmentContext::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EnvironmentContext");

  xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
    std::map<std::string, std::string> ::const_iterator _iter352;
    for (_iter352 = this->properties.begin(); _iter352 != this->properties.end(); ++_iter352)
    {
      xfer += oprot->writeString(_iter352->first);
      xfer += oprot->writeString(_iter352->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EnvironmentContext &a, EnvironmentContext &b) {
  using ::std::swap;
  swap(a.properties, b.properties);
  swap(a.__isset, b.__isset);
}

EnvironmentContext::EnvironmentContext(const EnvironmentContext& other353) {
  properties = other353.properties;
  __isset = other353.__isset;
}
EnvironmentContext& EnvironmentContext::operator=(const EnvironmentContext& other354) {
  properties = other354.properties;
  __isset = other354.__isset;
  return *this;
}
void EnvironmentContext::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EnvironmentContext(";
  out << "properties=" << to_string(properties);
  out << ")";
}


PrimaryKeysRequest::~PrimaryKeysRequest() noexcept {
}


void PrimaryKeysRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void PrimaryKeysRequest::__set_tbl_name(const std::string& val) {
  this->tbl_name = val;
}
std::ostream& operator<<(std::ostream& out, const PrimaryKeysRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PrimaryKeysRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db_name = false;
  bool isset_tbl_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tbl_name);
          isset_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tbl_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PrimaryKeysRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PrimaryKeysRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tbl_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tbl_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PrimaryKeysRequest &a, PrimaryKeysRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.tbl_name, b.tbl_name);
}

PrimaryKeysRequest::PrimaryKeysRequest(const PrimaryKeysRequest& other355) {
  db_name = other355.db_name;
  tbl_name = other355.tbl_name;
}
PrimaryKeysRequest& PrimaryKeysRequest::operator=(const PrimaryKeysRequest& other356) {
  db_name = other356.db_name;
  tbl_name = other356.tbl_name;
  return *this;
}
void PrimaryKeysRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PrimaryKeysRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "tbl_name=" << to_string(tbl_name);
  out << ")";
}


PrimaryKeysResponse::~PrimaryKeysResponse() noexcept {
}


void PrimaryKeysResponse::__set_primaryKeys(const std::vector<SQLPrimaryKey> & val) {
  this->primaryKeys = val;
}
std::ostream& operator<<(std::ostream& out, const PrimaryKeysResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PrimaryKeysResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_primaryKeys = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->primaryKeys.clear();
            uint32_t _size357;
            ::apache::thrift::protocol::TType _etype360;
            xfer += iprot->readListBegin(_etype360, _size357);
            this->primaryKeys.resize(_size357);
            uint32_t _i361;
            for (_i361 = 0; _i361 < _size357; ++_i361)
            {
              xfer += this->primaryKeys[_i361].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_primaryKeys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_primaryKeys)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PrimaryKeysResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PrimaryKeysResponse");

  xfer += oprot->writeFieldBegin("primaryKeys", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->primaryKeys.size()));
    std::vector<SQLPrimaryKey> ::const_iterator _iter362;
    for (_iter362 = this->primaryKeys.begin(); _iter362 != this->primaryKeys.end(); ++_iter362)
    {
      xfer += (*_iter362).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PrimaryKeysResponse &a, PrimaryKeysResponse &b) {
  using ::std::swap;
  swap(a.primaryKeys, b.primaryKeys);
}

PrimaryKeysResponse::PrimaryKeysResponse(const PrimaryKeysResponse& other363) {
  primaryKeys = other363.primaryKeys;
}
PrimaryKeysResponse& PrimaryKeysResponse::operator=(const PrimaryKeysResponse& other364) {
  primaryKeys = other364.primaryKeys;
  return *this;
}
void PrimaryKeysResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PrimaryKeysResponse(";
  out << "primaryKeys=" << to_string(primaryKeys);
  out << ")";
}


ForeignKeysRequest::~ForeignKeysRequest() noexcept {
}


void ForeignKeysRequest::__set_parent_db_name(const std::string& val) {
  this->parent_db_name = val;
}

void ForeignKeysRequest::__set_parent_tbl_name(const std::string& val) {
  this->parent_tbl_name = val;
}

void ForeignKeysRequest::__set_foreign_db_name(const std::string& val) {
  this->foreign_db_name = val;
}

void ForeignKeysRequest::__set_foreign_tbl_name(const std::string& val) {
  this->foreign_tbl_name = val;
}
std::ostream& operator<<(std::ostream& out, const ForeignKeysRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ForeignKeysRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parent_db_name);
          this->__isset.parent_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parent_tbl_name);
          this->__isset.parent_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->foreign_db_name);
          this->__isset.foreign_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->foreign_tbl_name);
          this->__isset.foreign_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ForeignKeysRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ForeignKeysRequest");

  xfer += oprot->writeFieldBegin("parent_db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->parent_db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parent_tbl_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->parent_tbl_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("foreign_db_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->foreign_db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("foreign_tbl_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->foreign_tbl_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ForeignKeysRequest &a, ForeignKeysRequest &b) {
  using ::std::swap;
  swap(a.parent_db_name, b.parent_db_name);
  swap(a.parent_tbl_name, b.parent_tbl_name);
  swap(a.foreign_db_name, b.foreign_db_name);
  swap(a.foreign_tbl_name, b.foreign_tbl_name);
  swap(a.__isset, b.__isset);
}

ForeignKeysRequest::ForeignKeysRequest(const ForeignKeysRequest& other365) {
  parent_db_name = other365.parent_db_name;
  parent_tbl_name = other365.parent_tbl_name;
  foreign_db_name = other365.foreign_db_name;
  foreign_tbl_name = other365.foreign_tbl_name;
  __isset = other365.__isset;
}
ForeignKeysRequest& ForeignKeysRequest::operator=(const ForeignKeysRequest& other366) {
  parent_db_name = other366.parent_db_name;
  parent_tbl_name = other366.parent_tbl_name;
  foreign_db_name = other366.foreign_db_name;
  foreign_tbl_name = other366.foreign_tbl_name;
  __isset = other366.__isset;
  return *this;
}
void ForeignKeysRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ForeignKeysRequest(";
  out << "parent_db_name=" << to_string(parent_db_name);
  out << ", " << "parent_tbl_name=" << to_string(parent_tbl_name);
  out << ", " << "foreign_db_name=" << to_string(foreign_db_name);
  out << ", " << "foreign_tbl_name=" << to_string(foreign_tbl_name);
  out << ")";
}


ForeignKeysResponse::~ForeignKeysResponse() noexcept {
}


void ForeignKeysResponse::__set_foreignKeys(const std::vector<SQLForeignKey> & val) {
  this->foreignKeys = val;
}
std::ostream& operator<<(std::ostream& out, const ForeignKeysResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ForeignKeysResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_foreignKeys = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->foreignKeys.clear();
            uint32_t _size367;
            ::apache::thrift::protocol::TType _etype370;
            xfer += iprot->readListBegin(_etype370, _size367);
            this->foreignKeys.resize(_size367);
            uint32_t _i371;
            for (_i371 = 0; _i371 < _size367; ++_i371)
            {
              xfer += this->foreignKeys[_i371].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_foreignKeys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_foreignKeys)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ForeignKeysResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ForeignKeysResponse");

  xfer += oprot->writeFieldBegin("foreignKeys", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->foreignKeys.size()));
    std::vector<SQLForeignKey> ::const_iterator _iter372;
    for (_iter372 = this->foreignKeys.begin(); _iter372 != this->foreignKeys.end(); ++_iter372)
    {
      xfer += (*_iter372).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ForeignKeysResponse &a, ForeignKeysResponse &b) {
  using ::std::swap;
  swap(a.foreignKeys, b.foreignKeys);
}

ForeignKeysResponse::ForeignKeysResponse(const ForeignKeysResponse& other373) {
  foreignKeys = other373.foreignKeys;
}
ForeignKeysResponse& ForeignKeysResponse::operator=(const ForeignKeysResponse& other374) {
  foreignKeys = other374.foreignKeys;
  return *this;
}
void ForeignKeysResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ForeignKeysResponse(";
  out << "foreignKeys=" << to_string(foreignKeys);
  out << ")";
}


UniqueConstraintsRequest::~UniqueConstraintsRequest() noexcept {
}


void UniqueConstraintsRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void UniqueConstraintsRequest::__set_tbl_name(const std::string& val) {
  this->tbl_name = val;
}
std::ostream& operator<<(std::ostream& out, const UniqueConstraintsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UniqueConstraintsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db_name = false;
  bool isset_tbl_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tbl_name);
          isset_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tbl_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UniqueConstraintsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UniqueConstraintsRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tbl_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tbl_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UniqueConstraintsRequest &a, UniqueConstraintsRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.tbl_name, b.tbl_name);
}

UniqueConstraintsRequest::UniqueConstraintsRequest(const UniqueConstraintsRequest& other375) {
  db_name = other375.db_name;
  tbl_name = other375.tbl_name;
}
UniqueConstraintsRequest& UniqueConstraintsRequest::operator=(const UniqueConstraintsRequest& other376) {
  db_name = other376.db_name;
  tbl_name = other376.tbl_name;
  return *this;
}
void UniqueConstraintsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UniqueConstraintsRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "tbl_name=" << to_string(tbl_name);
  out << ")";
}


UniqueConstraintsResponse::~UniqueConstraintsResponse() noexcept {
}


void UniqueConstraintsResponse::__set_uniqueConstraints(const std::vector<SQLUniqueConstraint> & val) {
  this->uniqueConstraints = val;
}
std::ostream& operator<<(std::ostream& out, const UniqueConstraintsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UniqueConstraintsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_uniqueConstraints = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->uniqueConstraints.clear();
            uint32_t _size377;
            ::apache::thrift::protocol::TType _etype380;
            xfer += iprot->readListBegin(_etype380, _size377);
            this->uniqueConstraints.resize(_size377);
            uint32_t _i381;
            for (_i381 = 0; _i381 < _size377; ++_i381)
            {
              xfer += this->uniqueConstraints[_i381].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_uniqueConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_uniqueConstraints)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UniqueConstraintsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UniqueConstraintsResponse");

  xfer += oprot->writeFieldBegin("uniqueConstraints", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->uniqueConstraints.size()));
    std::vector<SQLUniqueConstraint> ::const_iterator _iter382;
    for (_iter382 = this->uniqueConstraints.begin(); _iter382 != this->uniqueConstraints.end(); ++_iter382)
    {
      xfer += (*_iter382).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UniqueConstraintsResponse &a, UniqueConstraintsResponse &b) {
  using ::std::swap;
  swap(a.uniqueConstraints, b.uniqueConstraints);
}

UniqueConstraintsResponse::UniqueConstraintsResponse(const UniqueConstraintsResponse& other383) {
  uniqueConstraints = other383.uniqueConstraints;
}
UniqueConstraintsResponse& UniqueConstraintsResponse::operator=(const UniqueConstraintsResponse& other384) {
  uniqueConstraints = other384.uniqueConstraints;
  return *this;
}
void UniqueConstraintsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UniqueConstraintsResponse(";
  out << "uniqueConstraints=" << to_string(uniqueConstraints);
  out << ")";
}


NotNullConstraintsRequest::~NotNullConstraintsRequest() noexcept {
}


void NotNullConstraintsRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void NotNullConstraintsRequest::__set_tbl_name(const std::string& val) {
  this->tbl_name = val;
}
std::ostream& operator<<(std::ostream& out, const NotNullConstraintsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotNullConstraintsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db_name = false;
  bool isset_tbl_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tbl_name);
          isset_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tbl_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotNullConstraintsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotNullConstraintsRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tbl_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tbl_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotNullConstraintsRequest &a, NotNullConstraintsRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.tbl_name, b.tbl_name);
}

NotNullConstraintsRequest::NotNullConstraintsRequest(const NotNullConstraintsRequest& other385) {
  db_name = other385.db_name;
  tbl_name = other385.tbl_name;
}
NotNullConstraintsRequest& NotNullConstraintsRequest::operator=(const NotNullConstraintsRequest& other386) {
  db_name = other386.db_name;
  tbl_name = other386.tbl_name;
  return *this;
}
void NotNullConstraintsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotNullConstraintsRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "tbl_name=" << to_string(tbl_name);
  out << ")";
}


NotNullConstraintsResponse::~NotNullConstraintsResponse() noexcept {
}


void NotNullConstraintsResponse::__set_notNullConstraints(const std::vector<SQLNotNullConstraint> & val) {
  this->notNullConstraints = val;
}
std::ostream& operator<<(std::ostream& out, const NotNullConstraintsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotNullConstraintsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_notNullConstraints = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->notNullConstraints.clear();
            uint32_t _size387;
            ::apache::thrift::protocol::TType _etype390;
            xfer += iprot->readListBegin(_etype390, _size387);
            this->notNullConstraints.resize(_size387);
            uint32_t _i391;
            for (_i391 = 0; _i391 < _size387; ++_i391)
            {
              xfer += this->notNullConstraints[_i391].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_notNullConstraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_notNullConstraints)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotNullConstraintsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotNullConstraintsResponse");

  xfer += oprot->writeFieldBegin("notNullConstraints", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->notNullConstraints.size()));
    std::vector<SQLNotNullConstraint> ::const_iterator _iter392;
    for (_iter392 = this->notNullConstraints.begin(); _iter392 != this->notNullConstraints.end(); ++_iter392)
    {
      xfer += (*_iter392).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotNullConstraintsResponse &a, NotNullConstraintsResponse &b) {
  using ::std::swap;
  swap(a.notNullConstraints, b.notNullConstraints);
}

NotNullConstraintsResponse::NotNullConstraintsResponse(const NotNullConstraintsResponse& other393) {
  notNullConstraints = other393.notNullConstraints;
}
NotNullConstraintsResponse& NotNullConstraintsResponse::operator=(const NotNullConstraintsResponse& other394) {
  notNullConstraints = other394.notNullConstraints;
  return *this;
}
void NotNullConstraintsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotNullConstraintsResponse(";
  out << "notNullConstraints=" << to_string(notNullConstraints);
  out << ")";
}


DropConstraintRequest::~DropConstraintRequest() noexcept {
}


void DropConstraintRequest::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void DropConstraintRequest::__set_tablename(const std::string& val) {
  this->tablename = val;
}

void DropConstraintRequest::__set_constraintname(const std::string& val) {
  this->constraintname = val;
}
std::ostream& operator<<(std::ostream& out, const DropConstraintRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropConstraintRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbname = false;
  bool isset_tablename = false;
  bool isset_constraintname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          isset_tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->constraintname);
          isset_constraintname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablename)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_constraintname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DropConstraintRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropConstraintRequest");

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("constraintname", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->constraintname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropConstraintRequest &a, DropConstraintRequest &b) {
  using ::std::swap;
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.constraintname, b.constraintname);
}

DropConstraintRequest::DropConstraintRequest(const DropConstraintRequest& other395) {
  dbname = other395.dbname;
  tablename = other395.tablename;
  constraintname = other395.constraintname;
}
DropConstraintRequest& DropConstraintRequest::operator=(const DropConstraintRequest& other396) {
  dbname = other396.dbname;
  tablename = other396.tablename;
  constraintname = other396.constraintname;
  return *this;
}
void DropConstraintRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropConstraintRequest(";
  out << "dbname=" << to_string(dbname);
  out << ", " << "tablename=" << to_string(tablename);
  out << ", " << "constraintname=" << to_string(constraintname);
  out << ")";
}


AddPrimaryKeyRequest::~AddPrimaryKeyRequest() noexcept {
}


void AddPrimaryKeyRequest::__set_primaryKeyCols(const std::vector<SQLPrimaryKey> & val) {
  this->primaryKeyCols = val;
}
std::ostream& operator<<(std::ostream& out, const AddPrimaryKeyRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddPrimaryKeyRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_primaryKeyCols = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->primaryKeyCols.clear();
            uint32_t _size397;
            ::apache::thrift::protocol::TType _etype400;
            xfer += iprot->readListBegin(_etype400, _size397);
            this->primaryKeyCols.resize(_size397);
            uint32_t _i401;
            for (_i401 = 0; _i401 < _size397; ++_i401)
            {
              xfer += this->primaryKeyCols[_i401].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_primaryKeyCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_primaryKeyCols)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddPrimaryKeyRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddPrimaryKeyRequest");

  xfer += oprot->writeFieldBegin("primaryKeyCols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->primaryKeyCols.size()));
    std::vector<SQLPrimaryKey> ::const_iterator _iter402;
    for (_iter402 = this->primaryKeyCols.begin(); _iter402 != this->primaryKeyCols.end(); ++_iter402)
    {
      xfer += (*_iter402).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddPrimaryKeyRequest &a, AddPrimaryKeyRequest &b) {
  using ::std::swap;
  swap(a.primaryKeyCols, b.primaryKeyCols);
}

AddPrimaryKeyRequest::AddPrimaryKeyRequest(const AddPrimaryKeyRequest& other403) {
  primaryKeyCols = other403.primaryKeyCols;
}
AddPrimaryKeyRequest& AddPrimaryKeyRequest::operator=(const AddPrimaryKeyRequest& other404) {
  primaryKeyCols = other404.primaryKeyCols;
  return *this;
}
void AddPrimaryKeyRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddPrimaryKeyRequest(";
  out << "primaryKeyCols=" << to_string(primaryKeyCols);
  out << ")";
}


AddForeignKeyRequest::~AddForeignKeyRequest() noexcept {
}


void AddForeignKeyRequest::__set_foreignKeyCols(const std::vector<SQLForeignKey> & val) {
  this->foreignKeyCols = val;
}
std::ostream& operator<<(std::ostream& out, const AddForeignKeyRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddForeignKeyRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_foreignKeyCols = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->foreignKeyCols.clear();
            uint32_t _size405;
            ::apache::thrift::protocol::TType _etype408;
            xfer += iprot->readListBegin(_etype408, _size405);
            this->foreignKeyCols.resize(_size405);
            uint32_t _i409;
            for (_i409 = 0; _i409 < _size405; ++_i409)
            {
              xfer += this->foreignKeyCols[_i409].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_foreignKeyCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_foreignKeyCols)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddForeignKeyRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddForeignKeyRequest");

  xfer += oprot->writeFieldBegin("foreignKeyCols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->foreignKeyCols.size()));
    std::vector<SQLForeignKey> ::const_iterator _iter410;
    for (_iter410 = this->foreignKeyCols.begin(); _iter410 != this->foreignKeyCols.end(); ++_iter410)
    {
      xfer += (*_iter410).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddForeignKeyRequest &a, AddForeignKeyRequest &b) {
  using ::std::swap;
  swap(a.foreignKeyCols, b.foreignKeyCols);
}

AddForeignKeyRequest::AddForeignKeyRequest(const AddForeignKeyRequest& other411) {
  foreignKeyCols = other411.foreignKeyCols;
}
AddForeignKeyRequest& AddForeignKeyRequest::operator=(const AddForeignKeyRequest& other412) {
  foreignKeyCols = other412.foreignKeyCols;
  return *this;
}
void AddForeignKeyRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddForeignKeyRequest(";
  out << "foreignKeyCols=" << to_string(foreignKeyCols);
  out << ")";
}


AddUniqueConstraintRequest::~AddUniqueConstraintRequest() noexcept {
}


void AddUniqueConstraintRequest::__set_uniqueConstraintCols(const std::vector<SQLUniqueConstraint> & val) {
  this->uniqueConstraintCols = val;
}
std::ostream& operator<<(std::ostream& out, const AddUniqueConstraintRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddUniqueConstraintRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_uniqueConstraintCols = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->uniqueConstraintCols.clear();
            uint32_t _size413;
            ::apache::thrift::protocol::TType _etype416;
            xfer += iprot->readListBegin(_etype416, _size413);
            this->uniqueConstraintCols.resize(_size413);
            uint32_t _i417;
            for (_i417 = 0; _i417 < _size413; ++_i417)
            {
              xfer += this->uniqueConstraintCols[_i417].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_uniqueConstraintCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_uniqueConstraintCols)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddUniqueConstraintRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddUniqueConstraintRequest");

  xfer += oprot->writeFieldBegin("uniqueConstraintCols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->uniqueConstraintCols.size()));
    std::vector<SQLUniqueConstraint> ::const_iterator _iter418;
    for (_iter418 = this->uniqueConstraintCols.begin(); _iter418 != this->uniqueConstraintCols.end(); ++_iter418)
    {
      xfer += (*_iter418).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddUniqueConstraintRequest &a, AddUniqueConstraintRequest &b) {
  using ::std::swap;
  swap(a.uniqueConstraintCols, b.uniqueConstraintCols);
}

AddUniqueConstraintRequest::AddUniqueConstraintRequest(const AddUniqueConstraintRequest& other419) {
  uniqueConstraintCols = other419.uniqueConstraintCols;
}
AddUniqueConstraintRequest& AddUniqueConstraintRequest::operator=(const AddUniqueConstraintRequest& other420) {
  uniqueConstraintCols = other420.uniqueConstraintCols;
  return *this;
}
void AddUniqueConstraintRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddUniqueConstraintRequest(";
  out << "uniqueConstraintCols=" << to_string(uniqueConstraintCols);
  out << ")";
}


AddNotNullConstraintRequest::~AddNotNullConstraintRequest() noexcept {
}


void AddNotNullConstraintRequest::__set_notNullConstraintCols(const std::vector<SQLNotNullConstraint> & val) {
  this->notNullConstraintCols = val;
}
std::ostream& operator<<(std::ostream& out, const AddNotNullConstraintRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddNotNullConstraintRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_notNullConstraintCols = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->notNullConstraintCols.clear();
            uint32_t _size421;
            ::apache::thrift::protocol::TType _etype424;
            xfer += iprot->readListBegin(_etype424, _size421);
            this->notNullConstraintCols.resize(_size421);
            uint32_t _i425;
            for (_i425 = 0; _i425 < _size421; ++_i425)
            {
              xfer += this->notNullConstraintCols[_i425].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_notNullConstraintCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_notNullConstraintCols)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddNotNullConstraintRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddNotNullConstraintRequest");

  xfer += oprot->writeFieldBegin("notNullConstraintCols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->notNullConstraintCols.size()));
    std::vector<SQLNotNullConstraint> ::const_iterator _iter426;
    for (_iter426 = this->notNullConstraintCols.begin(); _iter426 != this->notNullConstraintCols.end(); ++_iter426)
    {
      xfer += (*_iter426).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddNotNullConstraintRequest &a, AddNotNullConstraintRequest &b) {
  using ::std::swap;
  swap(a.notNullConstraintCols, b.notNullConstraintCols);
}

AddNotNullConstraintRequest::AddNotNullConstraintRequest(const AddNotNullConstraintRequest& other427) {
  notNullConstraintCols = other427.notNullConstraintCols;
}
AddNotNullConstraintRequest& AddNotNullConstraintRequest::operator=(const AddNotNullConstraintRequest& other428) {
  notNullConstraintCols = other428.notNullConstraintCols;
  return *this;
}
void AddNotNullConstraintRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddNotNullConstraintRequest(";
  out << "notNullConstraintCols=" << to_string(notNullConstraintCols);
  out << ")";
}


PartitionsByExprResult::~PartitionsByExprResult() noexcept {
}


void PartitionsByExprResult::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
}

void PartitionsByExprResult::__set_hasUnknownPartitions(const bool val) {
  this->hasUnknownPartitions = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionsByExprResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionsByExprResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partitions = false;
  bool isset_hasUnknownPartitions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size429;
            ::apache::thrift::protocol::TType _etype432;
            xfer += iprot->readListBegin(_etype432, _size429);
            this->partitions.resize(_size429);
            uint32_t _i433;
            for (_i433 = 0; _i433 < _size429; ++_i433)
            {
              xfer += this->partitions[_i433].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasUnknownPartitions);
          isset_hasUnknownPartitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hasUnknownPartitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionsByExprResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionsByExprResult");

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<Partition> ::const_iterator _iter434;
    for (_iter434 = this->partitions.begin(); _iter434 != this->partitions.end(); ++_iter434)
    {
      xfer += (*_iter434).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hasUnknownPartitions", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->hasUnknownPartitions);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionsByExprResult &a, PartitionsByExprResult &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
  swap(a.hasUnknownPartitions, b.hasUnknownPartitions);
}

PartitionsByExprResult::PartitionsByExprResult(const PartitionsByExprResult& other435) {
  partitions = other435.partitions;
  hasUnknownPartitions = other435.hasUnknownPartitions;
}
PartitionsByExprResult& PartitionsByExprResult::operator=(const PartitionsByExprResult& other436) {
  partitions = other436.partitions;
  hasUnknownPartitions = other436.hasUnknownPartitions;
  return *this;
}
void PartitionsByExprResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionsByExprResult(";
  out << "partitions=" << to_string(partitions);
  out << ", " << "hasUnknownPartitions=" << to_string(hasUnknownPartitions);
  out << ")";
}


PartitionsByExprRequest::~PartitionsByExprRequest() noexcept {
}


void PartitionsByExprRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void PartitionsByExprRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void PartitionsByExprRequest::__set_expr(const std::string& val) {
  this->expr = val;
}

void PartitionsByExprRequest::__set_defaultPartitionName(const std::string& val) {
  this->defaultPartitionName = val;
__isset.defaultPartitionName = true;
}

void PartitionsByExprRequest::__set_maxParts(const int16_t val) {
  this->maxParts = val;
__isset.maxParts = true;
}
std::ostream& operator<<(std::ostream& out, const PartitionsByExprRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionsByExprRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_expr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->expr);
          isset_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->defaultPartitionName);
          this->__isset.defaultPartitionName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->maxParts);
          this->__isset.maxParts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_expr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionsByExprRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionsByExprRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expr", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->expr);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.defaultPartitionName) {
    xfer += oprot->writeFieldBegin("defaultPartitionName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->defaultPartitionName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxParts) {
    xfer += oprot->writeFieldBegin("maxParts", ::apache::thrift::protocol::T_I16, 5);
    xfer += oprot->writeI16(this->maxParts);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionsByExprRequest &a, PartitionsByExprRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.expr, b.expr);
  swap(a.defaultPartitionName, b.defaultPartitionName);
  swap(a.maxParts, b.maxParts);
  swap(a.__isset, b.__isset);
}

PartitionsByExprRequest::PartitionsByExprRequest(const PartitionsByExprRequest& other437) {
  dbName = other437.dbName;
  tblName = other437.tblName;
  expr = other437.expr;
  defaultPartitionName = other437.defaultPartitionName;
  maxParts = other437.maxParts;
  __isset = other437.__isset;
}
PartitionsByExprRequest& PartitionsByExprRequest::operator=(const PartitionsByExprRequest& other438) {
  dbName = other438.dbName;
  tblName = other438.tblName;
  expr = other438.expr;
  defaultPartitionName = other438.defaultPartitionName;
  maxParts = other438.maxParts;
  __isset = other438.__isset;
  return *this;
}
void PartitionsByExprRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionsByExprRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "expr=" << to_string(expr);
  out << ", " << "defaultPartitionName="; (__isset.defaultPartitionName ? (out << to_string(defaultPartitionName)) : (out << "<null>"));
  out << ", " << "maxParts="; (__isset.maxParts ? (out << to_string(maxParts)) : (out << "<null>"));
  out << ")";
}


TableStatsResult::~TableStatsResult() noexcept {
}


void TableStatsResult::__set_tableStats(const std::vector<ColumnStatisticsObj> & val) {
  this->tableStats = val;
}
std::ostream& operator<<(std::ostream& out, const TableStatsResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TableStatsResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tableStats = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tableStats.clear();
            uint32_t _size439;
            ::apache::thrift::protocol::TType _etype442;
            xfer += iprot->readListBegin(_etype442, _size439);
            this->tableStats.resize(_size439);
            uint32_t _i443;
            for (_i443 = 0; _i443 < _size439; ++_i443)
            {
              xfer += this->tableStats[_i443].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_tableStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tableStats)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TableStatsResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TableStatsResult");

  xfer += oprot->writeFieldBegin("tableStats", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tableStats.size()));
    std::vector<ColumnStatisticsObj> ::const_iterator _iter444;
    for (_iter444 = this->tableStats.begin(); _iter444 != this->tableStats.end(); ++_iter444)
    {
      xfer += (*_iter444).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TableStatsResult &a, TableStatsResult &b) {
  using ::std::swap;
  swap(a.tableStats, b.tableStats);
}

TableStatsResult::TableStatsResult(const TableStatsResult& other445) {
  tableStats = other445.tableStats;
}
TableStatsResult& TableStatsResult::operator=(const TableStatsResult& other446) {
  tableStats = other446.tableStats;
  return *this;
}
void TableStatsResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TableStatsResult(";
  out << "tableStats=" << to_string(tableStats);
  out << ")";
}


PartitionsStatsResult::~PartitionsStatsResult() noexcept {
}


void PartitionsStatsResult::__set_partStats(const std::map<std::string, std::vector<ColumnStatisticsObj> > & val) {
  this->partStats = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionsStatsResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionsStatsResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partStats = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->partStats.clear();
            uint32_t _size447;
            ::apache::thrift::protocol::TType _ktype448;
            ::apache::thrift::protocol::TType _vtype449;
            xfer += iprot->readMapBegin(_ktype448, _vtype449, _size447);
            uint32_t _i451;
            for (_i451 = 0; _i451 < _size447; ++_i451)
            {
              std::string _key452;
              xfer += iprot->readString(_key452);
              std::vector<ColumnStatisticsObj> & _val453 = this->partStats[_key452];
              {
                _val453.clear();
                uint32_t _size454;
                ::apache::thrift::protocol::TType _etype457;
                xfer += iprot->readListBegin(_etype457, _size454);
                _val453.resize(_size454);
                uint32_t _i458;
                for (_i458 = 0; _i458 < _size454; ++_i458)
                {
                  xfer += _val453[_i458].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_partStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partStats)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionsStatsResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionsStatsResult");

  xfer += oprot->writeFieldBegin("partStats", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->partStats.size()));
    std::map<std::string, std::vector<ColumnStatisticsObj> > ::const_iterator _iter459;
    for (_iter459 = this->partStats.begin(); _iter459 != this->partStats.end(); ++_iter459)
    {
      xfer += oprot->writeString(_iter459->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter459->second.size()));
        std::vector<ColumnStatisticsObj> ::const_iterator _iter460;
        for (_iter460 = _iter459->second.begin(); _iter460 != _iter459->second.end(); ++_iter460)
        {
          xfer += (*_iter460).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionsStatsResult &a, PartitionsStatsResult &b) {
  using ::std::swap;
  swap(a.partStats, b.partStats);
}

PartitionsStatsResult::PartitionsStatsResult(const PartitionsStatsResult& other461) {
  partStats = other461.partStats;
}
PartitionsStatsResult& PartitionsStatsResult::operator=(const PartitionsStatsResult& other462) {
  partStats = other462.partStats;
  return *this;
}
void PartitionsStatsResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionsStatsResult(";
  out << "partStats=" << to_string(partStats);
  out << ")";
}


TableStatsRequest::~TableStatsRequest() noexcept {
}


void TableStatsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void TableStatsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void TableStatsRequest::__set_colNames(const std::vector<std::string> & val) {
  this->colNames = val;
}
std::ostream& operator<<(std::ostream& out, const TableStatsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TableStatsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_colNames = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colNames.clear();
            uint32_t _size463;
            ::apache::thrift::protocol::TType _etype466;
            xfer += iprot->readListBegin(_etype466, _size463);
            this->colNames.resize(_size463);
            uint32_t _i467;
            for (_i467 = 0; _i467 < _size463; ++_i467)
            {
              xfer += iprot->readString(this->colNames[_i467]);
            }
            xfer += iprot->readListEnd();
          }
          isset_colNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_colNames)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TableStatsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TableStatsRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colNames", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->colNames.size()));
    std::vector<std::string> ::const_iterator _iter468;
    for (_iter468 = this->colNames.begin(); _iter468 != this->colNames.end(); ++_iter468)
    {
      xfer += oprot->writeString((*_iter468));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TableStatsRequest &a, TableStatsRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.colNames, b.colNames);
}

TableStatsRequest::TableStatsRequest(const TableStatsRequest& other469) {
  dbName = other469.dbName;
  tblName = other469.tblName;
  colNames = other469.colNames;
}
TableStatsRequest& TableStatsRequest::operator=(const TableStatsRequest& other470) {
  dbName = other470.dbName;
  tblName = other470.tblName;
  colNames = other470.colNames;
  return *this;
}
void TableStatsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TableStatsRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "colNames=" << to_string(colNames);
  out << ")";
}


PartitionsStatsRequest::~PartitionsStatsRequest() noexcept {
}


void PartitionsStatsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void PartitionsStatsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void PartitionsStatsRequest::__set_colNames(const std::vector<std::string> & val) {
  this->colNames = val;
}

void PartitionsStatsRequest::__set_partNames(const std::vector<std::string> & val) {
  this->partNames = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionsStatsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionsStatsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_colNames = false;
  bool isset_partNames = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colNames.clear();
            uint32_t _size471;
            ::apache::thrift::protocol::TType _etype474;
            xfer += iprot->readListBegin(_etype474, _size471);
            this->colNames.resize(_size471);
            uint32_t _i475;
            for (_i475 = 0; _i475 < _size471; ++_i475)
            {
              xfer += iprot->readString(this->colNames[_i475]);
            }
            xfer += iprot->readListEnd();
          }
          isset_colNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partNames.clear();
            uint32_t _size476;
            ::apache::thrift::protocol::TType _etype479;
            xfer += iprot->readListBegin(_etype479, _size476);
            this->partNames.resize(_size476);
            uint32_t _i480;
            for (_i480 = 0; _i480 < _size476; ++_i480)
            {
              xfer += iprot->readString(this->partNames[_i480]);
            }
            xfer += iprot->readListEnd();
          }
          isset_partNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_colNames)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partNames)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionsStatsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionsStatsRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colNames", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->colNames.size()));
    std::vector<std::string> ::const_iterator _iter481;
    for (_iter481 = this->colNames.begin(); _iter481 != this->colNames.end(); ++_iter481)
    {
      xfer += oprot->writeString((*_iter481));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partNames", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partNames.size()));
    std::vector<std::string> ::const_iterator _iter482;
    for (_iter482 = this->partNames.begin(); _iter482 != this->partNames.end(); ++_iter482)
    {
      xfer += oprot->writeString((*_iter482));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionsStatsRequest &a, PartitionsStatsRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.colNames, b.colNames);
  swap(a.partNames, b.partNames);
}

PartitionsStatsRequest::PartitionsStatsRequest(const PartitionsStatsRequest& other483) {
  dbName = other483.dbName;
  tblName = other483.tblName;
  colNames = other483.colNames;
  partNames = other483.partNames;
}
PartitionsStatsRequest& PartitionsStatsRequest::operator=(const PartitionsStatsRequest& other484) {
  dbName = other484.dbName;
  tblName = other484.tblName;
  colNames = other484.colNames;
  partNames = other484.partNames;
  return *this;
}
void PartitionsStatsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionsStatsRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "colNames=" << to_string(colNames);
  out << ", " << "partNames=" << to_string(partNames);
  out << ")";
}


AddPartitionsResult::~AddPartitionsResult() noexcept {
}


void AddPartitionsResult::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
__isset.partitions = true;
}
std::ostream& operator<<(std::ostream& out, const AddPartitionsResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddPartitionsResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size485;
            ::apache::thrift::protocol::TType _etype488;
            xfer += iprot->readListBegin(_etype488, _size485);
            this->partitions.resize(_size485);
            uint32_t _i489;
            for (_i489 = 0; _i489 < _size485; ++_i489)
            {
              xfer += this->partitions[_i489].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AddPartitionsResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddPartitionsResult");

  if (this->__isset.partitions) {
    xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
      std::vector<Partition> ::const_iterator _iter490;
      for (_iter490 = this->partitions.begin(); _iter490 != this->partitions.end(); ++_iter490)
      {
        xfer += (*_iter490).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddPartitionsResult &a, AddPartitionsResult &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
  swap(a.__isset, b.__isset);
}

AddPartitionsResult::AddPartitionsResult(const AddPartitionsResult& other491) {
  partitions = other491.partitions;
  __isset = other491.__isset;
}
AddPartitionsResult& AddPartitionsResult::operator=(const AddPartitionsResult& other492) {
  partitions = other492.partitions;
  __isset = other492.__isset;
  return *this;
}
void AddPartitionsResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddPartitionsResult(";
  out << "partitions="; (__isset.partitions ? (out << to_string(partitions)) : (out << "<null>"));
  out << ")";
}


AddPartitionsRequest::~AddPartitionsRequest() noexcept {
}


void AddPartitionsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void AddPartitionsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void AddPartitionsRequest::__set_parts(const std::vector<Partition> & val) {
  this->parts = val;
}

void AddPartitionsRequest::__set_ifNotExists(const bool val) {
  this->ifNotExists = val;
}

void AddPartitionsRequest::__set_needResult(const bool val) {
  this->needResult = val;
__isset.needResult = true;
}
std::ostream& operator<<(std::ostream& out, const AddPartitionsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddPartitionsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_parts = false;
  bool isset_ifNotExists = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->parts.clear();
            uint32_t _size493;
            ::apache::thrift::protocol::TType _etype496;
            xfer += iprot->readListBegin(_etype496, _size493);
            this->parts.resize(_size493);
            uint32_t _i497;
            for (_i497 = 0; _i497 < _size493; ++_i497)
            {
              xfer += this->parts[_i497].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_parts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ifNotExists);
          isset_ifNotExists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->needResult);
          this->__isset.needResult = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_parts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ifNotExists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddPartitionsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddPartitionsRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parts", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->parts.size()));
    std::vector<Partition> ::const_iterator _iter498;
    for (_iter498 = this->parts.begin(); _iter498 != this->parts.end(); ++_iter498)
    {
      xfer += (*_iter498).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ifNotExists", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->ifNotExists);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.needResult) {
    xfer += oprot->writeFieldBegin("needResult", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->needResult);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddPartitionsRequest &a, AddPartitionsRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.parts, b.parts);
  swap(a.ifNotExists, b.ifNotExists);
  swap(a.needResult, b.needResult);
  swap(a.__isset, b.__isset);
}

AddPartitionsRequest::AddPartitionsRequest(const AddPartitionsRequest& other499) {
  dbName = other499.dbName;
  tblName = other499.tblName;
  parts = other499.parts;
  ifNotExists = other499.ifNotExists;
  needResult = other499.needResult;
  __isset = other499.__isset;
}
AddPartitionsRequest& AddPartitionsRequest::operator=(const AddPartitionsRequest& other500) {
  dbName = other500.dbName;
  tblName = other500.tblName;
  parts = other500.parts;
  ifNotExists = other500.ifNotExists;
  needResult = other500.needResult;
  __isset = other500.__isset;
  return *this;
}
void AddPartitionsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddPartitionsRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "parts=" << to_string(parts);
  out << ", " << "ifNotExists=" << to_string(ifNotExists);
  out << ", " << "needResult="; (__isset.needResult ? (out << to_string(needResult)) : (out << "<null>"));
  out << ")";
}


DropPartitionsResult::~DropPartitionsResult() noexcept {
}


void DropPartitionsResult::__set_partitions(const std::vector<Partition> & val) {
  this->partitions = val;
__isset.partitions = true;
}
std::ostream& operator<<(std::ostream& out, const DropPartitionsResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropPartitionsResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size501;
            ::apache::thrift::protocol::TType _etype504;
            xfer += iprot->readListBegin(_etype504, _size501);
            this->partitions.resize(_size501);
            uint32_t _i505;
            for (_i505 = 0; _i505 < _size501; ++_i505)
            {
              xfer += this->partitions[_i505].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DropPartitionsResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropPartitionsResult");

  if (this->__isset.partitions) {
    xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
      std::vector<Partition> ::const_iterator _iter506;
      for (_iter506 = this->partitions.begin(); _iter506 != this->partitions.end(); ++_iter506)
      {
        xfer += (*_iter506).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropPartitionsResult &a, DropPartitionsResult &b) {
  using ::std::swap;
  swap(a.partitions, b.partitions);
  swap(a.__isset, b.__isset);
}

DropPartitionsResult::DropPartitionsResult(const DropPartitionsResult& other507) {
  partitions = other507.partitions;
  __isset = other507.__isset;
}
DropPartitionsResult& DropPartitionsResult::operator=(const DropPartitionsResult& other508) {
  partitions = other508.partitions;
  __isset = other508.__isset;
  return *this;
}
void DropPartitionsResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropPartitionsResult(";
  out << "partitions="; (__isset.partitions ? (out << to_string(partitions)) : (out << "<null>"));
  out << ")";
}


DropPartitionsExpr::~DropPartitionsExpr() noexcept {
}


void DropPartitionsExpr::__set_expr(const std::string& val) {
  this->expr = val;
}

void DropPartitionsExpr::__set_partArchiveLevel(const int32_t val) {
  this->partArchiveLevel = val;
__isset.partArchiveLevel = true;
}
std::ostream& operator<<(std::ostream& out, const DropPartitionsExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropPartitionsExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_expr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->expr);
          isset_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partArchiveLevel);
          this->__isset.partArchiveLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_expr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DropPartitionsExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropPartitionsExpr");

  xfer += oprot->writeFieldBegin("expr", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->expr);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partArchiveLevel) {
    xfer += oprot->writeFieldBegin("partArchiveLevel", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->partArchiveLevel);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropPartitionsExpr &a, DropPartitionsExpr &b) {
  using ::std::swap;
  swap(a.expr, b.expr);
  swap(a.partArchiveLevel, b.partArchiveLevel);
  swap(a.__isset, b.__isset);
}

DropPartitionsExpr::DropPartitionsExpr(const DropPartitionsExpr& other509) {
  expr = other509.expr;
  partArchiveLevel = other509.partArchiveLevel;
  __isset = other509.__isset;
}
DropPartitionsExpr& DropPartitionsExpr::operator=(const DropPartitionsExpr& other510) {
  expr = other510.expr;
  partArchiveLevel = other510.partArchiveLevel;
  __isset = other510.__isset;
  return *this;
}
void DropPartitionsExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropPartitionsExpr(";
  out << "expr=" << to_string(expr);
  out << ", " << "partArchiveLevel="; (__isset.partArchiveLevel ? (out << to_string(partArchiveLevel)) : (out << "<null>"));
  out << ")";
}


RequestPartsSpec::~RequestPartsSpec() noexcept {
}


void RequestPartsSpec::__set_names(const std::vector<std::string> & val) {
  this->names = val;
__isset.names = true;
}

void RequestPartsSpec::__set_exprs(const std::vector<DropPartitionsExpr> & val) {
  this->exprs = val;
__isset.exprs = true;
}
std::ostream& operator<<(std::ostream& out, const RequestPartsSpec& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RequestPartsSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->names.clear();
            uint32_t _size511;
            ::apache::thrift::protocol::TType _etype514;
            xfer += iprot->readListBegin(_etype514, _size511);
            this->names.resize(_size511);
            uint32_t _i515;
            for (_i515 = 0; _i515 < _size511; ++_i515)
            {
              xfer += iprot->readString(this->names[_i515]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->exprs.clear();
            uint32_t _size516;
            ::apache::thrift::protocol::TType _etype519;
            xfer += iprot->readListBegin(_etype519, _size516);
            this->exprs.resize(_size516);
            uint32_t _i520;
            for (_i520 = 0; _i520 < _size516; ++_i520)
            {
              xfer += this->exprs[_i520].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RequestPartsSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RequestPartsSpec");

  if (this->__isset.names) {
    xfer += oprot->writeFieldBegin("names", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->names.size()));
      std::vector<std::string> ::const_iterator _iter521;
      for (_iter521 = this->names.begin(); _iter521 != this->names.end(); ++_iter521)
      {
        xfer += oprot->writeString((*_iter521));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exprs) {
    xfer += oprot->writeFieldBegin("exprs", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->exprs.size()));
      std::vector<DropPartitionsExpr> ::const_iterator _iter522;
      for (_iter522 = this->exprs.begin(); _iter522 != this->exprs.end(); ++_iter522)
      {
        xfer += (*_iter522).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RequestPartsSpec &a, RequestPartsSpec &b) {
  using ::std::swap;
  swap(a.names, b.names);
  swap(a.exprs, b.exprs);
  swap(a.__isset, b.__isset);
}

RequestPartsSpec::RequestPartsSpec(const RequestPartsSpec& other523) {
  names = other523.names;
  exprs = other523.exprs;
  __isset = other523.__isset;
}
RequestPartsSpec& RequestPartsSpec::operator=(const RequestPartsSpec& other524) {
  names = other524.names;
  exprs = other524.exprs;
  __isset = other524.__isset;
  return *this;
}
void RequestPartsSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RequestPartsSpec(";
  out << "names="; (__isset.names ? (out << to_string(names)) : (out << "<null>"));
  out << ", " << "exprs="; (__isset.exprs ? (out << to_string(exprs)) : (out << "<null>"));
  out << ")";
}


DropPartitionsRequest::~DropPartitionsRequest() noexcept {
}


void DropPartitionsRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void DropPartitionsRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void DropPartitionsRequest::__set_parts(const RequestPartsSpec& val) {
  this->parts = val;
}

void DropPartitionsRequest::__set_deleteData(const bool val) {
  this->deleteData = val;
__isset.deleteData = true;
}

void DropPartitionsRequest::__set_ifExists(const bool val) {
  this->ifExists = val;
__isset.ifExists = true;
}

void DropPartitionsRequest::__set_ignoreProtection(const bool val) {
  this->ignoreProtection = val;
__isset.ignoreProtection = true;
}

void DropPartitionsRequest::__set_environmentContext(const EnvironmentContext& val) {
  this->environmentContext = val;
__isset.environmentContext = true;
}

void DropPartitionsRequest::__set_needResult(const bool val) {
  this->needResult = val;
__isset.needResult = true;
}
std::ostream& operator<<(std::ostream& out, const DropPartitionsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropPartitionsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_parts = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->parts.read(iprot);
          isset_parts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->deleteData);
          this->__isset.deleteData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ifExists);
          this->__isset.ifExists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ignoreProtection);
          this->__isset.ignoreProtection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->environmentContext.read(iprot);
          this->__isset.environmentContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->needResult);
          this->__isset.needResult = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_parts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DropPartitionsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropPartitionsRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parts", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->parts.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.deleteData) {
    xfer += oprot->writeFieldBegin("deleteData", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->deleteData);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ifExists) {
    xfer += oprot->writeFieldBegin("ifExists", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->ifExists);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ignoreProtection) {
    xfer += oprot->writeFieldBegin("ignoreProtection", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->ignoreProtection);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.environmentContext) {
    xfer += oprot->writeFieldBegin("environmentContext", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->environmentContext.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.needResult) {
    xfer += oprot->writeFieldBegin("needResult", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->needResult);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropPartitionsRequest &a, DropPartitionsRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.parts, b.parts);
  swap(a.deleteData, b.deleteData);
  swap(a.ifExists, b.ifExists);
  swap(a.ignoreProtection, b.ignoreProtection);
  swap(a.environmentContext, b.environmentContext);
  swap(a.needResult, b.needResult);
  swap(a.__isset, b.__isset);
}

DropPartitionsRequest::DropPartitionsRequest(const DropPartitionsRequest& other525) {
  dbName = other525.dbName;
  tblName = other525.tblName;
  parts = other525.parts;
  deleteData = other525.deleteData;
  ifExists = other525.ifExists;
  ignoreProtection = other525.ignoreProtection;
  environmentContext = other525.environmentContext;
  needResult = other525.needResult;
  __isset = other525.__isset;
}
DropPartitionsRequest& DropPartitionsRequest::operator=(const DropPartitionsRequest& other526) {
  dbName = other526.dbName;
  tblName = other526.tblName;
  parts = other526.parts;
  deleteData = other526.deleteData;
  ifExists = other526.ifExists;
  ignoreProtection = other526.ignoreProtection;
  environmentContext = other526.environmentContext;
  needResult = other526.needResult;
  __isset = other526.__isset;
  return *this;
}
void DropPartitionsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropPartitionsRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "parts=" << to_string(parts);
  out << ", " << "deleteData="; (__isset.deleteData ? (out << to_string(deleteData)) : (out << "<null>"));
  out << ", " << "ifExists="; (__isset.ifExists ? (out << to_string(ifExists)) : (out << "<null>"));
  out << ", " << "ignoreProtection="; (__isset.ignoreProtection ? (out << to_string(ignoreProtection)) : (out << "<null>"));
  out << ", " << "environmentContext="; (__isset.environmentContext ? (out << to_string(environmentContext)) : (out << "<null>"));
  out << ", " << "needResult="; (__isset.needResult ? (out << to_string(needResult)) : (out << "<null>"));
  out << ")";
}


PartitionValuesRequest::~PartitionValuesRequest() noexcept {
}


void PartitionValuesRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void PartitionValuesRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void PartitionValuesRequest::__set_partitionKeys(const std::vector<FieldSchema> & val) {
  this->partitionKeys = val;
}

void PartitionValuesRequest::__set_applyDistinct(const bool val) {
  this->applyDistinct = val;
__isset.applyDistinct = true;
}

void PartitionValuesRequest::__set_filter(const std::string& val) {
  this->filter = val;
__isset.filter = true;
}

void PartitionValuesRequest::__set_partitionOrder(const std::vector<FieldSchema> & val) {
  this->partitionOrder = val;
__isset.partitionOrder = true;
}

void PartitionValuesRequest::__set_ascending(const bool val) {
  this->ascending = val;
__isset.ascending = true;
}

void PartitionValuesRequest::__set_maxParts(const int64_t val) {
  this->maxParts = val;
__isset.maxParts = true;
}
std::ostream& operator<<(std::ostream& out, const PartitionValuesRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionValuesRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;
  bool isset_partitionKeys = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionKeys.clear();
            uint32_t _size527;
            ::apache::thrift::protocol::TType _etype530;
            xfer += iprot->readListBegin(_etype530, _size527);
            this->partitionKeys.resize(_size527);
            uint32_t _i531;
            for (_i531 = 0; _i531 < _size527; ++_i531)
            {
              xfer += this->partitionKeys[_i531].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitionKeys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->applyDistinct);
          this->__isset.applyDistinct = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->filter);
          this->__isset.filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionOrder.clear();
            uint32_t _size532;
            ::apache::thrift::protocol::TType _etype535;
            xfer += iprot->readListBegin(_etype535, _size532);
            this->partitionOrder.resize(_size532);
            uint32_t _i536;
            for (_i536 = 0; _i536 < _size532; ++_i536)
            {
              xfer += this->partitionOrder[_i536].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitionOrder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ascending);
          this->__isset.ascending = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxParts);
          this->__isset.maxParts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partitionKeys)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionValuesRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionValuesRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partitionKeys", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitionKeys.size()));
    std::vector<FieldSchema> ::const_iterator _iter537;
    for (_iter537 = this->partitionKeys.begin(); _iter537 != this->partitionKeys.end(); ++_iter537)
    {
      xfer += (*_iter537).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.applyDistinct) {
    xfer += oprot->writeFieldBegin("applyDistinct", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->applyDistinct);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filter) {
    xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->filter);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitionOrder) {
    xfer += oprot->writeFieldBegin("partitionOrder", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitionOrder.size()));
      std::vector<FieldSchema> ::const_iterator _iter538;
      for (_iter538 = this->partitionOrder.begin(); _iter538 != this->partitionOrder.end(); ++_iter538)
      {
        xfer += (*_iter538).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ascending) {
    xfer += oprot->writeFieldBegin("ascending", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->ascending);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxParts) {
    xfer += oprot->writeFieldBegin("maxParts", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->maxParts);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionValuesRequest &a, PartitionValuesRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.partitionKeys, b.partitionKeys);
  swap(a.applyDistinct, b.applyDistinct);
  swap(a.filter, b.filter);
  swap(a.partitionOrder, b.partitionOrder);
  swap(a.ascending, b.ascending);
  swap(a.maxParts, b.maxParts);
  swap(a.__isset, b.__isset);
}

PartitionValuesRequest::PartitionValuesRequest(const PartitionValuesRequest& other539) {
  dbName = other539.dbName;
  tblName = other539.tblName;
  partitionKeys = other539.partitionKeys;
  applyDistinct = other539.applyDistinct;
  filter = other539.filter;
  partitionOrder = other539.partitionOrder;
  ascending = other539.ascending;
  maxParts = other539.maxParts;
  __isset = other539.__isset;
}
PartitionValuesRequest& PartitionValuesRequest::operator=(const PartitionValuesRequest& other540) {
  dbName = other540.dbName;
  tblName = other540.tblName;
  partitionKeys = other540.partitionKeys;
  applyDistinct = other540.applyDistinct;
  filter = other540.filter;
  partitionOrder = other540.partitionOrder;
  ascending = other540.ascending;
  maxParts = other540.maxParts;
  __isset = other540.__isset;
  return *this;
}
void PartitionValuesRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionValuesRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "partitionKeys=" << to_string(partitionKeys);
  out << ", " << "applyDistinct="; (__isset.applyDistinct ? (out << to_string(applyDistinct)) : (out << "<null>"));
  out << ", " << "filter="; (__isset.filter ? (out << to_string(filter)) : (out << "<null>"));
  out << ", " << "partitionOrder="; (__isset.partitionOrder ? (out << to_string(partitionOrder)) : (out << "<null>"));
  out << ", " << "ascending="; (__isset.ascending ? (out << to_string(ascending)) : (out << "<null>"));
  out << ", " << "maxParts="; (__isset.maxParts ? (out << to_string(maxParts)) : (out << "<null>"));
  out << ")";
}


PartitionValuesRow::~PartitionValuesRow() noexcept {
}


void PartitionValuesRow::__set_row(const std::vector<std::string> & val) {
  this->row = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionValuesRow& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionValuesRow::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row.clear();
            uint32_t _size541;
            ::apache::thrift::protocol::TType _etype544;
            xfer += iprot->readListBegin(_etype544, _size541);
            this->row.resize(_size541);
            uint32_t _i545;
            for (_i545 = 0; _i545 < _size541; ++_i545)
            {
              xfer += iprot->readString(this->row[_i545]);
            }
            xfer += iprot->readListEnd();
          }
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionValuesRow::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionValuesRow");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->row.size()));
    std::vector<std::string> ::const_iterator _iter546;
    for (_iter546 = this->row.begin(); _iter546 != this->row.end(); ++_iter546)
    {
      xfer += oprot->writeString((*_iter546));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionValuesRow &a, PartitionValuesRow &b) {
  using ::std::swap;
  swap(a.row, b.row);
}

PartitionValuesRow::PartitionValuesRow(const PartitionValuesRow& other547) {
  row = other547.row;
}
PartitionValuesRow& PartitionValuesRow::operator=(const PartitionValuesRow& other548) {
  row = other548.row;
  return *this;
}
void PartitionValuesRow::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionValuesRow(";
  out << "row=" << to_string(row);
  out << ")";
}


PartitionValuesResponse::~PartitionValuesResponse() noexcept {
}


void PartitionValuesResponse::__set_partitionValues(const std::vector<PartitionValuesRow> & val) {
  this->partitionValues = val;
}
std::ostream& operator<<(std::ostream& out, const PartitionValuesResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PartitionValuesResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partitionValues = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionValues.clear();
            uint32_t _size549;
            ::apache::thrift::protocol::TType _etype552;
            xfer += iprot->readListBegin(_etype552, _size549);
            this->partitionValues.resize(_size549);
            uint32_t _i553;
            for (_i553 = 0; _i553 < _size549; ++_i553)
            {
              xfer += this->partitionValues[_i553].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitionValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partitionValues)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PartitionValuesResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PartitionValuesResponse");

  xfer += oprot->writeFieldBegin("partitionValues", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitionValues.size()));
    std::vector<PartitionValuesRow> ::const_iterator _iter554;
    for (_iter554 = this->partitionValues.begin(); _iter554 != this->partitionValues.end(); ++_iter554)
    {
      xfer += (*_iter554).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PartitionValuesResponse &a, PartitionValuesResponse &b) {
  using ::std::swap;
  swap(a.partitionValues, b.partitionValues);
}

PartitionValuesResponse::PartitionValuesResponse(const PartitionValuesResponse& other555) {
  partitionValues = other555.partitionValues;
}
PartitionValuesResponse& PartitionValuesResponse::operator=(const PartitionValuesResponse& other556) {
  partitionValues = other556.partitionValues;
  return *this;
}
void PartitionValuesResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PartitionValuesResponse(";
  out << "partitionValues=" << to_string(partitionValues);
  out << ")";
}


ResourceUri::~ResourceUri() noexcept {
}


void ResourceUri::__set_resourceType(const ResourceType::type val) {
  this->resourceType = val;
}

void ResourceUri::__set_uri(const std::string& val) {
  this->uri = val;
}
std::ostream& operator<<(std::ostream& out, const ResourceUri& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ResourceUri::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast557;
          xfer += iprot->readI32(ecast557);
          this->resourceType = (ResourceType::type)ecast557;
          this->__isset.resourceType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uri);
          this->__isset.uri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ResourceUri::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResourceUri");

  xfer += oprot->writeFieldBegin("resourceType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->resourceType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uri", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->uri);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResourceUri &a, ResourceUri &b) {
  using ::std::swap;
  swap(a.resourceType, b.resourceType);
  swap(a.uri, b.uri);
  swap(a.__isset, b.__isset);
}

ResourceUri::ResourceUri(const ResourceUri& other558) {
  resourceType = other558.resourceType;
  uri = other558.uri;
  __isset = other558.__isset;
}
ResourceUri& ResourceUri::operator=(const ResourceUri& other559) {
  resourceType = other559.resourceType;
  uri = other559.uri;
  __isset = other559.__isset;
  return *this;
}
void ResourceUri::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResourceUri(";
  out << "resourceType=" << to_string(resourceType);
  out << ", " << "uri=" << to_string(uri);
  out << ")";
}


Function::~Function() noexcept {
}


void Function::__set_functionName(const std::string& val) {
  this->functionName = val;
}

void Function::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void Function::__set_className(const std::string& val) {
  this->className = val;
}

void Function::__set_ownerName(const std::string& val) {
  this->ownerName = val;
}

void Function::__set_ownerType(const PrincipalType::type val) {
  this->ownerType = val;
}

void Function::__set_createTime(const int32_t val) {
  this->createTime = val;
}

void Function::__set_functionType(const FunctionType::type val) {
  this->functionType = val;
}

void Function::__set_resourceUris(const std::vector<ResourceUri> & val) {
  this->resourceUris = val;
}
std::ostream& operator<<(std::ostream& out, const Function& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Function::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->functionName);
          this->__isset.functionName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->className);
          this->__isset.className = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast560;
          xfer += iprot->readI32(ecast560);
          this->ownerType = (PrincipalType::type)ecast560;
          this->__isset.ownerType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast561;
          xfer += iprot->readI32(ecast561);
          this->functionType = (FunctionType::type)ecast561;
          this->__isset.functionType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->resourceUris.clear();
            uint32_t _size562;
            ::apache::thrift::protocol::TType _etype565;
            xfer += iprot->readListBegin(_etype565, _size562);
            this->resourceUris.resize(_size562);
            uint32_t _i566;
            for (_i566 = 0; _i566 < _size562; ++_i566)
            {
              xfer += this->resourceUris[_i566].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.resourceUris = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Function::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Function");

  xfer += oprot->writeFieldBegin("functionName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->functionName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("className", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->className);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->ownerName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ownerType", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->ownerType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("functionType", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->functionType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resourceUris", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->resourceUris.size()));
    std::vector<ResourceUri> ::const_iterator _iter567;
    for (_iter567 = this->resourceUris.begin(); _iter567 != this->resourceUris.end(); ++_iter567)
    {
      xfer += (*_iter567).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Function &a, Function &b) {
  using ::std::swap;
  swap(a.functionName, b.functionName);
  swap(a.dbName, b.dbName);
  swap(a.className, b.className);
  swap(a.ownerName, b.ownerName);
  swap(a.ownerType, b.ownerType);
  swap(a.createTime, b.createTime);
  swap(a.functionType, b.functionType);
  swap(a.resourceUris, b.resourceUris);
  swap(a.__isset, b.__isset);
}

Function::Function(const Function& other568) {
  functionName = other568.functionName;
  dbName = other568.dbName;
  className = other568.className;
  ownerName = other568.ownerName;
  ownerType = other568.ownerType;
  createTime = other568.createTime;
  functionType = other568.functionType;
  resourceUris = other568.resourceUris;
  __isset = other568.__isset;
}
Function& Function::operator=(const Function& other569) {
  functionName = other569.functionName;
  dbName = other569.dbName;
  className = other569.className;
  ownerName = other569.ownerName;
  ownerType = other569.ownerType;
  createTime = other569.createTime;
  functionType = other569.functionType;
  resourceUris = other569.resourceUris;
  __isset = other569.__isset;
  return *this;
}
void Function::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Function(";
  out << "functionName=" << to_string(functionName);
  out << ", " << "dbName=" << to_string(dbName);
  out << ", " << "className=" << to_string(className);
  out << ", " << "ownerName=" << to_string(ownerName);
  out << ", " << "ownerType=" << to_string(ownerType);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "functionType=" << to_string(functionType);
  out << ", " << "resourceUris=" << to_string(resourceUris);
  out << ")";
}


TxnInfo::~TxnInfo() noexcept {
}


void TxnInfo::__set_id(const int64_t val) {
  this->id = val;
}

void TxnInfo::__set_state(const TxnState::type val) {
  this->state = val;
}

void TxnInfo::__set_user(const std::string& val) {
  this->user = val;
}

void TxnInfo::__set_hostname(const std::string& val) {
  this->hostname = val;
}

void TxnInfo::__set_agentInfo(const std::string& val) {
  this->agentInfo = val;
__isset.agentInfo = true;
}

void TxnInfo::__set_heartbeatCount(const int32_t val) {
  this->heartbeatCount = val;
__isset.heartbeatCount = true;
}

void TxnInfo::__set_metaInfo(const std::string& val) {
  this->metaInfo = val;
__isset.metaInfo = true;
}

void TxnInfo::__set_startedTime(const int64_t val) {
  this->startedTime = val;
__isset.startedTime = true;
}

void TxnInfo::__set_lastHeartbeatTime(const int64_t val) {
  this->lastHeartbeatTime = val;
__isset.lastHeartbeatTime = true;
}
std::ostream& operator<<(std::ostream& out, const TxnInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TxnInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_state = false;
  bool isset_user = false;
  bool isset_hostname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast570;
          xfer += iprot->readI32(ecast570);
          this->state = (TxnState::type)ecast570;
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          isset_hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->agentInfo);
          this->__isset.agentInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->heartbeatCount);
          this->__isset.heartbeatCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->metaInfo);
          this->__isset.metaInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startedTime);
          this->__isset.startedTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastHeartbeatTime);
          this->__isset.lastHeartbeatTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hostname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TxnInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TxnInfo");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.agentInfo) {
    xfer += oprot->writeFieldBegin("agentInfo", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->agentInfo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.heartbeatCount) {
    xfer += oprot->writeFieldBegin("heartbeatCount", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->heartbeatCount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.metaInfo) {
    xfer += oprot->writeFieldBegin("metaInfo", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->metaInfo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.startedTime) {
    xfer += oprot->writeFieldBegin("startedTime", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->startedTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastHeartbeatTime) {
    xfer += oprot->writeFieldBegin("lastHeartbeatTime", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->lastHeartbeatTime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TxnInfo &a, TxnInfo &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.state, b.state);
  swap(a.user, b.user);
  swap(a.hostname, b.hostname);
  swap(a.agentInfo, b.agentInfo);
  swap(a.heartbeatCount, b.heartbeatCount);
  swap(a.metaInfo, b.metaInfo);
  swap(a.startedTime, b.startedTime);
  swap(a.lastHeartbeatTime, b.lastHeartbeatTime);
  swap(a.__isset, b.__isset);
}

TxnInfo::TxnInfo(const TxnInfo& other571) {
  id = other571.id;
  state = other571.state;
  user = other571.user;
  hostname = other571.hostname;
  agentInfo = other571.agentInfo;
  heartbeatCount = other571.heartbeatCount;
  metaInfo = other571.metaInfo;
  startedTime = other571.startedTime;
  lastHeartbeatTime = other571.lastHeartbeatTime;
  __isset = other571.__isset;
}
TxnInfo& TxnInfo::operator=(const TxnInfo& other572) {
  id = other572.id;
  state = other572.state;
  user = other572.user;
  hostname = other572.hostname;
  agentInfo = other572.agentInfo;
  heartbeatCount = other572.heartbeatCount;
  metaInfo = other572.metaInfo;
  startedTime = other572.startedTime;
  lastHeartbeatTime = other572.lastHeartbeatTime;
  __isset = other572.__isset;
  return *this;
}
void TxnInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TxnInfo(";
  out << "id=" << to_string(id);
  out << ", " << "state=" << to_string(state);
  out << ", " << "user=" << to_string(user);
  out << ", " << "hostname=" << to_string(hostname);
  out << ", " << "agentInfo="; (__isset.agentInfo ? (out << to_string(agentInfo)) : (out << "<null>"));
  out << ", " << "heartbeatCount="; (__isset.heartbeatCount ? (out << to_string(heartbeatCount)) : (out << "<null>"));
  out << ", " << "metaInfo="; (__isset.metaInfo ? (out << to_string(metaInfo)) : (out << "<null>"));
  out << ", " << "startedTime="; (__isset.startedTime ? (out << to_string(startedTime)) : (out << "<null>"));
  out << ", " << "lastHeartbeatTime="; (__isset.lastHeartbeatTime ? (out << to_string(lastHeartbeatTime)) : (out << "<null>"));
  out << ")";
}


GetOpenTxnsInfoResponse::~GetOpenTxnsInfoResponse() noexcept {
}


void GetOpenTxnsInfoResponse::__set_txn_high_water_mark(const int64_t val) {
  this->txn_high_water_mark = val;
}

void GetOpenTxnsInfoResponse::__set_open_txns(const std::vector<TxnInfo> & val) {
  this->open_txns = val;
}
std::ostream& operator<<(std::ostream& out, const GetOpenTxnsInfoResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetOpenTxnsInfoResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txn_high_water_mark = false;
  bool isset_open_txns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txn_high_water_mark);
          isset_txn_high_water_mark = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->open_txns.clear();
            uint32_t _size573;
            ::apache::thrift::protocol::TType _etype576;
            xfer += iprot->readListBegin(_etype576, _size573);
            this->open_txns.resize(_size573);
            uint32_t _i577;
            for (_i577 = 0; _i577 < _size573; ++_i577)
            {
              xfer += this->open_txns[_i577].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_open_txns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txn_high_water_mark)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_open_txns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetOpenTxnsInfoResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetOpenTxnsInfoResponse");

  xfer += oprot->writeFieldBegin("txn_high_water_mark", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txn_high_water_mark);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("open_txns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->open_txns.size()));
    std::vector<TxnInfo> ::const_iterator _iter578;
    for (_iter578 = this->open_txns.begin(); _iter578 != this->open_txns.end(); ++_iter578)
    {
      xfer += (*_iter578).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetOpenTxnsInfoResponse &a, GetOpenTxnsInfoResponse &b) {
  using ::std::swap;
  swap(a.txn_high_water_mark, b.txn_high_water_mark);
  swap(a.open_txns, b.open_txns);
}

GetOpenTxnsInfoResponse::GetOpenTxnsInfoResponse(const GetOpenTxnsInfoResponse& other579) {
  txn_high_water_mark = other579.txn_high_water_mark;
  open_txns = other579.open_txns;
}
GetOpenTxnsInfoResponse& GetOpenTxnsInfoResponse::operator=(const GetOpenTxnsInfoResponse& other580) {
  txn_high_water_mark = other580.txn_high_water_mark;
  open_txns = other580.open_txns;
  return *this;
}
void GetOpenTxnsInfoResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetOpenTxnsInfoResponse(";
  out << "txn_high_water_mark=" << to_string(txn_high_water_mark);
  out << ", " << "open_txns=" << to_string(open_txns);
  out << ")";
}


GetOpenTxnsResponse::~GetOpenTxnsResponse() noexcept {
}


void GetOpenTxnsResponse::__set_txn_high_water_mark(const int64_t val) {
  this->txn_high_water_mark = val;
}

void GetOpenTxnsResponse::__set_open_txns(const std::vector<int64_t> & val) {
  this->open_txns = val;
}

void GetOpenTxnsResponse::__set_min_open_txn(const int64_t val) {
  this->min_open_txn = val;
__isset.min_open_txn = true;
}

void GetOpenTxnsResponse::__set_abortedBits(const std::string& val) {
  this->abortedBits = val;
}
std::ostream& operator<<(std::ostream& out, const GetOpenTxnsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetOpenTxnsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txn_high_water_mark = false;
  bool isset_open_txns = false;
  bool isset_abortedBits = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txn_high_water_mark);
          isset_txn_high_water_mark = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->open_txns.clear();
            uint32_t _size581;
            ::apache::thrift::protocol::TType _etype584;
            xfer += iprot->readListBegin(_etype584, _size581);
            this->open_txns.resize(_size581);
            uint32_t _i585;
            for (_i585 = 0; _i585 < _size581; ++_i585)
            {
              xfer += iprot->readI64(this->open_txns[_i585]);
            }
            xfer += iprot->readListEnd();
          }
          isset_open_txns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->min_open_txn);
          this->__isset.min_open_txn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->abortedBits);
          isset_abortedBits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txn_high_water_mark)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_open_txns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_abortedBits)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetOpenTxnsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetOpenTxnsResponse");

  xfer += oprot->writeFieldBegin("txn_high_water_mark", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txn_high_water_mark);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("open_txns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->open_txns.size()));
    std::vector<int64_t> ::const_iterator _iter586;
    for (_iter586 = this->open_txns.begin(); _iter586 != this->open_txns.end(); ++_iter586)
    {
      xfer += oprot->writeI64((*_iter586));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.min_open_txn) {
    xfer += oprot->writeFieldBegin("min_open_txn", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->min_open_txn);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("abortedBits", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->abortedBits);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetOpenTxnsResponse &a, GetOpenTxnsResponse &b) {
  using ::std::swap;
  swap(a.txn_high_water_mark, b.txn_high_water_mark);
  swap(a.open_txns, b.open_txns);
  swap(a.min_open_txn, b.min_open_txn);
  swap(a.abortedBits, b.abortedBits);
  swap(a.__isset, b.__isset);
}

GetOpenTxnsResponse::GetOpenTxnsResponse(const GetOpenTxnsResponse& other587) {
  txn_high_water_mark = other587.txn_high_water_mark;
  open_txns = other587.open_txns;
  min_open_txn = other587.min_open_txn;
  abortedBits = other587.abortedBits;
  __isset = other587.__isset;
}
GetOpenTxnsResponse& GetOpenTxnsResponse::operator=(const GetOpenTxnsResponse& other588) {
  txn_high_water_mark = other588.txn_high_water_mark;
  open_txns = other588.open_txns;
  min_open_txn = other588.min_open_txn;
  abortedBits = other588.abortedBits;
  __isset = other588.__isset;
  return *this;
}
void GetOpenTxnsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetOpenTxnsResponse(";
  out << "txn_high_water_mark=" << to_string(txn_high_water_mark);
  out << ", " << "open_txns=" << to_string(open_txns);
  out << ", " << "min_open_txn="; (__isset.min_open_txn ? (out << to_string(min_open_txn)) : (out << "<null>"));
  out << ", " << "abortedBits=" << to_string(abortedBits);
  out << ")";
}


OpenTxnRequest::~OpenTxnRequest() noexcept {
}


void OpenTxnRequest::__set_num_txns(const int32_t val) {
  this->num_txns = val;
}

void OpenTxnRequest::__set_user(const std::string& val) {
  this->user = val;
}

void OpenTxnRequest::__set_hostname(const std::string& val) {
  this->hostname = val;
}

void OpenTxnRequest::__set_agentInfo(const std::string& val) {
  this->agentInfo = val;
__isset.agentInfo = true;
}
std::ostream& operator<<(std::ostream& out, const OpenTxnRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t OpenTxnRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_num_txns = false;
  bool isset_user = false;
  bool isset_hostname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_txns);
          isset_num_txns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          isset_hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->agentInfo);
          this->__isset.agentInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_num_txns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hostname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t OpenTxnRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OpenTxnRequest");

  xfer += oprot->writeFieldBegin("num_txns", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->num_txns);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.agentInfo) {
    xfer += oprot->writeFieldBegin("agentInfo", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->agentInfo);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OpenTxnRequest &a, OpenTxnRequest &b) {
  using ::std::swap;
  swap(a.num_txns, b.num_txns);
  swap(a.user, b.user);
  swap(a.hostname, b.hostname);
  swap(a.agentInfo, b.agentInfo);
  swap(a.__isset, b.__isset);
}

OpenTxnRequest::OpenTxnRequest(const OpenTxnRequest& other589) {
  num_txns = other589.num_txns;
  user = other589.user;
  hostname = other589.hostname;
  agentInfo = other589.agentInfo;
  __isset = other589.__isset;
}
OpenTxnRequest& OpenTxnRequest::operator=(const OpenTxnRequest& other590) {
  num_txns = other590.num_txns;
  user = other590.user;
  hostname = other590.hostname;
  agentInfo = other590.agentInfo;
  __isset = other590.__isset;
  return *this;
}
void OpenTxnRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OpenTxnRequest(";
  out << "num_txns=" << to_string(num_txns);
  out << ", " << "user=" << to_string(user);
  out << ", " << "hostname=" << to_string(hostname);
  out << ", " << "agentInfo="; (__isset.agentInfo ? (out << to_string(agentInfo)) : (out << "<null>"));
  out << ")";
}


OpenTxnsResponse::~OpenTxnsResponse() noexcept {
}


void OpenTxnsResponse::__set_txn_ids(const std::vector<int64_t> & val) {
  this->txn_ids = val;
}
std::ostream& operator<<(std::ostream& out, const OpenTxnsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t OpenTxnsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txn_ids = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->txn_ids.clear();
            uint32_t _size591;
            ::apache::thrift::protocol::TType _etype594;
            xfer += iprot->readListBegin(_etype594, _size591);
            this->txn_ids.resize(_size591);
            uint32_t _i595;
            for (_i595 = 0; _i595 < _size591; ++_i595)
            {
              xfer += iprot->readI64(this->txn_ids[_i595]);
            }
            xfer += iprot->readListEnd();
          }
          isset_txn_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txn_ids)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t OpenTxnsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OpenTxnsResponse");

  xfer += oprot->writeFieldBegin("txn_ids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->txn_ids.size()));
    std::vector<int64_t> ::const_iterator _iter596;
    for (_iter596 = this->txn_ids.begin(); _iter596 != this->txn_ids.end(); ++_iter596)
    {
      xfer += oprot->writeI64((*_iter596));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OpenTxnsResponse &a, OpenTxnsResponse &b) {
  using ::std::swap;
  swap(a.txn_ids, b.txn_ids);
}

OpenTxnsResponse::OpenTxnsResponse(const OpenTxnsResponse& other597) {
  txn_ids = other597.txn_ids;
}
OpenTxnsResponse& OpenTxnsResponse::operator=(const OpenTxnsResponse& other598) {
  txn_ids = other598.txn_ids;
  return *this;
}
void OpenTxnsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OpenTxnsResponse(";
  out << "txn_ids=" << to_string(txn_ids);
  out << ")";
}


AbortTxnRequest::~AbortTxnRequest() noexcept {
}


void AbortTxnRequest::__set_txnid(const int64_t val) {
  this->txnid = val;
}
std::ostream& operator<<(std::ostream& out, const AbortTxnRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AbortTxnRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txnid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          isset_txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txnid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AbortTxnRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AbortTxnRequest");

  xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txnid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AbortTxnRequest &a, AbortTxnRequest &b) {
  using ::std::swap;
  swap(a.txnid, b.txnid);
}

AbortTxnRequest::AbortTxnRequest(const AbortTxnRequest& other599) {
  txnid = other599.txnid;
}
AbortTxnRequest& AbortTxnRequest::operator=(const AbortTxnRequest& other600) {
  txnid = other600.txnid;
  return *this;
}
void AbortTxnRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AbortTxnRequest(";
  out << "txnid=" << to_string(txnid);
  out << ")";
}


AbortTxnsRequest::~AbortTxnsRequest() noexcept {
}


void AbortTxnsRequest::__set_txn_ids(const std::vector<int64_t> & val) {
  this->txn_ids = val;
}
std::ostream& operator<<(std::ostream& out, const AbortTxnsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AbortTxnsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txn_ids = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->txn_ids.clear();
            uint32_t _size601;
            ::apache::thrift::protocol::TType _etype604;
            xfer += iprot->readListBegin(_etype604, _size601);
            this->txn_ids.resize(_size601);
            uint32_t _i605;
            for (_i605 = 0; _i605 < _size601; ++_i605)
            {
              xfer += iprot->readI64(this->txn_ids[_i605]);
            }
            xfer += iprot->readListEnd();
          }
          isset_txn_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txn_ids)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AbortTxnsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AbortTxnsRequest");

  xfer += oprot->writeFieldBegin("txn_ids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->txn_ids.size()));
    std::vector<int64_t> ::const_iterator _iter606;
    for (_iter606 = this->txn_ids.begin(); _iter606 != this->txn_ids.end(); ++_iter606)
    {
      xfer += oprot->writeI64((*_iter606));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AbortTxnsRequest &a, AbortTxnsRequest &b) {
  using ::std::swap;
  swap(a.txn_ids, b.txn_ids);
}

AbortTxnsRequest::AbortTxnsRequest(const AbortTxnsRequest& other607) {
  txn_ids = other607.txn_ids;
}
AbortTxnsRequest& AbortTxnsRequest::operator=(const AbortTxnsRequest& other608) {
  txn_ids = other608.txn_ids;
  return *this;
}
void AbortTxnsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AbortTxnsRequest(";
  out << "txn_ids=" << to_string(txn_ids);
  out << ")";
}


CommitTxnRequest::~CommitTxnRequest() noexcept {
}


void CommitTxnRequest::__set_txnid(const int64_t val) {
  this->txnid = val;
}
std::ostream& operator<<(std::ostream& out, const CommitTxnRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CommitTxnRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txnid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          isset_txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txnid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CommitTxnRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CommitTxnRequest");

  xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txnid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CommitTxnRequest &a, CommitTxnRequest &b) {
  using ::std::swap;
  swap(a.txnid, b.txnid);
}

CommitTxnRequest::CommitTxnRequest(const CommitTxnRequest& other609) {
  txnid = other609.txnid;
}
CommitTxnRequest& CommitTxnRequest::operator=(const CommitTxnRequest& other610) {
  txnid = other610.txnid;
  return *this;
}
void CommitTxnRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CommitTxnRequest(";
  out << "txnid=" << to_string(txnid);
  out << ")";
}


LockComponent::~LockComponent() noexcept {
}


void LockComponent::__set_type(const LockType::type val) {
  this->type = val;
}

void LockComponent::__set_level(const LockLevel::type val) {
  this->level = val;
}

void LockComponent::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void LockComponent::__set_tablename(const std::string& val) {
  this->tablename = val;
__isset.tablename = true;
}

void LockComponent::__set_partitionname(const std::string& val) {
  this->partitionname = val;
__isset.partitionname = true;
}

void LockComponent::__set_operationType(const DataOperationType::type val) {
  this->operationType = val;
__isset.operationType = true;
}

void LockComponent::__set_isAcid(const bool val) {
  this->isAcid = val;
__isset.isAcid = true;
}

void LockComponent::__set_isDynamicPartitionWrite(const bool val) {
  this->isDynamicPartitionWrite = val;
__isset.isDynamicPartitionWrite = true;
}
std::ostream& operator<<(std::ostream& out, const LockComponent& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LockComponent::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;
  bool isset_level = false;
  bool isset_dbname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast611;
          xfer += iprot->readI32(ecast611);
          this->type = (LockType::type)ecast611;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast612;
          xfer += iprot->readI32(ecast612);
          this->level = (LockLevel::type)ecast612;
          isset_level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          this->__isset.tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partitionname);
          this->__isset.partitionname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast613;
          xfer += iprot->readI32(ecast613);
          this->operationType = (DataOperationType::type)ecast613;
          this->__isset.operationType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isAcid);
          this->__isset.isAcid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isDynamicPartitionWrite);
          this->__isset.isDynamicPartitionWrite = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_level)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LockComponent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LockComponent");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tablename) {
    xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->tablename);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitionname) {
    xfer += oprot->writeFieldBegin("partitionname", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->partitionname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.operationType) {
    xfer += oprot->writeFieldBegin("operationType", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->operationType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isAcid) {
    xfer += oprot->writeFieldBegin("isAcid", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->isAcid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isDynamicPartitionWrite) {
    xfer += oprot->writeFieldBegin("isDynamicPartitionWrite", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->isDynamicPartitionWrite);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LockComponent &a, LockComponent &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.level, b.level);
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partitionname, b.partitionname);
  swap(a.operationType, b.operationType);
  swap(a.isAcid, b.isAcid);
  swap(a.isDynamicPartitionWrite, b.isDynamicPartitionWrite);
  swap(a.__isset, b.__isset);
}

LockComponent::LockComponent(const LockComponent& other614) {
  type = other614.type;
  level = other614.level;
  dbname = other614.dbname;
  tablename = other614.tablename;
  partitionname = other614.partitionname;
  operationType = other614.operationType;
  isAcid = other614.isAcid;
  isDynamicPartitionWrite = other614.isDynamicPartitionWrite;
  __isset = other614.__isset;
}
LockComponent& LockComponent::operator=(const LockComponent& other615) {
  type = other615.type;
  level = other615.level;
  dbname = other615.dbname;
  tablename = other615.tablename;
  partitionname = other615.partitionname;
  operationType = other615.operationType;
  isAcid = other615.isAcid;
  isDynamicPartitionWrite = other615.isDynamicPartitionWrite;
  __isset = other615.__isset;
  return *this;
}
void LockComponent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LockComponent(";
  out << "type=" << to_string(type);
  out << ", " << "level=" << to_string(level);
  out << ", " << "dbname=" << to_string(dbname);
  out << ", " << "tablename="; (__isset.tablename ? (out << to_string(tablename)) : (out << "<null>"));
  out << ", " << "partitionname="; (__isset.partitionname ? (out << to_string(partitionname)) : (out << "<null>"));
  out << ", " << "operationType="; (__isset.operationType ? (out << to_string(operationType)) : (out << "<null>"));
  out << ", " << "isAcid="; (__isset.isAcid ? (out << to_string(isAcid)) : (out << "<null>"));
  out << ", " << "isDynamicPartitionWrite="; (__isset.isDynamicPartitionWrite ? (out << to_string(isDynamicPartitionWrite)) : (out << "<null>"));
  out << ")";
}


LockRequest::~LockRequest() noexcept {
}


void LockRequest::__set_component(const std::vector<LockComponent> & val) {
  this->component = val;
}

void LockRequest::__set_txnid(const int64_t val) {
  this->txnid = val;
__isset.txnid = true;
}

void LockRequest::__set_user(const std::string& val) {
  this->user = val;
}

void LockRequest::__set_hostname(const std::string& val) {
  this->hostname = val;
}

void LockRequest::__set_agentInfo(const std::string& val) {
  this->agentInfo = val;
__isset.agentInfo = true;
}
std::ostream& operator<<(std::ostream& out, const LockRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LockRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_component = false;
  bool isset_user = false;
  bool isset_hostname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->component.clear();
            uint32_t _size616;
            ::apache::thrift::protocol::TType _etype619;
            xfer += iprot->readListBegin(_etype619, _size616);
            this->component.resize(_size616);
            uint32_t _i620;
            for (_i620 = 0; _i620 < _size616; ++_i620)
            {
              xfer += this->component[_i620].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_component = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          this->__isset.txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          isset_hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->agentInfo);
          this->__isset.agentInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_component)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hostname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LockRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LockRequest");

  xfer += oprot->writeFieldBegin("component", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->component.size()));
    std::vector<LockComponent> ::const_iterator _iter621;
    for (_iter621 = this->component.begin(); _iter621 != this->component.end(); ++_iter621)
    {
      xfer += (*_iter621).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.txnid) {
    xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->txnid);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.agentInfo) {
    xfer += oprot->writeFieldBegin("agentInfo", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->agentInfo);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LockRequest &a, LockRequest &b) {
  using ::std::swap;
  swap(a.component, b.component);
  swap(a.txnid, b.txnid);
  swap(a.user, b.user);
  swap(a.hostname, b.hostname);
  swap(a.agentInfo, b.agentInfo);
  swap(a.__isset, b.__isset);
}

LockRequest::LockRequest(const LockRequest& other622) {
  component = other622.component;
  txnid = other622.txnid;
  user = other622.user;
  hostname = other622.hostname;
  agentInfo = other622.agentInfo;
  __isset = other622.__isset;
}
LockRequest& LockRequest::operator=(const LockRequest& other623) {
  component = other623.component;
  txnid = other623.txnid;
  user = other623.user;
  hostname = other623.hostname;
  agentInfo = other623.agentInfo;
  __isset = other623.__isset;
  return *this;
}
void LockRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LockRequest(";
  out << "component=" << to_string(component);
  out << ", " << "txnid="; (__isset.txnid ? (out << to_string(txnid)) : (out << "<null>"));
  out << ", " << "user=" << to_string(user);
  out << ", " << "hostname=" << to_string(hostname);
  out << ", " << "agentInfo="; (__isset.agentInfo ? (out << to_string(agentInfo)) : (out << "<null>"));
  out << ")";
}


LockResponse::~LockResponse() noexcept {
}


void LockResponse::__set_lockid(const int64_t val) {
  this->lockid = val;
}

void LockResponse::__set_state(const LockState::type val) {
  this->state = val;
}
std::ostream& operator<<(std::ostream& out, const LockResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LockResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lockid = false;
  bool isset_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockid);
          isset_lockid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast624;
          xfer += iprot->readI32(ecast624);
          this->state = (LockState::type)ecast624;
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lockid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LockResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LockResponse");

  xfer += oprot->writeFieldBegin("lockid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lockid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LockResponse &a, LockResponse &b) {
  using ::std::swap;
  swap(a.lockid, b.lockid);
  swap(a.state, b.state);
}

LockResponse::LockResponse(const LockResponse& other625) {
  lockid = other625.lockid;
  state = other625.state;
}
LockResponse& LockResponse::operator=(const LockResponse& other626) {
  lockid = other626.lockid;
  state = other626.state;
  return *this;
}
void LockResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LockResponse(";
  out << "lockid=" << to_string(lockid);
  out << ", " << "state=" << to_string(state);
  out << ")";
}


CheckLockRequest::~CheckLockRequest() noexcept {
}


void CheckLockRequest::__set_lockid(const int64_t val) {
  this->lockid = val;
}

void CheckLockRequest::__set_txnid(const int64_t val) {
  this->txnid = val;
__isset.txnid = true;
}

void CheckLockRequest::__set_elapsed_ms(const int64_t val) {
  this->elapsed_ms = val;
__isset.elapsed_ms = true;
}
std::ostream& operator<<(std::ostream& out, const CheckLockRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CheckLockRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lockid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockid);
          isset_lockid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          this->__isset.txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->elapsed_ms);
          this->__isset.elapsed_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lockid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CheckLockRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CheckLockRequest");

  xfer += oprot->writeFieldBegin("lockid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lockid);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.txnid) {
    xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->txnid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.elapsed_ms) {
    xfer += oprot->writeFieldBegin("elapsed_ms", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->elapsed_ms);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CheckLockRequest &a, CheckLockRequest &b) {
  using ::std::swap;
  swap(a.lockid, b.lockid);
  swap(a.txnid, b.txnid);
  swap(a.elapsed_ms, b.elapsed_ms);
  swap(a.__isset, b.__isset);
}

CheckLockRequest::CheckLockRequest(const CheckLockRequest& other627) {
  lockid = other627.lockid;
  txnid = other627.txnid;
  elapsed_ms = other627.elapsed_ms;
  __isset = other627.__isset;
}
CheckLockRequest& CheckLockRequest::operator=(const CheckLockRequest& other628) {
  lockid = other628.lockid;
  txnid = other628.txnid;
  elapsed_ms = other628.elapsed_ms;
  __isset = other628.__isset;
  return *this;
}
void CheckLockRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CheckLockRequest(";
  out << "lockid=" << to_string(lockid);
  out << ", " << "txnid="; (__isset.txnid ? (out << to_string(txnid)) : (out << "<null>"));
  out << ", " << "elapsed_ms="; (__isset.elapsed_ms ? (out << to_string(elapsed_ms)) : (out << "<null>"));
  out << ")";
}


UnlockRequest::~UnlockRequest() noexcept {
}


void UnlockRequest::__set_lockid(const int64_t val) {
  this->lockid = val;
}
std::ostream& operator<<(std::ostream& out, const UnlockRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UnlockRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lockid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockid);
          isset_lockid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lockid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UnlockRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnlockRequest");

  xfer += oprot->writeFieldBegin("lockid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lockid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnlockRequest &a, UnlockRequest &b) {
  using ::std::swap;
  swap(a.lockid, b.lockid);
}

UnlockRequest::UnlockRequest(const UnlockRequest& other629) {
  lockid = other629.lockid;
}
UnlockRequest& UnlockRequest::operator=(const UnlockRequest& other630) {
  lockid = other630.lockid;
  return *this;
}
void UnlockRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnlockRequest(";
  out << "lockid=" << to_string(lockid);
  out << ")";
}


ShowLocksRequest::~ShowLocksRequest() noexcept {
}


void ShowLocksRequest::__set_dbname(const std::string& val) {
  this->dbname = val;
__isset.dbname = true;
}

void ShowLocksRequest::__set_tablename(const std::string& val) {
  this->tablename = val;
__isset.tablename = true;
}

void ShowLocksRequest::__set_partname(const std::string& val) {
  this->partname = val;
__isset.partname = true;
}

void ShowLocksRequest::__set_isExtended(const bool val) {
  this->isExtended = val;
__isset.isExtended = true;
}
std::ostream& operator<<(std::ostream& out, const ShowLocksRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowLocksRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          this->__isset.dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          this->__isset.tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partname);
          this->__isset.partname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isExtended);
          this->__isset.isExtended = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowLocksRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowLocksRequest");

  if (this->__isset.dbname) {
    xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->dbname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tablename) {
    xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->tablename);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partname) {
    xfer += oprot->writeFieldBegin("partname", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->partname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isExtended) {
    xfer += oprot->writeFieldBegin("isExtended", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->isExtended);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowLocksRequest &a, ShowLocksRequest &b) {
  using ::std::swap;
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partname, b.partname);
  swap(a.isExtended, b.isExtended);
  swap(a.__isset, b.__isset);
}

ShowLocksRequest::ShowLocksRequest(const ShowLocksRequest& other631) {
  dbname = other631.dbname;
  tablename = other631.tablename;
  partname = other631.partname;
  isExtended = other631.isExtended;
  __isset = other631.__isset;
}
ShowLocksRequest& ShowLocksRequest::operator=(const ShowLocksRequest& other632) {
  dbname = other632.dbname;
  tablename = other632.tablename;
  partname = other632.partname;
  isExtended = other632.isExtended;
  __isset = other632.__isset;
  return *this;
}
void ShowLocksRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowLocksRequest(";
  out << "dbname="; (__isset.dbname ? (out << to_string(dbname)) : (out << "<null>"));
  out << ", " << "tablename="; (__isset.tablename ? (out << to_string(tablename)) : (out << "<null>"));
  out << ", " << "partname="; (__isset.partname ? (out << to_string(partname)) : (out << "<null>"));
  out << ", " << "isExtended="; (__isset.isExtended ? (out << to_string(isExtended)) : (out << "<null>"));
  out << ")";
}


ShowLocksResponseElement::~ShowLocksResponseElement() noexcept {
}


void ShowLocksResponseElement::__set_lockid(const int64_t val) {
  this->lockid = val;
}

void ShowLocksResponseElement::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void ShowLocksResponseElement::__set_tablename(const std::string& val) {
  this->tablename = val;
__isset.tablename = true;
}

void ShowLocksResponseElement::__set_partname(const std::string& val) {
  this->partname = val;
__isset.partname = true;
}

void ShowLocksResponseElement::__set_state(const LockState::type val) {
  this->state = val;
}

void ShowLocksResponseElement::__set_type(const LockType::type val) {
  this->type = val;
}

void ShowLocksResponseElement::__set_txnid(const int64_t val) {
  this->txnid = val;
__isset.txnid = true;
}

void ShowLocksResponseElement::__set_lastheartbeat(const int64_t val) {
  this->lastheartbeat = val;
}

void ShowLocksResponseElement::__set_acquiredat(const int64_t val) {
  this->acquiredat = val;
__isset.acquiredat = true;
}

void ShowLocksResponseElement::__set_user(const std::string& val) {
  this->user = val;
}

void ShowLocksResponseElement::__set_hostname(const std::string& val) {
  this->hostname = val;
}

void ShowLocksResponseElement::__set_heartbeatCount(const int32_t val) {
  this->heartbeatCount = val;
__isset.heartbeatCount = true;
}

void ShowLocksResponseElement::__set_agentInfo(const std::string& val) {
  this->agentInfo = val;
__isset.agentInfo = true;
}

void ShowLocksResponseElement::__set_blockedByExtId(const int64_t val) {
  this->blockedByExtId = val;
__isset.blockedByExtId = true;
}

void ShowLocksResponseElement::__set_blockedByIntId(const int64_t val) {
  this->blockedByIntId = val;
__isset.blockedByIntId = true;
}

void ShowLocksResponseElement::__set_lockIdInternal(const int64_t val) {
  this->lockIdInternal = val;
__isset.lockIdInternal = true;
}
std::ostream& operator<<(std::ostream& out, const ShowLocksResponseElement& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowLocksResponseElement::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lockid = false;
  bool isset_dbname = false;
  bool isset_state = false;
  bool isset_type = false;
  bool isset_lastheartbeat = false;
  bool isset_user = false;
  bool isset_hostname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockid);
          isset_lockid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          this->__isset.tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partname);
          this->__isset.partname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast633;
          xfer += iprot->readI32(ecast633);
          this->state = (LockState::type)ecast633;
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast634;
          xfer += iprot->readI32(ecast634);
          this->type = (LockType::type)ecast634;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          this->__isset.txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastheartbeat);
          isset_lastheartbeat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->acquiredat);
          this->__isset.acquiredat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          isset_hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->heartbeatCount);
          this->__isset.heartbeatCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->agentInfo);
          this->__isset.agentInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->blockedByExtId);
          this->__isset.blockedByExtId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->blockedByIntId);
          this->__isset.blockedByIntId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockIdInternal);
          this->__isset.lockIdInternal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lockid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_lastheartbeat)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hostname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ShowLocksResponseElement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowLocksResponseElement");

  xfer += oprot->writeFieldBegin("lockid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lockid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tablename) {
    xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->tablename);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partname) {
    xfer += oprot->writeFieldBegin("partname", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->partname);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.txnid) {
    xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->txnid);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("lastheartbeat", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->lastheartbeat);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.acquiredat) {
    xfer += oprot->writeFieldBegin("acquiredat", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->acquiredat);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.heartbeatCount) {
    xfer += oprot->writeFieldBegin("heartbeatCount", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->heartbeatCount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.agentInfo) {
    xfer += oprot->writeFieldBegin("agentInfo", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->agentInfo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blockedByExtId) {
    xfer += oprot->writeFieldBegin("blockedByExtId", ::apache::thrift::protocol::T_I64, 14);
    xfer += oprot->writeI64(this->blockedByExtId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blockedByIntId) {
    xfer += oprot->writeFieldBegin("blockedByIntId", ::apache::thrift::protocol::T_I64, 15);
    xfer += oprot->writeI64(this->blockedByIntId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lockIdInternal) {
    xfer += oprot->writeFieldBegin("lockIdInternal", ::apache::thrift::protocol::T_I64, 16);
    xfer += oprot->writeI64(this->lockIdInternal);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowLocksResponseElement &a, ShowLocksResponseElement &b) {
  using ::std::swap;
  swap(a.lockid, b.lockid);
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partname, b.partname);
  swap(a.state, b.state);
  swap(a.type, b.type);
  swap(a.txnid, b.txnid);
  swap(a.lastheartbeat, b.lastheartbeat);
  swap(a.acquiredat, b.acquiredat);
  swap(a.user, b.user);
  swap(a.hostname, b.hostname);
  swap(a.heartbeatCount, b.heartbeatCount);
  swap(a.agentInfo, b.agentInfo);
  swap(a.blockedByExtId, b.blockedByExtId);
  swap(a.blockedByIntId, b.blockedByIntId);
  swap(a.lockIdInternal, b.lockIdInternal);
  swap(a.__isset, b.__isset);
}

ShowLocksResponseElement::ShowLocksResponseElement(const ShowLocksResponseElement& other635) {
  lockid = other635.lockid;
  dbname = other635.dbname;
  tablename = other635.tablename;
  partname = other635.partname;
  state = other635.state;
  type = other635.type;
  txnid = other635.txnid;
  lastheartbeat = other635.lastheartbeat;
  acquiredat = other635.acquiredat;
  user = other635.user;
  hostname = other635.hostname;
  heartbeatCount = other635.heartbeatCount;
  agentInfo = other635.agentInfo;
  blockedByExtId = other635.blockedByExtId;
  blockedByIntId = other635.blockedByIntId;
  lockIdInternal = other635.lockIdInternal;
  __isset = other635.__isset;
}
ShowLocksResponseElement& ShowLocksResponseElement::operator=(const ShowLocksResponseElement& other636) {
  lockid = other636.lockid;
  dbname = other636.dbname;
  tablename = other636.tablename;
  partname = other636.partname;
  state = other636.state;
  type = other636.type;
  txnid = other636.txnid;
  lastheartbeat = other636.lastheartbeat;
  acquiredat = other636.acquiredat;
  user = other636.user;
  hostname = other636.hostname;
  heartbeatCount = other636.heartbeatCount;
  agentInfo = other636.agentInfo;
  blockedByExtId = other636.blockedByExtId;
  blockedByIntId = other636.blockedByIntId;
  lockIdInternal = other636.lockIdInternal;
  __isset = other636.__isset;
  return *this;
}
void ShowLocksResponseElement::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowLocksResponseElement(";
  out << "lockid=" << to_string(lockid);
  out << ", " << "dbname=" << to_string(dbname);
  out << ", " << "tablename="; (__isset.tablename ? (out << to_string(tablename)) : (out << "<null>"));
  out << ", " << "partname="; (__isset.partname ? (out << to_string(partname)) : (out << "<null>"));
  out << ", " << "state=" << to_string(state);
  out << ", " << "type=" << to_string(type);
  out << ", " << "txnid="; (__isset.txnid ? (out << to_string(txnid)) : (out << "<null>"));
  out << ", " << "lastheartbeat=" << to_string(lastheartbeat);
  out << ", " << "acquiredat="; (__isset.acquiredat ? (out << to_string(acquiredat)) : (out << "<null>"));
  out << ", " << "user=" << to_string(user);
  out << ", " << "hostname=" << to_string(hostname);
  out << ", " << "heartbeatCount="; (__isset.heartbeatCount ? (out << to_string(heartbeatCount)) : (out << "<null>"));
  out << ", " << "agentInfo="; (__isset.agentInfo ? (out << to_string(agentInfo)) : (out << "<null>"));
  out << ", " << "blockedByExtId="; (__isset.blockedByExtId ? (out << to_string(blockedByExtId)) : (out << "<null>"));
  out << ", " << "blockedByIntId="; (__isset.blockedByIntId ? (out << to_string(blockedByIntId)) : (out << "<null>"));
  out << ", " << "lockIdInternal="; (__isset.lockIdInternal ? (out << to_string(lockIdInternal)) : (out << "<null>"));
  out << ")";
}


ShowLocksResponse::~ShowLocksResponse() noexcept {
}


void ShowLocksResponse::__set_locks(const std::vector<ShowLocksResponseElement> & val) {
  this->locks = val;
}
std::ostream& operator<<(std::ostream& out, const ShowLocksResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowLocksResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->locks.clear();
            uint32_t _size637;
            ::apache::thrift::protocol::TType _etype640;
            xfer += iprot->readListBegin(_etype640, _size637);
            this->locks.resize(_size637);
            uint32_t _i641;
            for (_i641 = 0; _i641 < _size637; ++_i641)
            {
              xfer += this->locks[_i641].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.locks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowLocksResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowLocksResponse");

  xfer += oprot->writeFieldBegin("locks", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->locks.size()));
    std::vector<ShowLocksResponseElement> ::const_iterator _iter642;
    for (_iter642 = this->locks.begin(); _iter642 != this->locks.end(); ++_iter642)
    {
      xfer += (*_iter642).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowLocksResponse &a, ShowLocksResponse &b) {
  using ::std::swap;
  swap(a.locks, b.locks);
  swap(a.__isset, b.__isset);
}

ShowLocksResponse::ShowLocksResponse(const ShowLocksResponse& other643) {
  locks = other643.locks;
  __isset = other643.__isset;
}
ShowLocksResponse& ShowLocksResponse::operator=(const ShowLocksResponse& other644) {
  locks = other644.locks;
  __isset = other644.__isset;
  return *this;
}
void ShowLocksResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowLocksResponse(";
  out << "locks=" << to_string(locks);
  out << ")";
}


HeartbeatRequest::~HeartbeatRequest() noexcept {
}


void HeartbeatRequest::__set_lockid(const int64_t val) {
  this->lockid = val;
__isset.lockid = true;
}

void HeartbeatRequest::__set_txnid(const int64_t val) {
  this->txnid = val;
__isset.txnid = true;
}
std::ostream& operator<<(std::ostream& out, const HeartbeatRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HeartbeatRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lockid);
          this->__isset.lockid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          this->__isset.txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HeartbeatRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HeartbeatRequest");

  if (this->__isset.lockid) {
    xfer += oprot->writeFieldBegin("lockid", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->lockid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.txnid) {
    xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->txnid);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HeartbeatRequest &a, HeartbeatRequest &b) {
  using ::std::swap;
  swap(a.lockid, b.lockid);
  swap(a.txnid, b.txnid);
  swap(a.__isset, b.__isset);
}

HeartbeatRequest::HeartbeatRequest(const HeartbeatRequest& other645) {
  lockid = other645.lockid;
  txnid = other645.txnid;
  __isset = other645.__isset;
}
HeartbeatRequest& HeartbeatRequest::operator=(const HeartbeatRequest& other646) {
  lockid = other646.lockid;
  txnid = other646.txnid;
  __isset = other646.__isset;
  return *this;
}
void HeartbeatRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HeartbeatRequest(";
  out << "lockid="; (__isset.lockid ? (out << to_string(lockid)) : (out << "<null>"));
  out << ", " << "txnid="; (__isset.txnid ? (out << to_string(txnid)) : (out << "<null>"));
  out << ")";
}


HeartbeatTxnRangeRequest::~HeartbeatTxnRangeRequest() noexcept {
}


void HeartbeatTxnRangeRequest::__set_min(const int64_t val) {
  this->min = val;
}

void HeartbeatTxnRangeRequest::__set_max(const int64_t val) {
  this->max = val;
}
std::ostream& operator<<(std::ostream& out, const HeartbeatTxnRangeRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HeartbeatTxnRangeRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_min = false;
  bool isset_max = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->min);
          isset_min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max);
          isset_max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_min)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_max)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HeartbeatTxnRangeRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HeartbeatTxnRangeRequest");

  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HeartbeatTxnRangeRequest &a, HeartbeatTxnRangeRequest &b) {
  using ::std::swap;
  swap(a.min, b.min);
  swap(a.max, b.max);
}

HeartbeatTxnRangeRequest::HeartbeatTxnRangeRequest(const HeartbeatTxnRangeRequest& other647) {
  min = other647.min;
  max = other647.max;
}
HeartbeatTxnRangeRequest& HeartbeatTxnRangeRequest::operator=(const HeartbeatTxnRangeRequest& other648) {
  min = other648.min;
  max = other648.max;
  return *this;
}
void HeartbeatTxnRangeRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HeartbeatTxnRangeRequest(";
  out << "min=" << to_string(min);
  out << ", " << "max=" << to_string(max);
  out << ")";
}


HeartbeatTxnRangeResponse::~HeartbeatTxnRangeResponse() noexcept {
}


void HeartbeatTxnRangeResponse::__set_aborted(const std::set<int64_t> & val) {
  this->aborted = val;
}

void HeartbeatTxnRangeResponse::__set_nosuch(const std::set<int64_t> & val) {
  this->nosuch = val;
}
std::ostream& operator<<(std::ostream& out, const HeartbeatTxnRangeResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t HeartbeatTxnRangeResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_aborted = false;
  bool isset_nosuch = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->aborted.clear();
            uint32_t _size649;
            ::apache::thrift::protocol::TType _etype652;
            xfer += iprot->readSetBegin(_etype652, _size649);
            uint32_t _i653;
            for (_i653 = 0; _i653 < _size649; ++_i653)
            {
              int64_t _elem654;
              xfer += iprot->readI64(_elem654);
              this->aborted.insert(_elem654);
            }
            xfer += iprot->readSetEnd();
          }
          isset_aborted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->nosuch.clear();
            uint32_t _size655;
            ::apache::thrift::protocol::TType _etype658;
            xfer += iprot->readSetBegin(_etype658, _size655);
            uint32_t _i659;
            for (_i659 = 0; _i659 < _size655; ++_i659)
            {
              int64_t _elem660;
              xfer += iprot->readI64(_elem660);
              this->nosuch.insert(_elem660);
            }
            xfer += iprot->readSetEnd();
          }
          isset_nosuch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_aborted)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nosuch)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HeartbeatTxnRangeResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HeartbeatTxnRangeResponse");

  xfer += oprot->writeFieldBegin("aborted", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->aborted.size()));
    std::set<int64_t> ::const_iterator _iter661;
    for (_iter661 = this->aborted.begin(); _iter661 != this->aborted.end(); ++_iter661)
    {
      xfer += oprot->writeI64((*_iter661));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nosuch", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->nosuch.size()));
    std::set<int64_t> ::const_iterator _iter662;
    for (_iter662 = this->nosuch.begin(); _iter662 != this->nosuch.end(); ++_iter662)
    {
      xfer += oprot->writeI64((*_iter662));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HeartbeatTxnRangeResponse &a, HeartbeatTxnRangeResponse &b) {
  using ::std::swap;
  swap(a.aborted, b.aborted);
  swap(a.nosuch, b.nosuch);
}

HeartbeatTxnRangeResponse::HeartbeatTxnRangeResponse(const HeartbeatTxnRangeResponse& other663) {
  aborted = other663.aborted;
  nosuch = other663.nosuch;
}
HeartbeatTxnRangeResponse& HeartbeatTxnRangeResponse::operator=(const HeartbeatTxnRangeResponse& other664) {
  aborted = other664.aborted;
  nosuch = other664.nosuch;
  return *this;
}
void HeartbeatTxnRangeResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HeartbeatTxnRangeResponse(";
  out << "aborted=" << to_string(aborted);
  out << ", " << "nosuch=" << to_string(nosuch);
  out << ")";
}


CompactionRequest::~CompactionRequest() noexcept {
}


void CompactionRequest::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void CompactionRequest::__set_tablename(const std::string& val) {
  this->tablename = val;
}

void CompactionRequest::__set_partitionname(const std::string& val) {
  this->partitionname = val;
__isset.partitionname = true;
}

void CompactionRequest::__set_type(const CompactionType::type val) {
  this->type = val;
}

void CompactionRequest::__set_runas(const std::string& val) {
  this->runas = val;
__isset.runas = true;
}

void CompactionRequest::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
__isset.properties = true;
}
std::ostream& operator<<(std::ostream& out, const CompactionRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CompactionRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbname = false;
  bool isset_tablename = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          isset_tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partitionname);
          this->__isset.partitionname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast665;
          xfer += iprot->readI32(ecast665);
          this->type = (CompactionType::type)ecast665;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->runas);
          this->__isset.runas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size666;
            ::apache::thrift::protocol::TType _ktype667;
            ::apache::thrift::protocol::TType _vtype668;
            xfer += iprot->readMapBegin(_ktype667, _vtype668, _size666);
            uint32_t _i670;
            for (_i670 = 0; _i670 < _size666; ++_i670)
            {
              std::string _key671;
              xfer += iprot->readString(_key671);
              std::string& _val672 = this->properties[_key671];
              xfer += iprot->readString(_val672);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablename)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CompactionRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompactionRequest");

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partitionname) {
    xfer += oprot->writeFieldBegin("partitionname", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->partitionname);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.runas) {
    xfer += oprot->writeFieldBegin("runas", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->runas);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.properties) {
    xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter673;
      for (_iter673 = this->properties.begin(); _iter673 != this->properties.end(); ++_iter673)
      {
        xfer += oprot->writeString(_iter673->first);
        xfer += oprot->writeString(_iter673->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompactionRequest &a, CompactionRequest &b) {
  using ::std::swap;
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partitionname, b.partitionname);
  swap(a.type, b.type);
  swap(a.runas, b.runas);
  swap(a.properties, b.properties);
  swap(a.__isset, b.__isset);
}

CompactionRequest::CompactionRequest(const CompactionRequest& other674) {
  dbname = other674.dbname;
  tablename = other674.tablename;
  partitionname = other674.partitionname;
  type = other674.type;
  runas = other674.runas;
  properties = other674.properties;
  __isset = other674.__isset;
}
CompactionRequest& CompactionRequest::operator=(const CompactionRequest& other675) {
  dbname = other675.dbname;
  tablename = other675.tablename;
  partitionname = other675.partitionname;
  type = other675.type;
  runas = other675.runas;
  properties = other675.properties;
  __isset = other675.__isset;
  return *this;
}
void CompactionRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompactionRequest(";
  out << "dbname=" << to_string(dbname);
  out << ", " << "tablename=" << to_string(tablename);
  out << ", " << "partitionname="; (__isset.partitionname ? (out << to_string(partitionname)) : (out << "<null>"));
  out << ", " << "type=" << to_string(type);
  out << ", " << "runas="; (__isset.runas ? (out << to_string(runas)) : (out << "<null>"));
  out << ", " << "properties="; (__isset.properties ? (out << to_string(properties)) : (out << "<null>"));
  out << ")";
}


CompactionResponse::~CompactionResponse() noexcept {
}


void CompactionResponse::__set_id(const int64_t val) {
  this->id = val;
}

void CompactionResponse::__set_state(const std::string& val) {
  this->state = val;
}

void CompactionResponse::__set_accepted(const bool val) {
  this->accepted = val;
}
std::ostream& operator<<(std::ostream& out, const CompactionResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CompactionResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_state = false;
  bool isset_accepted = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->state);
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->accepted);
          isset_accepted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_accepted)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CompactionResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompactionResponse");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("accepted", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->accepted);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompactionResponse &a, CompactionResponse &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.state, b.state);
  swap(a.accepted, b.accepted);
}

CompactionResponse::CompactionResponse(const CompactionResponse& other676) {
  id = other676.id;
  state = other676.state;
  accepted = other676.accepted;
}
CompactionResponse& CompactionResponse::operator=(const CompactionResponse& other677) {
  id = other677.id;
  state = other677.state;
  accepted = other677.accepted;
  return *this;
}
void CompactionResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompactionResponse(";
  out << "id=" << to_string(id);
  out << ", " << "state=" << to_string(state);
  out << ", " << "accepted=" << to_string(accepted);
  out << ")";
}


ShowCompactRequest::~ShowCompactRequest() noexcept {
}

std::ostream& operator<<(std::ostream& out, const ShowCompactRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowCompactRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowCompactRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowCompactRequest");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowCompactRequest &a, ShowCompactRequest &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

ShowCompactRequest::ShowCompactRequest(const ShowCompactRequest& other678) {
  (void) other678;
}
ShowCompactRequest& ShowCompactRequest::operator=(const ShowCompactRequest& other679) {
  (void) other679;
  return *this;
}
void ShowCompactRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowCompactRequest(";
  out << ")";
}


ShowCompactResponseElement::~ShowCompactResponseElement() noexcept {
}


void ShowCompactResponseElement::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void ShowCompactResponseElement::__set_tablename(const std::string& val) {
  this->tablename = val;
}

void ShowCompactResponseElement::__set_partitionname(const std::string& val) {
  this->partitionname = val;
__isset.partitionname = true;
}

void ShowCompactResponseElement::__set_type(const CompactionType::type val) {
  this->type = val;
}

void ShowCompactResponseElement::__set_state(const std::string& val) {
  this->state = val;
}

void ShowCompactResponseElement::__set_workerid(const std::string& val) {
  this->workerid = val;
__isset.workerid = true;
}

void ShowCompactResponseElement::__set_start(const int64_t val) {
  this->start = val;
__isset.start = true;
}

void ShowCompactResponseElement::__set_runAs(const std::string& val) {
  this->runAs = val;
__isset.runAs = true;
}

void ShowCompactResponseElement::__set_hightestTxnId(const int64_t val) {
  this->hightestTxnId = val;
__isset.hightestTxnId = true;
}

void ShowCompactResponseElement::__set_metaInfo(const std::string& val) {
  this->metaInfo = val;
__isset.metaInfo = true;
}

void ShowCompactResponseElement::__set_endTime(const int64_t val) {
  this->endTime = val;
__isset.endTime = true;
}

void ShowCompactResponseElement::__set_hadoopJobId(const std::string& val) {
  this->hadoopJobId = val;
__isset.hadoopJobId = true;
}

void ShowCompactResponseElement::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}
std::ostream& operator<<(std::ostream& out, const ShowCompactResponseElement& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowCompactResponseElement::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbname = false;
  bool isset_tablename = false;
  bool isset_type = false;
  bool isset_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          isset_tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partitionname);
          this->__isset.partitionname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast680;
          xfer += iprot->readI32(ecast680);
          this->type = (CompactionType::type)ecast680;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->state);
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->workerid);
          this->__isset.workerid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->runAs);
          this->__isset.runAs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->hightestTxnId);
          this->__isset.hightestTxnId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->metaInfo);
          this->__isset.metaInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->endTime);
          this->__isset.endTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hadoopJobId);
          this->__isset.hadoopJobId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablename)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ShowCompactResponseElement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowCompactResponseElement");

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partitionname) {
    xfer += oprot->writeFieldBegin("partitionname", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->partitionname);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.workerid) {
    xfer += oprot->writeFieldBegin("workerid", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->workerid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.start) {
    xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->start);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.runAs) {
    xfer += oprot->writeFieldBegin("runAs", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->runAs);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hightestTxnId) {
    xfer += oprot->writeFieldBegin("hightestTxnId", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->hightestTxnId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.metaInfo) {
    xfer += oprot->writeFieldBegin("metaInfo", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->metaInfo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.endTime) {
    xfer += oprot->writeFieldBegin("endTime", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->endTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hadoopJobId) {
    xfer += oprot->writeFieldBegin("hadoopJobId", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->hadoopJobId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 13);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowCompactResponseElement &a, ShowCompactResponseElement &b) {
  using ::std::swap;
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partitionname, b.partitionname);
  swap(a.type, b.type);
  swap(a.state, b.state);
  swap(a.workerid, b.workerid);
  swap(a.start, b.start);
  swap(a.runAs, b.runAs);
  swap(a.hightestTxnId, b.hightestTxnId);
  swap(a.metaInfo, b.metaInfo);
  swap(a.endTime, b.endTime);
  swap(a.hadoopJobId, b.hadoopJobId);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

ShowCompactResponseElement::ShowCompactResponseElement(const ShowCompactResponseElement& other681) {
  dbname = other681.dbname;
  tablename = other681.tablename;
  partitionname = other681.partitionname;
  type = other681.type;
  state = other681.state;
  workerid = other681.workerid;
  start = other681.start;
  runAs = other681.runAs;
  hightestTxnId = other681.hightestTxnId;
  metaInfo = other681.metaInfo;
  endTime = other681.endTime;
  hadoopJobId = other681.hadoopJobId;
  id = other681.id;
  __isset = other681.__isset;
}
ShowCompactResponseElement& ShowCompactResponseElement::operator=(const ShowCompactResponseElement& other682) {
  dbname = other682.dbname;
  tablename = other682.tablename;
  partitionname = other682.partitionname;
  type = other682.type;
  state = other682.state;
  workerid = other682.workerid;
  start = other682.start;
  runAs = other682.runAs;
  hightestTxnId = other682.hightestTxnId;
  metaInfo = other682.metaInfo;
  endTime = other682.endTime;
  hadoopJobId = other682.hadoopJobId;
  id = other682.id;
  __isset = other682.__isset;
  return *this;
}
void ShowCompactResponseElement::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowCompactResponseElement(";
  out << "dbname=" << to_string(dbname);
  out << ", " << "tablename=" << to_string(tablename);
  out << ", " << "partitionname="; (__isset.partitionname ? (out << to_string(partitionname)) : (out << "<null>"));
  out << ", " << "type=" << to_string(type);
  out << ", " << "state=" << to_string(state);
  out << ", " << "workerid="; (__isset.workerid ? (out << to_string(workerid)) : (out << "<null>"));
  out << ", " << "start="; (__isset.start ? (out << to_string(start)) : (out << "<null>"));
  out << ", " << "runAs="; (__isset.runAs ? (out << to_string(runAs)) : (out << "<null>"));
  out << ", " << "hightestTxnId="; (__isset.hightestTxnId ? (out << to_string(hightestTxnId)) : (out << "<null>"));
  out << ", " << "metaInfo="; (__isset.metaInfo ? (out << to_string(metaInfo)) : (out << "<null>"));
  out << ", " << "endTime="; (__isset.endTime ? (out << to_string(endTime)) : (out << "<null>"));
  out << ", " << "hadoopJobId="; (__isset.hadoopJobId ? (out << to_string(hadoopJobId)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ")";
}


ShowCompactResponse::~ShowCompactResponse() noexcept {
}


void ShowCompactResponse::__set_compacts(const std::vector<ShowCompactResponseElement> & val) {
  this->compacts = val;
}
std::ostream& operator<<(std::ostream& out, const ShowCompactResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowCompactResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_compacts = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->compacts.clear();
            uint32_t _size683;
            ::apache::thrift::protocol::TType _etype686;
            xfer += iprot->readListBegin(_etype686, _size683);
            this->compacts.resize(_size683);
            uint32_t _i687;
            for (_i687 = 0; _i687 < _size683; ++_i687)
            {
              xfer += this->compacts[_i687].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_compacts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_compacts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ShowCompactResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowCompactResponse");

  xfer += oprot->writeFieldBegin("compacts", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->compacts.size()));
    std::vector<ShowCompactResponseElement> ::const_iterator _iter688;
    for (_iter688 = this->compacts.begin(); _iter688 != this->compacts.end(); ++_iter688)
    {
      xfer += (*_iter688).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowCompactResponse &a, ShowCompactResponse &b) {
  using ::std::swap;
  swap(a.compacts, b.compacts);
}

ShowCompactResponse::ShowCompactResponse(const ShowCompactResponse& other689) {
  compacts = other689.compacts;
}
ShowCompactResponse& ShowCompactResponse::operator=(const ShowCompactResponse& other690) {
  compacts = other690.compacts;
  return *this;
}
void ShowCompactResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowCompactResponse(";
  out << "compacts=" << to_string(compacts);
  out << ")";
}


AddDynamicPartitions::~AddDynamicPartitions() noexcept {
}


void AddDynamicPartitions::__set_txnid(const int64_t val) {
  this->txnid = val;
}

void AddDynamicPartitions::__set_dbname(const std::string& val) {
  this->dbname = val;
}

void AddDynamicPartitions::__set_tablename(const std::string& val) {
  this->tablename = val;
}

void AddDynamicPartitions::__set_partitionnames(const std::vector<std::string> & val) {
  this->partitionnames = val;
}

void AddDynamicPartitions::__set_operationType(const DataOperationType::type val) {
  this->operationType = val;
__isset.operationType = true;
}
std::ostream& operator<<(std::ostream& out, const AddDynamicPartitions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddDynamicPartitions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_txnid = false;
  bool isset_dbname = false;
  bool isset_tablename = false;
  bool isset_partitionnames = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->txnid);
          isset_txnid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbname);
          isset_dbname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          isset_tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionnames.clear();
            uint32_t _size691;
            ::apache::thrift::protocol::TType _etype694;
            xfer += iprot->readListBegin(_etype694, _size691);
            this->partitionnames.resize(_size691);
            uint32_t _i695;
            for (_i695 = 0; _i695 < _size691; ++_i695)
            {
              xfer += iprot->readString(this->partitionnames[_i695]);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitionnames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast696;
          xfer += iprot->readI32(ecast696);
          this->operationType = (DataOperationType::type)ecast696;
          this->__isset.operationType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_txnid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tablename)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partitionnames)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AddDynamicPartitions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddDynamicPartitions");

  xfer += oprot->writeFieldBegin("txnid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->txnid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbname", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tablename", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partitionnames", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partitionnames.size()));
    std::vector<std::string> ::const_iterator _iter697;
    for (_iter697 = this->partitionnames.begin(); _iter697 != this->partitionnames.end(); ++_iter697)
    {
      xfer += oprot->writeString((*_iter697));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.operationType) {
    xfer += oprot->writeFieldBegin("operationType", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->operationType);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddDynamicPartitions &a, AddDynamicPartitions &b) {
  using ::std::swap;
  swap(a.txnid, b.txnid);
  swap(a.dbname, b.dbname);
  swap(a.tablename, b.tablename);
  swap(a.partitionnames, b.partitionnames);
  swap(a.operationType, b.operationType);
  swap(a.__isset, b.__isset);
}

AddDynamicPartitions::AddDynamicPartitions(const AddDynamicPartitions& other698) {
  txnid = other698.txnid;
  dbname = other698.dbname;
  tablename = other698.tablename;
  partitionnames = other698.partitionnames;
  operationType = other698.operationType;
  __isset = other698.__isset;
}
AddDynamicPartitions& AddDynamicPartitions::operator=(const AddDynamicPartitions& other699) {
  txnid = other699.txnid;
  dbname = other699.dbname;
  tablename = other699.tablename;
  partitionnames = other699.partitionnames;
  operationType = other699.operationType;
  __isset = other699.__isset;
  return *this;
}
void AddDynamicPartitions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddDynamicPartitions(";
  out << "txnid=" << to_string(txnid);
  out << ", " << "dbname=" << to_string(dbname);
  out << ", " << "tablename=" << to_string(tablename);
  out << ", " << "partitionnames=" << to_string(partitionnames);
  out << ", " << "operationType="; (__isset.operationType ? (out << to_string(operationType)) : (out << "<null>"));
  out << ")";
}


NotificationEventRequest::~NotificationEventRequest() noexcept {
}


void NotificationEventRequest::__set_lastEvent(const int64_t val) {
  this->lastEvent = val;
}

void NotificationEventRequest::__set_maxEvents(const int32_t val) {
  this->maxEvents = val;
__isset.maxEvents = true;
}
std::ostream& operator<<(std::ostream& out, const NotificationEventRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotificationEventRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lastEvent = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastEvent);
          isset_lastEvent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxEvents);
          this->__isset.maxEvents = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lastEvent)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotificationEventRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotificationEventRequest");

  xfer += oprot->writeFieldBegin("lastEvent", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lastEvent);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.maxEvents) {
    xfer += oprot->writeFieldBegin("maxEvents", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->maxEvents);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotificationEventRequest &a, NotificationEventRequest &b) {
  using ::std::swap;
  swap(a.lastEvent, b.lastEvent);
  swap(a.maxEvents, b.maxEvents);
  swap(a.__isset, b.__isset);
}

NotificationEventRequest::NotificationEventRequest(const NotificationEventRequest& other700) {
  lastEvent = other700.lastEvent;
  maxEvents = other700.maxEvents;
  __isset = other700.__isset;
}
NotificationEventRequest& NotificationEventRequest::operator=(const NotificationEventRequest& other701) {
  lastEvent = other701.lastEvent;
  maxEvents = other701.maxEvents;
  __isset = other701.__isset;
  return *this;
}
void NotificationEventRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotificationEventRequest(";
  out << "lastEvent=" << to_string(lastEvent);
  out << ", " << "maxEvents="; (__isset.maxEvents ? (out << to_string(maxEvents)) : (out << "<null>"));
  out << ")";
}


NotificationEvent::~NotificationEvent() noexcept {
}


void NotificationEvent::__set_eventId(const int64_t val) {
  this->eventId = val;
}

void NotificationEvent::__set_eventTime(const int32_t val) {
  this->eventTime = val;
}

void NotificationEvent::__set_eventType(const std::string& val) {
  this->eventType = val;
}

void NotificationEvent::__set_dbName(const std::string& val) {
  this->dbName = val;
__isset.dbName = true;
}

void NotificationEvent::__set_tableName(const std::string& val) {
  this->tableName = val;
__isset.tableName = true;
}

void NotificationEvent::__set_message(const std::string& val) {
  this->message = val;
}

void NotificationEvent::__set_messageFormat(const std::string& val) {
  this->messageFormat = val;
__isset.messageFormat = true;
}
std::ostream& operator<<(std::ostream& out, const NotificationEvent& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotificationEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_eventId = false;
  bool isset_eventTime = false;
  bool isset_eventType = false;
  bool isset_message = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->eventId);
          isset_eventId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->eventTime);
          isset_eventTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->eventType);
          isset_eventType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          isset_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->messageFormat);
          this->__isset.messageFormat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_eventId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_eventTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_eventType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_message)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotificationEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotificationEvent");

  xfer += oprot->writeFieldBegin("eventId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->eventId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eventTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->eventTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eventType", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->eventType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dbName) {
    xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->dbName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableName) {
    xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->tableName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.messageFormat) {
    xfer += oprot->writeFieldBegin("messageFormat", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->messageFormat);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotificationEvent &a, NotificationEvent &b) {
  using ::std::swap;
  swap(a.eventId, b.eventId);
  swap(a.eventTime, b.eventTime);
  swap(a.eventType, b.eventType);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.message, b.message);
  swap(a.messageFormat, b.messageFormat);
  swap(a.__isset, b.__isset);
}

NotificationEvent::NotificationEvent(const NotificationEvent& other702) {
  eventId = other702.eventId;
  eventTime = other702.eventTime;
  eventType = other702.eventType;
  dbName = other702.dbName;
  tableName = other702.tableName;
  message = other702.message;
  messageFormat = other702.messageFormat;
  __isset = other702.__isset;
}
NotificationEvent& NotificationEvent::operator=(const NotificationEvent& other703) {
  eventId = other703.eventId;
  eventTime = other703.eventTime;
  eventType = other703.eventType;
  dbName = other703.dbName;
  tableName = other703.tableName;
  message = other703.message;
  messageFormat = other703.messageFormat;
  __isset = other703.__isset;
  return *this;
}
void NotificationEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotificationEvent(";
  out << "eventId=" << to_string(eventId);
  out << ", " << "eventTime=" << to_string(eventTime);
  out << ", " << "eventType=" << to_string(eventType);
  out << ", " << "dbName="; (__isset.dbName ? (out << to_string(dbName)) : (out << "<null>"));
  out << ", " << "tableName="; (__isset.tableName ? (out << to_string(tableName)) : (out << "<null>"));
  out << ", " << "message=" << to_string(message);
  out << ", " << "messageFormat="; (__isset.messageFormat ? (out << to_string(messageFormat)) : (out << "<null>"));
  out << ")";
}


NotificationEventResponse::~NotificationEventResponse() noexcept {
}


void NotificationEventResponse::__set_events(const std::vector<NotificationEvent> & val) {
  this->events = val;
}
std::ostream& operator<<(std::ostream& out, const NotificationEventResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotificationEventResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_events = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->events.clear();
            uint32_t _size704;
            ::apache::thrift::protocol::TType _etype707;
            xfer += iprot->readListBegin(_etype707, _size704);
            this->events.resize(_size704);
            uint32_t _i708;
            for (_i708 = 0; _i708 < _size704; ++_i708)
            {
              xfer += this->events[_i708].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_events = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_events)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotificationEventResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotificationEventResponse");

  xfer += oprot->writeFieldBegin("events", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->events.size()));
    std::vector<NotificationEvent> ::const_iterator _iter709;
    for (_iter709 = this->events.begin(); _iter709 != this->events.end(); ++_iter709)
    {
      xfer += (*_iter709).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotificationEventResponse &a, NotificationEventResponse &b) {
  using ::std::swap;
  swap(a.events, b.events);
}

NotificationEventResponse::NotificationEventResponse(const NotificationEventResponse& other710) {
  events = other710.events;
}
NotificationEventResponse& NotificationEventResponse::operator=(const NotificationEventResponse& other711) {
  events = other711.events;
  return *this;
}
void NotificationEventResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotificationEventResponse(";
  out << "events=" << to_string(events);
  out << ")";
}


CurrentNotificationEventId::~CurrentNotificationEventId() noexcept {
}


void CurrentNotificationEventId::__set_eventId(const int64_t val) {
  this->eventId = val;
}
std::ostream& operator<<(std::ostream& out, const CurrentNotificationEventId& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CurrentNotificationEventId::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_eventId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->eventId);
          isset_eventId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_eventId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CurrentNotificationEventId::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CurrentNotificationEventId");

  xfer += oprot->writeFieldBegin("eventId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->eventId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CurrentNotificationEventId &a, CurrentNotificationEventId &b) {
  using ::std::swap;
  swap(a.eventId, b.eventId);
}

CurrentNotificationEventId::CurrentNotificationEventId(const CurrentNotificationEventId& other712) {
  eventId = other712.eventId;
}
CurrentNotificationEventId& CurrentNotificationEventId::operator=(const CurrentNotificationEventId& other713) {
  eventId = other713.eventId;
  return *this;
}
void CurrentNotificationEventId::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CurrentNotificationEventId(";
  out << "eventId=" << to_string(eventId);
  out << ")";
}


NotificationEventsCountRequest::~NotificationEventsCountRequest() noexcept {
}


void NotificationEventsCountRequest::__set_fromEventId(const int64_t val) {
  this->fromEventId = val;
}

void NotificationEventsCountRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}
std::ostream& operator<<(std::ostream& out, const NotificationEventsCountRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotificationEventsCountRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fromEventId = false;
  bool isset_dbName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->fromEventId);
          isset_fromEventId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fromEventId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotificationEventsCountRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotificationEventsCountRequest");

  xfer += oprot->writeFieldBegin("fromEventId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->fromEventId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotificationEventsCountRequest &a, NotificationEventsCountRequest &b) {
  using ::std::swap;
  swap(a.fromEventId, b.fromEventId);
  swap(a.dbName, b.dbName);
}

NotificationEventsCountRequest::NotificationEventsCountRequest(const NotificationEventsCountRequest& other714) {
  fromEventId = other714.fromEventId;
  dbName = other714.dbName;
}
NotificationEventsCountRequest& NotificationEventsCountRequest::operator=(const NotificationEventsCountRequest& other715) {
  fromEventId = other715.fromEventId;
  dbName = other715.dbName;
  return *this;
}
void NotificationEventsCountRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotificationEventsCountRequest(";
  out << "fromEventId=" << to_string(fromEventId);
  out << ", " << "dbName=" << to_string(dbName);
  out << ")";
}


NotificationEventsCountResponse::~NotificationEventsCountResponse() noexcept {
}


void NotificationEventsCountResponse::__set_eventsCount(const int64_t val) {
  this->eventsCount = val;
}
std::ostream& operator<<(std::ostream& out, const NotificationEventsCountResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NotificationEventsCountResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_eventsCount = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->eventsCount);
          isset_eventsCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_eventsCount)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NotificationEventsCountResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NotificationEventsCountResponse");

  xfer += oprot->writeFieldBegin("eventsCount", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->eventsCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotificationEventsCountResponse &a, NotificationEventsCountResponse &b) {
  using ::std::swap;
  swap(a.eventsCount, b.eventsCount);
}

NotificationEventsCountResponse::NotificationEventsCountResponse(const NotificationEventsCountResponse& other716) {
  eventsCount = other716.eventsCount;
}
NotificationEventsCountResponse& NotificationEventsCountResponse::operator=(const NotificationEventsCountResponse& other717) {
  eventsCount = other717.eventsCount;
  return *this;
}
void NotificationEventsCountResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NotificationEventsCountResponse(";
  out << "eventsCount=" << to_string(eventsCount);
  out << ")";
}


InsertEventRequestData::~InsertEventRequestData() noexcept {
}


void InsertEventRequestData::__set_replace(const bool val) {
  this->replace = val;
__isset.replace = true;
}

void InsertEventRequestData::__set_filesAdded(const std::vector<std::string> & val) {
  this->filesAdded = val;
}

void InsertEventRequestData::__set_filesAddedChecksum(const std::vector<std::string> & val) {
  this->filesAddedChecksum = val;
__isset.filesAddedChecksum = true;
}
std::ostream& operator<<(std::ostream& out, const InsertEventRequestData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InsertEventRequestData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_filesAdded = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->replace);
          this->__isset.replace = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->filesAdded.clear();
            uint32_t _size718;
            ::apache::thrift::protocol::TType _etype721;
            xfer += iprot->readListBegin(_etype721, _size718);
            this->filesAdded.resize(_size718);
            uint32_t _i722;
            for (_i722 = 0; _i722 < _size718; ++_i722)
            {
              xfer += iprot->readString(this->filesAdded[_i722]);
            }
            xfer += iprot->readListEnd();
          }
          isset_filesAdded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->filesAddedChecksum.clear();
            uint32_t _size723;
            ::apache::thrift::protocol::TType _etype726;
            xfer += iprot->readListBegin(_etype726, _size723);
            this->filesAddedChecksum.resize(_size723);
            uint32_t _i727;
            for (_i727 = 0; _i727 < _size723; ++_i727)
            {
              xfer += iprot->readString(this->filesAddedChecksum[_i727]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.filesAddedChecksum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_filesAdded)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t InsertEventRequestData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InsertEventRequestData");

  if (this->__isset.replace) {
    xfer += oprot->writeFieldBegin("replace", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->replace);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("filesAdded", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->filesAdded.size()));
    std::vector<std::string> ::const_iterator _iter728;
    for (_iter728 = this->filesAdded.begin(); _iter728 != this->filesAdded.end(); ++_iter728)
    {
      xfer += oprot->writeString((*_iter728));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.filesAddedChecksum) {
    xfer += oprot->writeFieldBegin("filesAddedChecksum", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->filesAddedChecksum.size()));
      std::vector<std::string> ::const_iterator _iter729;
      for (_iter729 = this->filesAddedChecksum.begin(); _iter729 != this->filesAddedChecksum.end(); ++_iter729)
      {
        xfer += oprot->writeString((*_iter729));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InsertEventRequestData &a, InsertEventRequestData &b) {
  using ::std::swap;
  swap(a.replace, b.replace);
  swap(a.filesAdded, b.filesAdded);
  swap(a.filesAddedChecksum, b.filesAddedChecksum);
  swap(a.__isset, b.__isset);
}

InsertEventRequestData::InsertEventRequestData(const InsertEventRequestData& other730) {
  replace = other730.replace;
  filesAdded = other730.filesAdded;
  filesAddedChecksum = other730.filesAddedChecksum;
  __isset = other730.__isset;
}
InsertEventRequestData& InsertEventRequestData::operator=(const InsertEventRequestData& other731) {
  replace = other731.replace;
  filesAdded = other731.filesAdded;
  filesAddedChecksum = other731.filesAddedChecksum;
  __isset = other731.__isset;
  return *this;
}
void InsertEventRequestData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InsertEventRequestData(";
  out << "replace="; (__isset.replace ? (out << to_string(replace)) : (out << "<null>"));
  out << ", " << "filesAdded=" << to_string(filesAdded);
  out << ", " << "filesAddedChecksum="; (__isset.filesAddedChecksum ? (out << to_string(filesAddedChecksum)) : (out << "<null>"));
  out << ")";
}


FireEventRequestData::~FireEventRequestData() noexcept {
}


void FireEventRequestData::__set_insertData(const InsertEventRequestData& val) {
  this->insertData = val;
__isset.insertData = true;
}
std::ostream& operator<<(std::ostream& out, const FireEventRequestData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FireEventRequestData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->insertData.read(iprot);
          this->__isset.insertData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FireEventRequestData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FireEventRequestData");

  if (this->__isset.insertData) {
    xfer += oprot->writeFieldBegin("insertData", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->insertData.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FireEventRequestData &a, FireEventRequestData &b) {
  using ::std::swap;
  swap(a.insertData, b.insertData);
  swap(a.__isset, b.__isset);
}

FireEventRequestData::FireEventRequestData(const FireEventRequestData& other732) {
  insertData = other732.insertData;
  __isset = other732.__isset;
}
FireEventRequestData& FireEventRequestData::operator=(const FireEventRequestData& other733) {
  insertData = other733.insertData;
  __isset = other733.__isset;
  return *this;
}
void FireEventRequestData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FireEventRequestData(";
  out << "insertData="; (__isset.insertData ? (out << to_string(insertData)) : (out << "<null>"));
  out << ")";
}


FireEventRequest::~FireEventRequest() noexcept {
}


void FireEventRequest::__set_successful(const bool val) {
  this->successful = val;
}

void FireEventRequest::__set_data(const FireEventRequestData& val) {
  this->data = val;
}

void FireEventRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
__isset.dbName = true;
}

void FireEventRequest::__set_tableName(const std::string& val) {
  this->tableName = val;
__isset.tableName = true;
}

void FireEventRequest::__set_partitionVals(const std::vector<std::string> & val) {
  this->partitionVals = val;
__isset.partitionVals = true;
}
std::ostream& operator<<(std::ostream& out, const FireEventRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FireEventRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_successful = false;
  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->successful);
          isset_successful = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          this->__isset.dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionVals.clear();
            uint32_t _size734;
            ::apache::thrift::protocol::TType _etype737;
            xfer += iprot->readListBegin(_etype737, _size734);
            this->partitionVals.resize(_size734);
            uint32_t _i738;
            for (_i738 = 0; _i738 < _size734; ++_i738)
            {
              xfer += iprot->readString(this->partitionVals[_i738]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitionVals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_successful)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t FireEventRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FireEventRequest");

  xfer += oprot->writeFieldBegin("successful", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->successful);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dbName) {
    xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->dbName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tableName) {
    xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->tableName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitionVals) {
    xfer += oprot->writeFieldBegin("partitionVals", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partitionVals.size()));
      std::vector<std::string> ::const_iterator _iter739;
      for (_iter739 = this->partitionVals.begin(); _iter739 != this->partitionVals.end(); ++_iter739)
      {
        xfer += oprot->writeString((*_iter739));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FireEventRequest &a, FireEventRequest &b) {
  using ::std::swap;
  swap(a.successful, b.successful);
  swap(a.data, b.data);
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.partitionVals, b.partitionVals);
  swap(a.__isset, b.__isset);
}

FireEventRequest::FireEventRequest(const FireEventRequest& other740) {
  successful = other740.successful;
  data = other740.data;
  dbName = other740.dbName;
  tableName = other740.tableName;
  partitionVals = other740.partitionVals;
  __isset = other740.__isset;
}
FireEventRequest& FireEventRequest::operator=(const FireEventRequest& other741) {
  successful = other741.successful;
  data = other741.data;
  dbName = other741.dbName;
  tableName = other741.tableName;
  partitionVals = other741.partitionVals;
  __isset = other741.__isset;
  return *this;
}
void FireEventRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FireEventRequest(";
  out << "successful=" << to_string(successful);
  out << ", " << "data=" << to_string(data);
  out << ", " << "dbName="; (__isset.dbName ? (out << to_string(dbName)) : (out << "<null>"));
  out << ", " << "tableName="; (__isset.tableName ? (out << to_string(tableName)) : (out << "<null>"));
  out << ", " << "partitionVals="; (__isset.partitionVals ? (out << to_string(partitionVals)) : (out << "<null>"));
  out << ")";
}


FireEventResponse::~FireEventResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const FireEventResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FireEventResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FireEventResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FireEventResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FireEventResponse &a, FireEventResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

FireEventResponse::FireEventResponse(const FireEventResponse& other742) {
  (void) other742;
}
FireEventResponse& FireEventResponse::operator=(const FireEventResponse& other743) {
  (void) other743;
  return *this;
}
void FireEventResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FireEventResponse(";
  out << ")";
}


MetadataPpdResult::~MetadataPpdResult() noexcept {
}


void MetadataPpdResult::__set_metadata(const std::string& val) {
  this->metadata = val;
__isset.metadata = true;
}

void MetadataPpdResult::__set_includeBitset(const std::string& val) {
  this->includeBitset = val;
__isset.includeBitset = true;
}
std::ostream& operator<<(std::ostream& out, const MetadataPpdResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MetadataPpdResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->metadata);
          this->__isset.metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->includeBitset);
          this->__isset.includeBitset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MetadataPpdResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MetadataPpdResult");

  if (this->__isset.metadata) {
    xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->metadata);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.includeBitset) {
    xfer += oprot->writeFieldBegin("includeBitset", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->includeBitset);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MetadataPpdResult &a, MetadataPpdResult &b) {
  using ::std::swap;
  swap(a.metadata, b.metadata);
  swap(a.includeBitset, b.includeBitset);
  swap(a.__isset, b.__isset);
}

MetadataPpdResult::MetadataPpdResult(const MetadataPpdResult& other744) {
  metadata = other744.metadata;
  includeBitset = other744.includeBitset;
  __isset = other744.__isset;
}
MetadataPpdResult& MetadataPpdResult::operator=(const MetadataPpdResult& other745) {
  metadata = other745.metadata;
  includeBitset = other745.includeBitset;
  __isset = other745.__isset;
  return *this;
}
void MetadataPpdResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MetadataPpdResult(";
  out << "metadata="; (__isset.metadata ? (out << to_string(metadata)) : (out << "<null>"));
  out << ", " << "includeBitset="; (__isset.includeBitset ? (out << to_string(includeBitset)) : (out << "<null>"));
  out << ")";
}


GetFileMetadataByExprResult::~GetFileMetadataByExprResult() noexcept {
}


void GetFileMetadataByExprResult::__set_metadata(const std::map<int64_t, MetadataPpdResult> & val) {
  this->metadata = val;
}

void GetFileMetadataByExprResult::__set_isSupported(const bool val) {
  this->isSupported = val;
}
std::ostream& operator<<(std::ostream& out, const GetFileMetadataByExprResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetFileMetadataByExprResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_metadata = false;
  bool isset_isSupported = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size746;
            ::apache::thrift::protocol::TType _ktype747;
            ::apache::thrift::protocol::TType _vtype748;
            xfer += iprot->readMapBegin(_ktype747, _vtype748, _size746);
            uint32_t _i750;
            for (_i750 = 0; _i750 < _size746; ++_i750)
            {
              int64_t _key751;
              xfer += iprot->readI64(_key751);
              MetadataPpdResult& _val752 = this->metadata[_key751];
              xfer += _val752.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isSupported);
          isset_isSupported = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isSupported)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetFileMetadataByExprResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetFileMetadataByExprResult");

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->metadata.size()));
    std::map<int64_t, MetadataPpdResult> ::const_iterator _iter753;
    for (_iter753 = this->metadata.begin(); _iter753 != this->metadata.end(); ++_iter753)
    {
      xfer += oprot->writeI64(_iter753->first);
      xfer += _iter753->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isSupported", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->isSupported);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetFileMetadataByExprResult &a, GetFileMetadataByExprResult &b) {
  using ::std::swap;
  swap(a.metadata, b.metadata);
  swap(a.isSupported, b.isSupported);
}

GetFileMetadataByExprResult::GetFileMetadataByExprResult(const GetFileMetadataByExprResult& other754) {
  metadata = other754.metadata;
  isSupported = other754.isSupported;
}
GetFileMetadataByExprResult& GetFileMetadataByExprResult::operator=(const GetFileMetadataByExprResult& other755) {
  metadata = other755.metadata;
  isSupported = other755.isSupported;
  return *this;
}
void GetFileMetadataByExprResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetFileMetadataByExprResult(";
  out << "metadata=" << to_string(metadata);
  out << ", " << "isSupported=" << to_string(isSupported);
  out << ")";
}


GetFileMetadataByExprRequest::~GetFileMetadataByExprRequest() noexcept {
}


void GetFileMetadataByExprRequest::__set_fileIds(const std::vector<int64_t> & val) {
  this->fileIds = val;
}

void GetFileMetadataByExprRequest::__set_expr(const std::string& val) {
  this->expr = val;
}

void GetFileMetadataByExprRequest::__set_doGetFooters(const bool val) {
  this->doGetFooters = val;
__isset.doGetFooters = true;
}

void GetFileMetadataByExprRequest::__set_type(const FileMetadataExprType::type val) {
  this->type = val;
__isset.type = true;
}
std::ostream& operator<<(std::ostream& out, const GetFileMetadataByExprRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetFileMetadataByExprRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fileIds = false;
  bool isset_expr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fileIds.clear();
            uint32_t _size756;
            ::apache::thrift::protocol::TType _etype759;
            xfer += iprot->readListBegin(_etype759, _size756);
            this->fileIds.resize(_size756);
            uint32_t _i760;
            for (_i760 = 0; _i760 < _size756; ++_i760)
            {
              xfer += iprot->readI64(this->fileIds[_i760]);
            }
            xfer += iprot->readListEnd();
          }
          isset_fileIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->expr);
          isset_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->doGetFooters);
          this->__isset.doGetFooters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast761;
          xfer += iprot->readI32(ecast761);
          this->type = (FileMetadataExprType::type)ecast761;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fileIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_expr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetFileMetadataByExprRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetFileMetadataByExprRequest");

  xfer += oprot->writeFieldBegin("fileIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->fileIds.size()));
    std::vector<int64_t> ::const_iterator _iter762;
    for (_iter762 = this->fileIds.begin(); _iter762 != this->fileIds.end(); ++_iter762)
    {
      xfer += oprot->writeI64((*_iter762));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->expr);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.doGetFooters) {
    xfer += oprot->writeFieldBegin("doGetFooters", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->doGetFooters);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetFileMetadataByExprRequest &a, GetFileMetadataByExprRequest &b) {
  using ::std::swap;
  swap(a.fileIds, b.fileIds);
  swap(a.expr, b.expr);
  swap(a.doGetFooters, b.doGetFooters);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

GetFileMetadataByExprRequest::GetFileMetadataByExprRequest(const GetFileMetadataByExprRequest& other763) {
  fileIds = other763.fileIds;
  expr = other763.expr;
  doGetFooters = other763.doGetFooters;
  type = other763.type;
  __isset = other763.__isset;
}
GetFileMetadataByExprRequest& GetFileMetadataByExprRequest::operator=(const GetFileMetadataByExprRequest& other764) {
  fileIds = other764.fileIds;
  expr = other764.expr;
  doGetFooters = other764.doGetFooters;
  type = other764.type;
  __isset = other764.__isset;
  return *this;
}
void GetFileMetadataByExprRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetFileMetadataByExprRequest(";
  out << "fileIds=" << to_string(fileIds);
  out << ", " << "expr=" << to_string(expr);
  out << ", " << "doGetFooters="; (__isset.doGetFooters ? (out << to_string(doGetFooters)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ")";
}


GetFileMetadataResult::~GetFileMetadataResult() noexcept {
}


void GetFileMetadataResult::__set_metadata(const std::map<int64_t, std::string> & val) {
  this->metadata = val;
}

void GetFileMetadataResult::__set_isSupported(const bool val) {
  this->isSupported = val;
}
std::ostream& operator<<(std::ostream& out, const GetFileMetadataResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetFileMetadataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_metadata = false;
  bool isset_isSupported = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->metadata.clear();
            uint32_t _size765;
            ::apache::thrift::protocol::TType _ktype766;
            ::apache::thrift::protocol::TType _vtype767;
            xfer += iprot->readMapBegin(_ktype766, _vtype767, _size765);
            uint32_t _i769;
            for (_i769 = 0; _i769 < _size765; ++_i769)
            {
              int64_t _key770;
              xfer += iprot->readI64(_key770);
              std::string& _val771 = this->metadata[_key770];
              xfer += iprot->readBinary(_val771);
            }
            xfer += iprot->readMapEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isSupported);
          isset_isSupported = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isSupported)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetFileMetadataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetFileMetadataResult");

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::map<int64_t, std::string> ::const_iterator _iter772;
    for (_iter772 = this->metadata.begin(); _iter772 != this->metadata.end(); ++_iter772)
    {
      xfer += oprot->writeI64(_iter772->first);
      xfer += oprot->writeBinary(_iter772->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isSupported", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->isSupported);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetFileMetadataResult &a, GetFileMetadataResult &b) {
  using ::std::swap;
  swap(a.metadata, b.metadata);
  swap(a.isSupported, b.isSupported);
}

GetFileMetadataResult::GetFileMetadataResult(const GetFileMetadataResult& other773) {
  metadata = other773.metadata;
  isSupported = other773.isSupported;
}
GetFileMetadataResult& GetFileMetadataResult::operator=(const GetFileMetadataResult& other774) {
  metadata = other774.metadata;
  isSupported = other774.isSupported;
  return *this;
}
void GetFileMetadataResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetFileMetadataResult(";
  out << "metadata=" << to_string(metadata);
  out << ", " << "isSupported=" << to_string(isSupported);
  out << ")";
}


GetFileMetadataRequest::~GetFileMetadataRequest() noexcept {
}


void GetFileMetadataRequest::__set_fileIds(const std::vector<int64_t> & val) {
  this->fileIds = val;
}
std::ostream& operator<<(std::ostream& out, const GetFileMetadataRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetFileMetadataRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fileIds = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fileIds.clear();
            uint32_t _size775;
            ::apache::thrift::protocol::TType _etype778;
            xfer += iprot->readListBegin(_etype778, _size775);
            this->fileIds.resize(_size775);
            uint32_t _i779;
            for (_i779 = 0; _i779 < _size775; ++_i779)
            {
              xfer += iprot->readI64(this->fileIds[_i779]);
            }
            xfer += iprot->readListEnd();
          }
          isset_fileIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fileIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetFileMetadataRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetFileMetadataRequest");

  xfer += oprot->writeFieldBegin("fileIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->fileIds.size()));
    std::vector<int64_t> ::const_iterator _iter780;
    for (_iter780 = this->fileIds.begin(); _iter780 != this->fileIds.end(); ++_iter780)
    {
      xfer += oprot->writeI64((*_iter780));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetFileMetadataRequest &a, GetFileMetadataRequest &b) {
  using ::std::swap;
  swap(a.fileIds, b.fileIds);
}

GetFileMetadataRequest::GetFileMetadataRequest(const GetFileMetadataRequest& other781) {
  fileIds = other781.fileIds;
}
GetFileMetadataRequest& GetFileMetadataRequest::operator=(const GetFileMetadataRequest& other782) {
  fileIds = other782.fileIds;
  return *this;
}
void GetFileMetadataRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetFileMetadataRequest(";
  out << "fileIds=" << to_string(fileIds);
  out << ")";
}


PutFileMetadataResult::~PutFileMetadataResult() noexcept {
}

std::ostream& operator<<(std::ostream& out, const PutFileMetadataResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PutFileMetadataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PutFileMetadataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PutFileMetadataResult");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PutFileMetadataResult &a, PutFileMetadataResult &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

PutFileMetadataResult::PutFileMetadataResult(const PutFileMetadataResult& other783) {
  (void) other783;
}
PutFileMetadataResult& PutFileMetadataResult::operator=(const PutFileMetadataResult& other784) {
  (void) other784;
  return *this;
}
void PutFileMetadataResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PutFileMetadataResult(";
  out << ")";
}


PutFileMetadataRequest::~PutFileMetadataRequest() noexcept {
}


void PutFileMetadataRequest::__set_fileIds(const std::vector<int64_t> & val) {
  this->fileIds = val;
}

void PutFileMetadataRequest::__set_metadata(const std::vector<std::string> & val) {
  this->metadata = val;
}

void PutFileMetadataRequest::__set_type(const FileMetadataExprType::type val) {
  this->type = val;
__isset.type = true;
}
std::ostream& operator<<(std::ostream& out, const PutFileMetadataRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PutFileMetadataRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fileIds = false;
  bool isset_metadata = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fileIds.clear();
            uint32_t _size785;
            ::apache::thrift::protocol::TType _etype788;
            xfer += iprot->readListBegin(_etype788, _size785);
            this->fileIds.resize(_size785);
            uint32_t _i789;
            for (_i789 = 0; _i789 < _size785; ++_i789)
            {
              xfer += iprot->readI64(this->fileIds[_i789]);
            }
            xfer += iprot->readListEnd();
          }
          isset_fileIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->metadata.clear();
            uint32_t _size790;
            ::apache::thrift::protocol::TType _etype793;
            xfer += iprot->readListBegin(_etype793, _size790);
            this->metadata.resize(_size790);
            uint32_t _i794;
            for (_i794 = 0; _i794 < _size790; ++_i794)
            {
              xfer += iprot->readBinary(this->metadata[_i794]);
            }
            xfer += iprot->readListEnd();
          }
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast795;
          xfer += iprot->readI32(ecast795);
          this->type = (FileMetadataExprType::type)ecast795;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fileIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PutFileMetadataRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PutFileMetadataRequest");

  xfer += oprot->writeFieldBegin("fileIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->fileIds.size()));
    std::vector<int64_t> ::const_iterator _iter796;
    for (_iter796 = this->fileIds.begin(); _iter796 != this->fileIds.end(); ++_iter796)
    {
      xfer += oprot->writeI64((*_iter796));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->metadata.size()));
    std::vector<std::string> ::const_iterator _iter797;
    for (_iter797 = this->metadata.begin(); _iter797 != this->metadata.end(); ++_iter797)
    {
      xfer += oprot->writeBinary((*_iter797));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PutFileMetadataRequest &a, PutFileMetadataRequest &b) {
  using ::std::swap;
  swap(a.fileIds, b.fileIds);
  swap(a.metadata, b.metadata);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

PutFileMetadataRequest::PutFileMetadataRequest(const PutFileMetadataRequest& other798) {
  fileIds = other798.fileIds;
  metadata = other798.metadata;
  type = other798.type;
  __isset = other798.__isset;
}
PutFileMetadataRequest& PutFileMetadataRequest::operator=(const PutFileMetadataRequest& other799) {
  fileIds = other799.fileIds;
  metadata = other799.metadata;
  type = other799.type;
  __isset = other799.__isset;
  return *this;
}
void PutFileMetadataRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PutFileMetadataRequest(";
  out << "fileIds=" << to_string(fileIds);
  out << ", " << "metadata=" << to_string(metadata);
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ")";
}


ClearFileMetadataResult::~ClearFileMetadataResult() noexcept {
}

std::ostream& operator<<(std::ostream& out, const ClearFileMetadataResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ClearFileMetadataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClearFileMetadataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClearFileMetadataResult");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ClearFileMetadataResult &a, ClearFileMetadataResult &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

ClearFileMetadataResult::ClearFileMetadataResult(const ClearFileMetadataResult& other800) {
  (void) other800;
}
ClearFileMetadataResult& ClearFileMetadataResult::operator=(const ClearFileMetadataResult& other801) {
  (void) other801;
  return *this;
}
void ClearFileMetadataResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ClearFileMetadataResult(";
  out << ")";
}


ClearFileMetadataRequest::~ClearFileMetadataRequest() noexcept {
}


void ClearFileMetadataRequest::__set_fileIds(const std::vector<int64_t> & val) {
  this->fileIds = val;
}
std::ostream& operator<<(std::ostream& out, const ClearFileMetadataRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ClearFileMetadataRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fileIds = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fileIds.clear();
            uint32_t _size802;
            ::apache::thrift::protocol::TType _etype805;
            xfer += iprot->readListBegin(_etype805, _size802);
            this->fileIds.resize(_size802);
            uint32_t _i806;
            for (_i806 = 0; _i806 < _size802; ++_i806)
            {
              xfer += iprot->readI64(this->fileIds[_i806]);
            }
            xfer += iprot->readListEnd();
          }
          isset_fileIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fileIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ClearFileMetadataRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClearFileMetadataRequest");

  xfer += oprot->writeFieldBegin("fileIds", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->fileIds.size()));
    std::vector<int64_t> ::const_iterator _iter807;
    for (_iter807 = this->fileIds.begin(); _iter807 != this->fileIds.end(); ++_iter807)
    {
      xfer += oprot->writeI64((*_iter807));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ClearFileMetadataRequest &a, ClearFileMetadataRequest &b) {
  using ::std::swap;
  swap(a.fileIds, b.fileIds);
}

ClearFileMetadataRequest::ClearFileMetadataRequest(const ClearFileMetadataRequest& other808) {
  fileIds = other808.fileIds;
}
ClearFileMetadataRequest& ClearFileMetadataRequest::operator=(const ClearFileMetadataRequest& other809) {
  fileIds = other809.fileIds;
  return *this;
}
void ClearFileMetadataRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ClearFileMetadataRequest(";
  out << "fileIds=" << to_string(fileIds);
  out << ")";
}


CacheFileMetadataResult::~CacheFileMetadataResult() noexcept {
}


void CacheFileMetadataResult::__set_isSupported(const bool val) {
  this->isSupported = val;
}
std::ostream& operator<<(std::ostream& out, const CacheFileMetadataResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CacheFileMetadataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_isSupported = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isSupported);
          isset_isSupported = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_isSupported)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CacheFileMetadataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CacheFileMetadataResult");

  xfer += oprot->writeFieldBegin("isSupported", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->isSupported);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CacheFileMetadataResult &a, CacheFileMetadataResult &b) {
  using ::std::swap;
  swap(a.isSupported, b.isSupported);
}

CacheFileMetadataResult::CacheFileMetadataResult(const CacheFileMetadataResult& other810) {
  isSupported = other810.isSupported;
}
CacheFileMetadataResult& CacheFileMetadataResult::operator=(const CacheFileMetadataResult& other811) {
  isSupported = other811.isSupported;
  return *this;
}
void CacheFileMetadataResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CacheFileMetadataResult(";
  out << "isSupported=" << to_string(isSupported);
  out << ")";
}


CacheFileMetadataRequest::~CacheFileMetadataRequest() noexcept {
}


void CacheFileMetadataRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void CacheFileMetadataRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void CacheFileMetadataRequest::__set_partName(const std::string& val) {
  this->partName = val;
__isset.partName = true;
}

void CacheFileMetadataRequest::__set_isAllParts(const bool val) {
  this->isAllParts = val;
__isset.isAllParts = true;
}
std::ostream& operator<<(std::ostream& out, const CacheFileMetadataRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CacheFileMetadataRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partName);
          this->__isset.partName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isAllParts);
          this->__isset.isAllParts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CacheFileMetadataRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CacheFileMetadataRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partName) {
    xfer += oprot->writeFieldBegin("partName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->partName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isAllParts) {
    xfer += oprot->writeFieldBegin("isAllParts", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->isAllParts);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CacheFileMetadataRequest &a, CacheFileMetadataRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.partName, b.partName);
  swap(a.isAllParts, b.isAllParts);
  swap(a.__isset, b.__isset);
}

CacheFileMetadataRequest::CacheFileMetadataRequest(const CacheFileMetadataRequest& other812) {
  dbName = other812.dbName;
  tblName = other812.tblName;
  partName = other812.partName;
  isAllParts = other812.isAllParts;
  __isset = other812.__isset;
}
CacheFileMetadataRequest& CacheFileMetadataRequest::operator=(const CacheFileMetadataRequest& other813) {
  dbName = other813.dbName;
  tblName = other813.tblName;
  partName = other813.partName;
  isAllParts = other813.isAllParts;
  __isset = other813.__isset;
  return *this;
}
void CacheFileMetadataRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CacheFileMetadataRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "partName="; (__isset.partName ? (out << to_string(partName)) : (out << "<null>"));
  out << ", " << "isAllParts="; (__isset.isAllParts ? (out << to_string(isAllParts)) : (out << "<null>"));
  out << ")";
}


GetAllFunctionsResponse::~GetAllFunctionsResponse() noexcept {
}


void GetAllFunctionsResponse::__set_functions(const std::vector<Function> & val) {
  this->functions = val;
__isset.functions = true;
}
std::ostream& operator<<(std::ostream& out, const GetAllFunctionsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetAllFunctionsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->functions.clear();
            uint32_t _size814;
            ::apache::thrift::protocol::TType _etype817;
            xfer += iprot->readListBegin(_etype817, _size814);
            this->functions.resize(_size814);
            uint32_t _i818;
            for (_i818 = 0; _i818 < _size814; ++_i818)
            {
              xfer += this->functions[_i818].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.functions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetAllFunctionsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetAllFunctionsResponse");

  if (this->__isset.functions) {
    xfer += oprot->writeFieldBegin("functions", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->functions.size()));
      std::vector<Function> ::const_iterator _iter819;
      for (_iter819 = this->functions.begin(); _iter819 != this->functions.end(); ++_iter819)
      {
        xfer += (*_iter819).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetAllFunctionsResponse &a, GetAllFunctionsResponse &b) {
  using ::std::swap;
  swap(a.functions, b.functions);
  swap(a.__isset, b.__isset);
}

GetAllFunctionsResponse::GetAllFunctionsResponse(const GetAllFunctionsResponse& other820) {
  functions = other820.functions;
  __isset = other820.__isset;
}
GetAllFunctionsResponse& GetAllFunctionsResponse::operator=(const GetAllFunctionsResponse& other821) {
  functions = other821.functions;
  __isset = other821.__isset;
  return *this;
}
void GetAllFunctionsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetAllFunctionsResponse(";
  out << "functions="; (__isset.functions ? (out << to_string(functions)) : (out << "<null>"));
  out << ")";
}


ClientCapabilities::~ClientCapabilities() noexcept {
}


void ClientCapabilities::__set_values(const std::vector<ClientCapability::type> & val) {
  this->values = val;
}
std::ostream& operator<<(std::ostream& out, const ClientCapabilities& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ClientCapabilities::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_values = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size822;
            ::apache::thrift::protocol::TType _etype825;
            xfer += iprot->readListBegin(_etype825, _size822);
            this->values.resize(_size822);
            uint32_t _i826;
            for (_i826 = 0; _i826 < _size822; ++_i826)
            {
              int32_t ecast827;
              xfer += iprot->readI32(ecast827);
              this->values[_i826] = (ClientCapability::type)ecast827;
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ClientCapabilities::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientCapabilities");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->values.size()));
    std::vector<ClientCapability::type> ::const_iterator _iter828;
    for (_iter828 = this->values.begin(); _iter828 != this->values.end(); ++_iter828)
    {
      xfer += oprot->writeI32((int32_t)(*_iter828));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ClientCapabilities &a, ClientCapabilities &b) {
  using ::std::swap;
  swap(a.values, b.values);
}

ClientCapabilities::ClientCapabilities(const ClientCapabilities& other829) {
  values = other829.values;
}
ClientCapabilities& ClientCapabilities::operator=(const ClientCapabilities& other830) {
  values = other830.values;
  return *this;
}
void ClientCapabilities::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ClientCapabilities(";
  out << "values=" << to_string(values);
  out << ")";
}


GetTableRequest::~GetTableRequest() noexcept {
}


void GetTableRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void GetTableRequest::__set_tblName(const std::string& val) {
  this->tblName = val;
}

void GetTableRequest::__set_capabilities(const ClientCapabilities& val) {
  this->capabilities = val;
__isset.capabilities = true;
}
std::ostream& operator<<(std::ostream& out, const GetTableRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetTableRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tblName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tblName);
          isset_tblName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->capabilities.read(iprot);
          this->__isset.capabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tblName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetTableRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetTableRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tblName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tblName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.capabilities) {
    xfer += oprot->writeFieldBegin("capabilities", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->capabilities.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetTableRequest &a, GetTableRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblName, b.tblName);
  swap(a.capabilities, b.capabilities);
  swap(a.__isset, b.__isset);
}

GetTableRequest::GetTableRequest(const GetTableRequest& other831) {
  dbName = other831.dbName;
  tblName = other831.tblName;
  capabilities = other831.capabilities;
  __isset = other831.__isset;
}
GetTableRequest& GetTableRequest::operator=(const GetTableRequest& other832) {
  dbName = other832.dbName;
  tblName = other832.tblName;
  capabilities = other832.capabilities;
  __isset = other832.__isset;
  return *this;
}
void GetTableRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetTableRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblName=" << to_string(tblName);
  out << ", " << "capabilities="; (__isset.capabilities ? (out << to_string(capabilities)) : (out << "<null>"));
  out << ")";
}


GetTableResult::~GetTableResult() noexcept {
}


void GetTableResult::__set_table(const Table& val) {
  this->table = val;
}
std::ostream& operator<<(std::ostream& out, const GetTableResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetTableResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table.read(iprot);
          isset_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetTableResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetTableResult");

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetTableResult &a, GetTableResult &b) {
  using ::std::swap;
  swap(a.table, b.table);
}

GetTableResult::GetTableResult(const GetTableResult& other833) {
  table = other833.table;
}
GetTableResult& GetTableResult::operator=(const GetTableResult& other834) {
  table = other834.table;
  return *this;
}
void GetTableResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetTableResult(";
  out << "table=" << to_string(table);
  out << ")";
}


GetTablesRequest::~GetTablesRequest() noexcept {
}


void GetTablesRequest::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void GetTablesRequest::__set_tblNames(const std::vector<std::string> & val) {
  this->tblNames = val;
__isset.tblNames = true;
}

void GetTablesRequest::__set_capabilities(const ClientCapabilities& val) {
  this->capabilities = val;
__isset.capabilities = true;
}
std::ostream& operator<<(std::ostream& out, const GetTablesRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetTablesRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tblNames.clear();
            uint32_t _size835;
            ::apache::thrift::protocol::TType _etype838;
            xfer += iprot->readListBegin(_etype838, _size835);
            this->tblNames.resize(_size835);
            uint32_t _i839;
            for (_i839 = 0; _i839 < _size835; ++_i839)
            {
              xfer += iprot->readString(this->tblNames[_i839]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tblNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->capabilities.read(iprot);
          this->__isset.capabilities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetTablesRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetTablesRequest");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tblNames) {
    xfer += oprot->writeFieldBegin("tblNames", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tblNames.size()));
      std::vector<std::string> ::const_iterator _iter840;
      for (_iter840 = this->tblNames.begin(); _iter840 != this->tblNames.end(); ++_iter840)
      {
        xfer += oprot->writeString((*_iter840));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.capabilities) {
    xfer += oprot->writeFieldBegin("capabilities", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->capabilities.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetTablesRequest &a, GetTablesRequest &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tblNames, b.tblNames);
  swap(a.capabilities, b.capabilities);
  swap(a.__isset, b.__isset);
}

GetTablesRequest::GetTablesRequest(const GetTablesRequest& other841) {
  dbName = other841.dbName;
  tblNames = other841.tblNames;
  capabilities = other841.capabilities;
  __isset = other841.__isset;
}
GetTablesRequest& GetTablesRequest::operator=(const GetTablesRequest& other842) {
  dbName = other842.dbName;
  tblNames = other842.tblNames;
  capabilities = other842.capabilities;
  __isset = other842.__isset;
  return *this;
}
void GetTablesRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetTablesRequest(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tblNames="; (__isset.tblNames ? (out << to_string(tblNames)) : (out << "<null>"));
  out << ", " << "capabilities="; (__isset.capabilities ? (out << to_string(capabilities)) : (out << "<null>"));
  out << ")";
}


GetTablesResult::~GetTablesResult() noexcept {
}


void GetTablesResult::__set_tables(const std::vector<Table> & val) {
  this->tables = val;
}
std::ostream& operator<<(std::ostream& out, const GetTablesResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetTablesResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tables = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tables.clear();
            uint32_t _size843;
            ::apache::thrift::protocol::TType _etype846;
            xfer += iprot->readListBegin(_etype846, _size843);
            this->tables.resize(_size843);
            uint32_t _i847;
            for (_i847 = 0; _i847 < _size843; ++_i847)
            {
              xfer += this->tables[_i847].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_tables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tables)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GetTablesResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetTablesResult");

  xfer += oprot->writeFieldBegin("tables", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tables.size()));
    std::vector<Table> ::const_iterator _iter848;
    for (_iter848 = this->tables.begin(); _iter848 != this->tables.end(); ++_iter848)
    {
      xfer += (*_iter848).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetTablesResult &a, GetTablesResult &b) {
  using ::std::swap;
  swap(a.tables, b.tables);
}

GetTablesResult::GetTablesResult(const GetTablesResult& other849) {
  tables = other849.tables;
}
GetTablesResult& GetTablesResult::operator=(const GetTablesResult& other850) {
  tables = other850.tables;
  return *this;
}
void GetTablesResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetTablesResult(";
  out << "tables=" << to_string(tables);
  out << ")";
}


CmRecycleRequest::~CmRecycleRequest() noexcept {
}


void CmRecycleRequest::__set_dataPath(const std::string& val) {
  this->dataPath = val;
}

void CmRecycleRequest::__set_purge(const bool val) {
  this->purge = val;
}
std::ostream& operator<<(std::ostream& out, const CmRecycleRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CmRecycleRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dataPath = false;
  bool isset_purge = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataPath);
          isset_dataPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->purge);
          isset_purge = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dataPath)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_purge)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CmRecycleRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CmRecycleRequest");

  xfer += oprot->writeFieldBegin("dataPath", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dataPath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("purge", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->purge);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CmRecycleRequest &a, CmRecycleRequest &b) {
  using ::std::swap;
  swap(a.dataPath, b.dataPath);
  swap(a.purge, b.purge);
}

CmRecycleRequest::CmRecycleRequest(const CmRecycleRequest& other851) {
  dataPath = other851.dataPath;
  purge = other851.purge;
}
CmRecycleRequest& CmRecycleRequest::operator=(const CmRecycleRequest& other852) {
  dataPath = other852.dataPath;
  purge = other852.purge;
  return *this;
}
void CmRecycleRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CmRecycleRequest(";
  out << "dataPath=" << to_string(dataPath);
  out << ", " << "purge=" << to_string(purge);
  out << ")";
}


CmRecycleResponse::~CmRecycleResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const CmRecycleResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CmRecycleResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CmRecycleResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CmRecycleResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CmRecycleResponse &a, CmRecycleResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CmRecycleResponse::CmRecycleResponse(const CmRecycleResponse& other853) {
  (void) other853;
}
CmRecycleResponse& CmRecycleResponse::operator=(const CmRecycleResponse& other854) {
  (void) other854;
  return *this;
}
void CmRecycleResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CmRecycleResponse(";
  out << ")";
}


TableMeta::~TableMeta() noexcept {
}


void TableMeta::__set_dbName(const std::string& val) {
  this->dbName = val;
}

void TableMeta::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void TableMeta::__set_tableType(const std::string& val) {
  this->tableType = val;
}

void TableMeta::__set_comments(const std::string& val) {
  this->comments = val;
__isset.comments = true;
}
std::ostream& operator<<(std::ostream& out, const TableMeta& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TableMeta::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbName = false;
  bool isset_tableName = false;
  bool isset_tableType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableType);
          isset_tableType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comments);
          this->__isset.comments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TableMeta::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TableMeta");

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableType", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tableType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.comments) {
    xfer += oprot->writeFieldBegin("comments", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->comments);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TableMeta &a, TableMeta &b) {
  using ::std::swap;
  swap(a.dbName, b.dbName);
  swap(a.tableName, b.tableName);
  swap(a.tableType, b.tableType);
  swap(a.comments, b.comments);
  swap(a.__isset, b.__isset);
}

TableMeta::TableMeta(const TableMeta& other855) {
  dbName = other855.dbName;
  tableName = other855.tableName;
  tableType = other855.tableType;
  comments = other855.comments;
  __isset = other855.__isset;
}
TableMeta& TableMeta::operator=(const TableMeta& other856) {
  dbName = other856.dbName;
  tableName = other856.tableName;
  tableType = other856.tableType;
  comments = other856.comments;
  __isset = other856.__isset;
  return *this;
}
void TableMeta::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TableMeta(";
  out << "dbName=" << to_string(dbName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "tableType=" << to_string(tableType);
  out << ", " << "comments="; (__isset.comments ? (out << to_string(comments)) : (out << "<null>"));
  out << ")";
}


WMResourcePlan::~WMResourcePlan() noexcept {
}


void WMResourcePlan::__set_name(const std::string& val) {
  this->name = val;
}

void WMResourcePlan::__set_status(const WMResourcePlanStatus::type val) {
  this->status = val;
__isset.status = true;
}

void WMResourcePlan::__set_queryParallelism(const int32_t val) {
  this->queryParallelism = val;
__isset.queryParallelism = true;
}

void WMResourcePlan::__set_defaultPoolPath(const std::string& val) {
  this->defaultPoolPath = val;
__isset.defaultPoolPath = true;
}
std::ostream& operator<<(std::ostream& out, const WMResourcePlan& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMResourcePlan::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast857;
          xfer += iprot->readI32(ecast857);
          this->status = (WMResourcePlanStatus::type)ecast857;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->queryParallelism);
          this->__isset.queryParallelism = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->defaultPoolPath);
          this->__isset.defaultPoolPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WMResourcePlan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMResourcePlan");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->status);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.queryParallelism) {
    xfer += oprot->writeFieldBegin("queryParallelism", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->queryParallelism);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.defaultPoolPath) {
    xfer += oprot->writeFieldBegin("defaultPoolPath", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->defaultPoolPath);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMResourcePlan &a, WMResourcePlan &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.status, b.status);
  swap(a.queryParallelism, b.queryParallelism);
  swap(a.defaultPoolPath, b.defaultPoolPath);
  swap(a.__isset, b.__isset);
}

WMResourcePlan::WMResourcePlan(const WMResourcePlan& other858) {
  name = other858.name;
  status = other858.status;
  queryParallelism = other858.queryParallelism;
  defaultPoolPath = other858.defaultPoolPath;
  __isset = other858.__isset;
}
WMResourcePlan& WMResourcePlan::operator=(const WMResourcePlan& other859) {
  name = other859.name;
  status = other859.status;
  queryParallelism = other859.queryParallelism;
  defaultPoolPath = other859.defaultPoolPath;
  __isset = other859.__isset;
  return *this;
}
void WMResourcePlan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMResourcePlan(";
  out << "name=" << to_string(name);
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ", " << "queryParallelism="; (__isset.queryParallelism ? (out << to_string(queryParallelism)) : (out << "<null>"));
  out << ", " << "defaultPoolPath="; (__isset.defaultPoolPath ? (out << to_string(defaultPoolPath)) : (out << "<null>"));
  out << ")";
}


WMPool::~WMPool() noexcept {
}


void WMPool::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
}

void WMPool::__set_poolPath(const std::string& val) {
  this->poolPath = val;
}

void WMPool::__set_allocFraction(const double val) {
  this->allocFraction = val;
__isset.allocFraction = true;
}

void WMPool::__set_queryParallelism(const int32_t val) {
  this->queryParallelism = val;
__isset.queryParallelism = true;
}

void WMPool::__set_schedulingPolicy(const std::string& val) {
  this->schedulingPolicy = val;
__isset.schedulingPolicy = true;
}
std::ostream& operator<<(std::ostream& out, const WMPool& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMPool::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resourcePlanName = false;
  bool isset_poolPath = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          isset_resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->poolPath);
          isset_poolPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->allocFraction);
          this->__isset.allocFraction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->queryParallelism);
          this->__isset.queryParallelism = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schedulingPolicy);
          this->__isset.schedulingPolicy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resourcePlanName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_poolPath)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WMPool::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMPool");

  xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->resourcePlanName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("poolPath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->poolPath);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.allocFraction) {
    xfer += oprot->writeFieldBegin("allocFraction", ::apache::thrift::protocol::T_DOUBLE, 3);
    xfer += oprot->writeDouble(this->allocFraction);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.queryParallelism) {
    xfer += oprot->writeFieldBegin("queryParallelism", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->queryParallelism);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schedulingPolicy) {
    xfer += oprot->writeFieldBegin("schedulingPolicy", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->schedulingPolicy);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMPool &a, WMPool &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.poolPath, b.poolPath);
  swap(a.allocFraction, b.allocFraction);
  swap(a.queryParallelism, b.queryParallelism);
  swap(a.schedulingPolicy, b.schedulingPolicy);
  swap(a.__isset, b.__isset);
}

WMPool::WMPool(const WMPool& other860) {
  resourcePlanName = other860.resourcePlanName;
  poolPath = other860.poolPath;
  allocFraction = other860.allocFraction;
  queryParallelism = other860.queryParallelism;
  schedulingPolicy = other860.schedulingPolicy;
  __isset = other860.__isset;
}
WMPool& WMPool::operator=(const WMPool& other861) {
  resourcePlanName = other861.resourcePlanName;
  poolPath = other861.poolPath;
  allocFraction = other861.allocFraction;
  queryParallelism = other861.queryParallelism;
  schedulingPolicy = other861.schedulingPolicy;
  __isset = other861.__isset;
  return *this;
}
void WMPool::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMPool(";
  out << "resourcePlanName=" << to_string(resourcePlanName);
  out << ", " << "poolPath=" << to_string(poolPath);
  out << ", " << "allocFraction="; (__isset.allocFraction ? (out << to_string(allocFraction)) : (out << "<null>"));
  out << ", " << "queryParallelism="; (__isset.queryParallelism ? (out << to_string(queryParallelism)) : (out << "<null>"));
  out << ", " << "schedulingPolicy="; (__isset.schedulingPolicy ? (out << to_string(schedulingPolicy)) : (out << "<null>"));
  out << ")";
}


WMTrigger::~WMTrigger() noexcept {
}


void WMTrigger::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
}

void WMTrigger::__set_triggerName(const std::string& val) {
  this->triggerName = val;
}

void WMTrigger::__set_triggerExpression(const std::string& val) {
  this->triggerExpression = val;
__isset.triggerExpression = true;
}

void WMTrigger::__set_actionExpression(const std::string& val) {
  this->actionExpression = val;
__isset.actionExpression = true;
}
std::ostream& operator<<(std::ostream& out, const WMTrigger& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMTrigger::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resourcePlanName = false;
  bool isset_triggerName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          isset_resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->triggerName);
          isset_triggerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->triggerExpression);
          this->__isset.triggerExpression = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->actionExpression);
          this->__isset.actionExpression = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resourcePlanName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_triggerName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WMTrigger::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMTrigger");

  xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->resourcePlanName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("triggerName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->triggerName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.triggerExpression) {
    xfer += oprot->writeFieldBegin("triggerExpression", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->triggerExpression);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.actionExpression) {
    xfer += oprot->writeFieldBegin("actionExpression", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->actionExpression);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMTrigger &a, WMTrigger &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.triggerName, b.triggerName);
  swap(a.triggerExpression, b.triggerExpression);
  swap(a.actionExpression, b.actionExpression);
  swap(a.__isset, b.__isset);
}

WMTrigger::WMTrigger(const WMTrigger& other862) {
  resourcePlanName = other862.resourcePlanName;
  triggerName = other862.triggerName;
  triggerExpression = other862.triggerExpression;
  actionExpression = other862.actionExpression;
  __isset = other862.__isset;
}
WMTrigger& WMTrigger::operator=(const WMTrigger& other863) {
  resourcePlanName = other863.resourcePlanName;
  triggerName = other863.triggerName;
  triggerExpression = other863.triggerExpression;
  actionExpression = other863.actionExpression;
  __isset = other863.__isset;
  return *this;
}
void WMTrigger::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMTrigger(";
  out << "resourcePlanName=" << to_string(resourcePlanName);
  out << ", " << "triggerName=" << to_string(triggerName);
  out << ", " << "triggerExpression="; (__isset.triggerExpression ? (out << to_string(triggerExpression)) : (out << "<null>"));
  out << ", " << "actionExpression="; (__isset.actionExpression ? (out << to_string(actionExpression)) : (out << "<null>"));
  out << ")";
}


WMMapping::~WMMapping() noexcept {
}


void WMMapping::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
}

void WMMapping::__set_entityType(const std::string& val) {
  this->entityType = val;
}

void WMMapping::__set_entityName(const std::string& val) {
  this->entityName = val;
}

void WMMapping::__set_poolName(const std::string& val) {
  this->poolName = val;
__isset.poolName = true;
}

void WMMapping::__set_ordering(const int32_t val) {
  this->ordering = val;
__isset.ordering = true;
}
std::ostream& operator<<(std::ostream& out, const WMMapping& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMMapping::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resourcePlanName = false;
  bool isset_entityType = false;
  bool isset_entityName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          isset_resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->entityType);
          isset_entityType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->entityName);
          isset_entityName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->poolName);
          this->__isset.poolName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ordering);
          this->__isset.ordering = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resourcePlanName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_entityType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_entityName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WMMapping::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMMapping");

  xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->resourcePlanName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entityType", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->entityType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entityName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->entityName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.poolName) {
    xfer += oprot->writeFieldBegin("poolName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->poolName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ordering) {
    xfer += oprot->writeFieldBegin("ordering", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->ordering);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMMapping &a, WMMapping &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.entityType, b.entityType);
  swap(a.entityName, b.entityName);
  swap(a.poolName, b.poolName);
  swap(a.ordering, b.ordering);
  swap(a.__isset, b.__isset);
}

WMMapping::WMMapping(const WMMapping& other864) {
  resourcePlanName = other864.resourcePlanName;
  entityType = other864.entityType;
  entityName = other864.entityName;
  poolName = other864.poolName;
  ordering = other864.ordering;
  __isset = other864.__isset;
}
WMMapping& WMMapping::operator=(const WMMapping& other865) {
  resourcePlanName = other865.resourcePlanName;
  entityType = other865.entityType;
  entityName = other865.entityName;
  poolName = other865.poolName;
  ordering = other865.ordering;
  __isset = other865.__isset;
  return *this;
}
void WMMapping::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMMapping(";
  out << "resourcePlanName=" << to_string(resourcePlanName);
  out << ", " << "entityType=" << to_string(entityType);
  out << ", " << "entityName=" << to_string(entityName);
  out << ", " << "poolName="; (__isset.poolName ? (out << to_string(poolName)) : (out << "<null>"));
  out << ", " << "ordering="; (__isset.ordering ? (out << to_string(ordering)) : (out << "<null>"));
  out << ")";
}


WMPoolTrigger::~WMPoolTrigger() noexcept {
}


void WMPoolTrigger::__set_pool(const std::string& val) {
  this->pool = val;
}

void WMPoolTrigger::__set_trigger(const std::string& val) {
  this->trigger = val;
}
std::ostream& operator<<(std::ostream& out, const WMPoolTrigger& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMPoolTrigger::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_pool = false;
  bool isset_trigger = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pool);
          isset_pool = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->trigger);
          isset_trigger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_pool)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_trigger)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WMPoolTrigger::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMPoolTrigger");

  xfer += oprot->writeFieldBegin("pool", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->pool);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("trigger", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->trigger);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMPoolTrigger &a, WMPoolTrigger &b) {
  using ::std::swap;
  swap(a.pool, b.pool);
  swap(a.trigger, b.trigger);
}

WMPoolTrigger::WMPoolTrigger(const WMPoolTrigger& other866) {
  pool = other866.pool;
  trigger = other866.trigger;
}
WMPoolTrigger& WMPoolTrigger::operator=(const WMPoolTrigger& other867) {
  pool = other867.pool;
  trigger = other867.trigger;
  return *this;
}
void WMPoolTrigger::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMPoolTrigger(";
  out << "pool=" << to_string(pool);
  out << ", " << "trigger=" << to_string(trigger);
  out << ")";
}


WMFullResourcePlan::~WMFullResourcePlan() noexcept {
}


void WMFullResourcePlan::__set_plan(const WMResourcePlan& val) {
  this->plan = val;
}

void WMFullResourcePlan::__set_pools(const std::vector<WMPool> & val) {
  this->pools = val;
}

void WMFullResourcePlan::__set_mappings(const std::vector<WMMapping> & val) {
  this->mappings = val;
__isset.mappings = true;
}

void WMFullResourcePlan::__set_triggers(const std::vector<WMTrigger> & val) {
  this->triggers = val;
__isset.triggers = true;
}

void WMFullResourcePlan::__set_poolTriggers(const std::vector<WMPoolTrigger> & val) {
  this->poolTriggers = val;
__isset.poolTriggers = true;
}
std::ostream& operator<<(std::ostream& out, const WMFullResourcePlan& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMFullResourcePlan::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_plan = false;
  bool isset_pools = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->plan.read(iprot);
          isset_plan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pools.clear();
            uint32_t _size868;
            ::apache::thrift::protocol::TType _etype871;
            xfer += iprot->readListBegin(_etype871, _size868);
            this->pools.resize(_size868);
            uint32_t _i872;
            for (_i872 = 0; _i872 < _size868; ++_i872)
            {
              xfer += this->pools[_i872].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_pools = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->mappings.clear();
            uint32_t _size873;
            ::apache::thrift::protocol::TType _etype876;
            xfer += iprot->readListBegin(_etype876, _size873);
            this->mappings.resize(_size873);
            uint32_t _i877;
            for (_i877 = 0; _i877 < _size873; ++_i877)
            {
              xfer += this->mappings[_i877].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.mappings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->triggers.clear();
            uint32_t _size878;
            ::apache::thrift::protocol::TType _etype881;
            xfer += iprot->readListBegin(_etype881, _size878);
            this->triggers.resize(_size878);
            uint32_t _i882;
            for (_i882 = 0; _i882 < _size878; ++_i882)
            {
              xfer += this->triggers[_i882].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.triggers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->poolTriggers.clear();
            uint32_t _size883;
            ::apache::thrift::protocol::TType _etype886;
            xfer += iprot->readListBegin(_etype886, _size883);
            this->poolTriggers.resize(_size883);
            uint32_t _i887;
            for (_i887 = 0; _i887 < _size883; ++_i887)
            {
              xfer += this->poolTriggers[_i887].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.poolTriggers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_plan)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_pools)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WMFullResourcePlan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMFullResourcePlan");

  xfer += oprot->writeFieldBegin("plan", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->plan.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pools", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->pools.size()));
    std::vector<WMPool> ::const_iterator _iter888;
    for (_iter888 = this->pools.begin(); _iter888 != this->pools.end(); ++_iter888)
    {
      xfer += (*_iter888).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.mappings) {
    xfer += oprot->writeFieldBegin("mappings", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->mappings.size()));
      std::vector<WMMapping> ::const_iterator _iter889;
      for (_iter889 = this->mappings.begin(); _iter889 != this->mappings.end(); ++_iter889)
      {
        xfer += (*_iter889).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.triggers) {
    xfer += oprot->writeFieldBegin("triggers", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->triggers.size()));
      std::vector<WMTrigger> ::const_iterator _iter890;
      for (_iter890 = this->triggers.begin(); _iter890 != this->triggers.end(); ++_iter890)
      {
        xfer += (*_iter890).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.poolTriggers) {
    xfer += oprot->writeFieldBegin("poolTriggers", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->poolTriggers.size()));
      std::vector<WMPoolTrigger> ::const_iterator _iter891;
      for (_iter891 = this->poolTriggers.begin(); _iter891 != this->poolTriggers.end(); ++_iter891)
      {
        xfer += (*_iter891).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMFullResourcePlan &a, WMFullResourcePlan &b) {
  using ::std::swap;
  swap(a.plan, b.plan);
  swap(a.pools, b.pools);
  swap(a.mappings, b.mappings);
  swap(a.triggers, b.triggers);
  swap(a.poolTriggers, b.poolTriggers);
  swap(a.__isset, b.__isset);
}

WMFullResourcePlan::WMFullResourcePlan(const WMFullResourcePlan& other892) {
  plan = other892.plan;
  pools = other892.pools;
  mappings = other892.mappings;
  triggers = other892.triggers;
  poolTriggers = other892.poolTriggers;
  __isset = other892.__isset;
}
WMFullResourcePlan& WMFullResourcePlan::operator=(const WMFullResourcePlan& other893) {
  plan = other893.plan;
  pools = other893.pools;
  mappings = other893.mappings;
  triggers = other893.triggers;
  poolTriggers = other893.poolTriggers;
  __isset = other893.__isset;
  return *this;
}
void WMFullResourcePlan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMFullResourcePlan(";
  out << "plan=" << to_string(plan);
  out << ", " << "pools=" << to_string(pools);
  out << ", " << "mappings="; (__isset.mappings ? (out << to_string(mappings)) : (out << "<null>"));
  out << ", " << "triggers="; (__isset.triggers ? (out << to_string(triggers)) : (out << "<null>"));
  out << ", " << "poolTriggers="; (__isset.poolTriggers ? (out << to_string(poolTriggers)) : (out << "<null>"));
  out << ")";
}


WMCreateResourcePlanRequest::~WMCreateResourcePlanRequest() noexcept {
}


void WMCreateResourcePlanRequest::__set_resourcePlan(const WMResourcePlan& val) {
  this->resourcePlan = val;
__isset.resourcePlan = true;
}
std::ostream& operator<<(std::ostream& out, const WMCreateResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreateResourcePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resourcePlan.read(iprot);
          this->__isset.resourcePlan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreateResourcePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreateResourcePlanRequest");

  if (this->__isset.resourcePlan) {
    xfer += oprot->writeFieldBegin("resourcePlan", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->resourcePlan.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreateResourcePlanRequest &a, WMCreateResourcePlanRequest &b) {
  using ::std::swap;
  swap(a.resourcePlan, b.resourcePlan);
  swap(a.__isset, b.__isset);
}

WMCreateResourcePlanRequest::WMCreateResourcePlanRequest(const WMCreateResourcePlanRequest& other894) {
  resourcePlan = other894.resourcePlan;
  __isset = other894.__isset;
}
WMCreateResourcePlanRequest& WMCreateResourcePlanRequest::operator=(const WMCreateResourcePlanRequest& other895) {
  resourcePlan = other895.resourcePlan;
  __isset = other895.__isset;
  return *this;
}
void WMCreateResourcePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreateResourcePlanRequest(";
  out << "resourcePlan="; (__isset.resourcePlan ? (out << to_string(resourcePlan)) : (out << "<null>"));
  out << ")";
}


WMCreateResourcePlanResponse::~WMCreateResourcePlanResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMCreateResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreateResourcePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreateResourcePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreateResourcePlanResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreateResourcePlanResponse &a, WMCreateResourcePlanResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMCreateResourcePlanResponse::WMCreateResourcePlanResponse(const WMCreateResourcePlanResponse& other896) {
  (void) other896;
}
WMCreateResourcePlanResponse& WMCreateResourcePlanResponse::operator=(const WMCreateResourcePlanResponse& other897) {
  (void) other897;
  return *this;
}
void WMCreateResourcePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreateResourcePlanResponse(";
  out << ")";
}


WMGetActiveResourcePlanRequest::~WMGetActiveResourcePlanRequest() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMGetActiveResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetActiveResourcePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetActiveResourcePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetActiveResourcePlanRequest");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetActiveResourcePlanRequest &a, WMGetActiveResourcePlanRequest &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMGetActiveResourcePlanRequest::WMGetActiveResourcePlanRequest(const WMGetActiveResourcePlanRequest& other898) {
  (void) other898;
}
WMGetActiveResourcePlanRequest& WMGetActiveResourcePlanRequest::operator=(const WMGetActiveResourcePlanRequest& other899) {
  (void) other899;
  return *this;
}
void WMGetActiveResourcePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetActiveResourcePlanRequest(";
  out << ")";
}


WMGetActiveResourcePlanResponse::~WMGetActiveResourcePlanResponse() noexcept {
}


void WMGetActiveResourcePlanResponse::__set_resourcePlan(const WMFullResourcePlan& val) {
  this->resourcePlan = val;
__isset.resourcePlan = true;
}
std::ostream& operator<<(std::ostream& out, const WMGetActiveResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetActiveResourcePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resourcePlan.read(iprot);
          this->__isset.resourcePlan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetActiveResourcePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetActiveResourcePlanResponse");

  if (this->__isset.resourcePlan) {
    xfer += oprot->writeFieldBegin("resourcePlan", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->resourcePlan.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetActiveResourcePlanResponse &a, WMGetActiveResourcePlanResponse &b) {
  using ::std::swap;
  swap(a.resourcePlan, b.resourcePlan);
  swap(a.__isset, b.__isset);
}

WMGetActiveResourcePlanResponse::WMGetActiveResourcePlanResponse(const WMGetActiveResourcePlanResponse& other900) {
  resourcePlan = other900.resourcePlan;
  __isset = other900.__isset;
}
WMGetActiveResourcePlanResponse& WMGetActiveResourcePlanResponse::operator=(const WMGetActiveResourcePlanResponse& other901) {
  resourcePlan = other901.resourcePlan;
  __isset = other901.__isset;
  return *this;
}
void WMGetActiveResourcePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetActiveResourcePlanResponse(";
  out << "resourcePlan="; (__isset.resourcePlan ? (out << to_string(resourcePlan)) : (out << "<null>"));
  out << ")";
}


WMGetResourcePlanRequest::~WMGetResourcePlanRequest() noexcept {
}


void WMGetResourcePlanRequest::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
__isset.resourcePlanName = true;
}
std::ostream& operator<<(std::ostream& out, const WMGetResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetResourcePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          this->__isset.resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetResourcePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetResourcePlanRequest");

  if (this->__isset.resourcePlanName) {
    xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resourcePlanName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetResourcePlanRequest &a, WMGetResourcePlanRequest &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.__isset, b.__isset);
}

WMGetResourcePlanRequest::WMGetResourcePlanRequest(const WMGetResourcePlanRequest& other902) {
  resourcePlanName = other902.resourcePlanName;
  __isset = other902.__isset;
}
WMGetResourcePlanRequest& WMGetResourcePlanRequest::operator=(const WMGetResourcePlanRequest& other903) {
  resourcePlanName = other903.resourcePlanName;
  __isset = other903.__isset;
  return *this;
}
void WMGetResourcePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetResourcePlanRequest(";
  out << "resourcePlanName="; (__isset.resourcePlanName ? (out << to_string(resourcePlanName)) : (out << "<null>"));
  out << ")";
}


WMGetResourcePlanResponse::~WMGetResourcePlanResponse() noexcept {
}


void WMGetResourcePlanResponse::__set_resourcePlan(const WMResourcePlan& val) {
  this->resourcePlan = val;
__isset.resourcePlan = true;
}
std::ostream& operator<<(std::ostream& out, const WMGetResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetResourcePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resourcePlan.read(iprot);
          this->__isset.resourcePlan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetResourcePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetResourcePlanResponse");

  if (this->__isset.resourcePlan) {
    xfer += oprot->writeFieldBegin("resourcePlan", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->resourcePlan.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetResourcePlanResponse &a, WMGetResourcePlanResponse &b) {
  using ::std::swap;
  swap(a.resourcePlan, b.resourcePlan);
  swap(a.__isset, b.__isset);
}

WMGetResourcePlanResponse::WMGetResourcePlanResponse(const WMGetResourcePlanResponse& other904) {
  resourcePlan = other904.resourcePlan;
  __isset = other904.__isset;
}
WMGetResourcePlanResponse& WMGetResourcePlanResponse::operator=(const WMGetResourcePlanResponse& other905) {
  resourcePlan = other905.resourcePlan;
  __isset = other905.__isset;
  return *this;
}
void WMGetResourcePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetResourcePlanResponse(";
  out << "resourcePlan="; (__isset.resourcePlan ? (out << to_string(resourcePlan)) : (out << "<null>"));
  out << ")";
}


WMGetAllResourcePlanRequest::~WMGetAllResourcePlanRequest() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMGetAllResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetAllResourcePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetAllResourcePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetAllResourcePlanRequest");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetAllResourcePlanRequest &a, WMGetAllResourcePlanRequest &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMGetAllResourcePlanRequest::WMGetAllResourcePlanRequest(const WMGetAllResourcePlanRequest& other906) {
  (void) other906;
}
WMGetAllResourcePlanRequest& WMGetAllResourcePlanRequest::operator=(const WMGetAllResourcePlanRequest& other907) {
  (void) other907;
  return *this;
}
void WMGetAllResourcePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetAllResourcePlanRequest(";
  out << ")";
}


WMGetAllResourcePlanResponse::~WMGetAllResourcePlanResponse() noexcept {
}


void WMGetAllResourcePlanResponse::__set_resourcePlans(const std::vector<WMResourcePlan> & val) {
  this->resourcePlans = val;
__isset.resourcePlans = true;
}
std::ostream& operator<<(std::ostream& out, const WMGetAllResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetAllResourcePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->resourcePlans.clear();
            uint32_t _size908;
            ::apache::thrift::protocol::TType _etype911;
            xfer += iprot->readListBegin(_etype911, _size908);
            this->resourcePlans.resize(_size908);
            uint32_t _i912;
            for (_i912 = 0; _i912 < _size908; ++_i912)
            {
              xfer += this->resourcePlans[_i912].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.resourcePlans = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetAllResourcePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetAllResourcePlanResponse");

  if (this->__isset.resourcePlans) {
    xfer += oprot->writeFieldBegin("resourcePlans", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->resourcePlans.size()));
      std::vector<WMResourcePlan> ::const_iterator _iter913;
      for (_iter913 = this->resourcePlans.begin(); _iter913 != this->resourcePlans.end(); ++_iter913)
      {
        xfer += (*_iter913).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetAllResourcePlanResponse &a, WMGetAllResourcePlanResponse &b) {
  using ::std::swap;
  swap(a.resourcePlans, b.resourcePlans);
  swap(a.__isset, b.__isset);
}

WMGetAllResourcePlanResponse::WMGetAllResourcePlanResponse(const WMGetAllResourcePlanResponse& other914) {
  resourcePlans = other914.resourcePlans;
  __isset = other914.__isset;
}
WMGetAllResourcePlanResponse& WMGetAllResourcePlanResponse::operator=(const WMGetAllResourcePlanResponse& other915) {
  resourcePlans = other915.resourcePlans;
  __isset = other915.__isset;
  return *this;
}
void WMGetAllResourcePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetAllResourcePlanResponse(";
  out << "resourcePlans="; (__isset.resourcePlans ? (out << to_string(resourcePlans)) : (out << "<null>"));
  out << ")";
}


WMAlterResourcePlanRequest::~WMAlterResourcePlanRequest() noexcept {
}


void WMAlterResourcePlanRequest::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
__isset.resourcePlanName = true;
}

void WMAlterResourcePlanRequest::__set_resourcePlan(const WMResourcePlan& val) {
  this->resourcePlan = val;
__isset.resourcePlan = true;
}

void WMAlterResourcePlanRequest::__set_isEnableAndActivate(const bool val) {
  this->isEnableAndActivate = val;
__isset.isEnableAndActivate = true;
}
std::ostream& operator<<(std::ostream& out, const WMAlterResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMAlterResourcePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          this->__isset.resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resourcePlan.read(iprot);
          this->__isset.resourcePlan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isEnableAndActivate);
          this->__isset.isEnableAndActivate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMAlterResourcePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMAlterResourcePlanRequest");

  if (this->__isset.resourcePlanName) {
    xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resourcePlanName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resourcePlan) {
    xfer += oprot->writeFieldBegin("resourcePlan", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->resourcePlan.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isEnableAndActivate) {
    xfer += oprot->writeFieldBegin("isEnableAndActivate", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->isEnableAndActivate);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMAlterResourcePlanRequest &a, WMAlterResourcePlanRequest &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.resourcePlan, b.resourcePlan);
  swap(a.isEnableAndActivate, b.isEnableAndActivate);
  swap(a.__isset, b.__isset);
}

WMAlterResourcePlanRequest::WMAlterResourcePlanRequest(const WMAlterResourcePlanRequest& other916) {
  resourcePlanName = other916.resourcePlanName;
  resourcePlan = other916.resourcePlan;
  isEnableAndActivate = other916.isEnableAndActivate;
  __isset = other916.__isset;
}
WMAlterResourcePlanRequest& WMAlterResourcePlanRequest::operator=(const WMAlterResourcePlanRequest& other917) {
  resourcePlanName = other917.resourcePlanName;
  resourcePlan = other917.resourcePlan;
  isEnableAndActivate = other917.isEnableAndActivate;
  __isset = other917.__isset;
  return *this;
}
void WMAlterResourcePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMAlterResourcePlanRequest(";
  out << "resourcePlanName="; (__isset.resourcePlanName ? (out << to_string(resourcePlanName)) : (out << "<null>"));
  out << ", " << "resourcePlan="; (__isset.resourcePlan ? (out << to_string(resourcePlan)) : (out << "<null>"));
  out << ", " << "isEnableAndActivate="; (__isset.isEnableAndActivate ? (out << to_string(isEnableAndActivate)) : (out << "<null>"));
  out << ")";
}


WMAlterResourcePlanResponse::~WMAlterResourcePlanResponse() noexcept {
}


void WMAlterResourcePlanResponse::__set_fullResourcePlan(const WMFullResourcePlan& val) {
  this->fullResourcePlan = val;
__isset.fullResourcePlan = true;
}
std::ostream& operator<<(std::ostream& out, const WMAlterResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMAlterResourcePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fullResourcePlan.read(iprot);
          this->__isset.fullResourcePlan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMAlterResourcePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMAlterResourcePlanResponse");

  if (this->__isset.fullResourcePlan) {
    xfer += oprot->writeFieldBegin("fullResourcePlan", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->fullResourcePlan.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMAlterResourcePlanResponse &a, WMAlterResourcePlanResponse &b) {
  using ::std::swap;
  swap(a.fullResourcePlan, b.fullResourcePlan);
  swap(a.__isset, b.__isset);
}

WMAlterResourcePlanResponse::WMAlterResourcePlanResponse(const WMAlterResourcePlanResponse& other918) {
  fullResourcePlan = other918.fullResourcePlan;
  __isset = other918.__isset;
}
WMAlterResourcePlanResponse& WMAlterResourcePlanResponse::operator=(const WMAlterResourcePlanResponse& other919) {
  fullResourcePlan = other919.fullResourcePlan;
  __isset = other919.__isset;
  return *this;
}
void WMAlterResourcePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMAlterResourcePlanResponse(";
  out << "fullResourcePlan="; (__isset.fullResourcePlan ? (out << to_string(fullResourcePlan)) : (out << "<null>"));
  out << ")";
}


WMValidateResourcePlanRequest::~WMValidateResourcePlanRequest() noexcept {
}


void WMValidateResourcePlanRequest::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
__isset.resourcePlanName = true;
}
std::ostream& operator<<(std::ostream& out, const WMValidateResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMValidateResourcePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          this->__isset.resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMValidateResourcePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMValidateResourcePlanRequest");

  if (this->__isset.resourcePlanName) {
    xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resourcePlanName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMValidateResourcePlanRequest &a, WMValidateResourcePlanRequest &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.__isset, b.__isset);
}

WMValidateResourcePlanRequest::WMValidateResourcePlanRequest(const WMValidateResourcePlanRequest& other920) {
  resourcePlanName = other920.resourcePlanName;
  __isset = other920.__isset;
}
WMValidateResourcePlanRequest& WMValidateResourcePlanRequest::operator=(const WMValidateResourcePlanRequest& other921) {
  resourcePlanName = other921.resourcePlanName;
  __isset = other921.__isset;
  return *this;
}
void WMValidateResourcePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMValidateResourcePlanRequest(";
  out << "resourcePlanName="; (__isset.resourcePlanName ? (out << to_string(resourcePlanName)) : (out << "<null>"));
  out << ")";
}


WMValidateResourcePlanResponse::~WMValidateResourcePlanResponse() noexcept {
}


void WMValidateResourcePlanResponse::__set_isValid(const bool val) {
  this->isValid = val;
__isset.isValid = true;
}
std::ostream& operator<<(std::ostream& out, const WMValidateResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMValidateResourcePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isValid);
          this->__isset.isValid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMValidateResourcePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMValidateResourcePlanResponse");

  if (this->__isset.isValid) {
    xfer += oprot->writeFieldBegin("isValid", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->isValid);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMValidateResourcePlanResponse &a, WMValidateResourcePlanResponse &b) {
  using ::std::swap;
  swap(a.isValid, b.isValid);
  swap(a.__isset, b.__isset);
}

WMValidateResourcePlanResponse::WMValidateResourcePlanResponse(const WMValidateResourcePlanResponse& other922) {
  isValid = other922.isValid;
  __isset = other922.__isset;
}
WMValidateResourcePlanResponse& WMValidateResourcePlanResponse::operator=(const WMValidateResourcePlanResponse& other923) {
  isValid = other923.isValid;
  __isset = other923.__isset;
  return *this;
}
void WMValidateResourcePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMValidateResourcePlanResponse(";
  out << "isValid="; (__isset.isValid ? (out << to_string(isValid)) : (out << "<null>"));
  out << ")";
}


WMDropResourcePlanRequest::~WMDropResourcePlanRequest() noexcept {
}


void WMDropResourcePlanRequest::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
__isset.resourcePlanName = true;
}
std::ostream& operator<<(std::ostream& out, const WMDropResourcePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMDropResourcePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          this->__isset.resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMDropResourcePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMDropResourcePlanRequest");

  if (this->__isset.resourcePlanName) {
    xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resourcePlanName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMDropResourcePlanRequest &a, WMDropResourcePlanRequest &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.__isset, b.__isset);
}

WMDropResourcePlanRequest::WMDropResourcePlanRequest(const WMDropResourcePlanRequest& other924) {
  resourcePlanName = other924.resourcePlanName;
  __isset = other924.__isset;
}
WMDropResourcePlanRequest& WMDropResourcePlanRequest::operator=(const WMDropResourcePlanRequest& other925) {
  resourcePlanName = other925.resourcePlanName;
  __isset = other925.__isset;
  return *this;
}
void WMDropResourcePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMDropResourcePlanRequest(";
  out << "resourcePlanName="; (__isset.resourcePlanName ? (out << to_string(resourcePlanName)) : (out << "<null>"));
  out << ")";
}


WMDropResourcePlanResponse::~WMDropResourcePlanResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMDropResourcePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMDropResourcePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMDropResourcePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMDropResourcePlanResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMDropResourcePlanResponse &a, WMDropResourcePlanResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMDropResourcePlanResponse::WMDropResourcePlanResponse(const WMDropResourcePlanResponse& other926) {
  (void) other926;
}
WMDropResourcePlanResponse& WMDropResourcePlanResponse::operator=(const WMDropResourcePlanResponse& other927) {
  (void) other927;
  return *this;
}
void WMDropResourcePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMDropResourcePlanResponse(";
  out << ")";
}


WMCreateTriggerRequest::~WMCreateTriggerRequest() noexcept {
}


void WMCreateTriggerRequest::__set_trigger(const WMTrigger& val) {
  this->trigger = val;
__isset.trigger = true;
}
std::ostream& operator<<(std::ostream& out, const WMCreateTriggerRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreateTriggerRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->trigger.read(iprot);
          this->__isset.trigger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreateTriggerRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreateTriggerRequest");

  if (this->__isset.trigger) {
    xfer += oprot->writeFieldBegin("trigger", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->trigger.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreateTriggerRequest &a, WMCreateTriggerRequest &b) {
  using ::std::swap;
  swap(a.trigger, b.trigger);
  swap(a.__isset, b.__isset);
}

WMCreateTriggerRequest::WMCreateTriggerRequest(const WMCreateTriggerRequest& other928) {
  trigger = other928.trigger;
  __isset = other928.__isset;
}
WMCreateTriggerRequest& WMCreateTriggerRequest::operator=(const WMCreateTriggerRequest& other929) {
  trigger = other929.trigger;
  __isset = other929.__isset;
  return *this;
}
void WMCreateTriggerRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreateTriggerRequest(";
  out << "trigger="; (__isset.trigger ? (out << to_string(trigger)) : (out << "<null>"));
  out << ")";
}


WMCreateTriggerResponse::~WMCreateTriggerResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMCreateTriggerResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMCreateTriggerResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMCreateTriggerResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMCreateTriggerResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMCreateTriggerResponse &a, WMCreateTriggerResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMCreateTriggerResponse::WMCreateTriggerResponse(const WMCreateTriggerResponse& other930) {
  (void) other930;
}
WMCreateTriggerResponse& WMCreateTriggerResponse::operator=(const WMCreateTriggerResponse& other931) {
  (void) other931;
  return *this;
}
void WMCreateTriggerResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMCreateTriggerResponse(";
  out << ")";
}


WMAlterTriggerRequest::~WMAlterTriggerRequest() noexcept {
}


void WMAlterTriggerRequest::__set_trigger(const WMTrigger& val) {
  this->trigger = val;
__isset.trigger = true;
}
std::ostream& operator<<(std::ostream& out, const WMAlterTriggerRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMAlterTriggerRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->trigger.read(iprot);
          this->__isset.trigger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMAlterTriggerRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMAlterTriggerRequest");

  if (this->__isset.trigger) {
    xfer += oprot->writeFieldBegin("trigger", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->trigger.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMAlterTriggerRequest &a, WMAlterTriggerRequest &b) {
  using ::std::swap;
  swap(a.trigger, b.trigger);
  swap(a.__isset, b.__isset);
}

WMAlterTriggerRequest::WMAlterTriggerRequest(const WMAlterTriggerRequest& other932) {
  trigger = other932.trigger;
  __isset = other932.__isset;
}
WMAlterTriggerRequest& WMAlterTriggerRequest::operator=(const WMAlterTriggerRequest& other933) {
  trigger = other933.trigger;
  __isset = other933.__isset;
  return *this;
}
void WMAlterTriggerRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMAlterTriggerRequest(";
  out << "trigger="; (__isset.trigger ? (out << to_string(trigger)) : (out << "<null>"));
  out << ")";
}


WMAlterTriggerResponse::~WMAlterTriggerResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMAlterTriggerResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMAlterTriggerResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMAlterTriggerResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMAlterTriggerResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMAlterTriggerResponse &a, WMAlterTriggerResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMAlterTriggerResponse::WMAlterTriggerResponse(const WMAlterTriggerResponse& other934) {
  (void) other934;
}
WMAlterTriggerResponse& WMAlterTriggerResponse::operator=(const WMAlterTriggerResponse& other935) {
  (void) other935;
  return *this;
}
void WMAlterTriggerResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMAlterTriggerResponse(";
  out << ")";
}


WMDropTriggerRequest::~WMDropTriggerRequest() noexcept {
}


void WMDropTriggerRequest::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
__isset.resourcePlanName = true;
}

void WMDropTriggerRequest::__set_triggerName(const std::string& val) {
  this->triggerName = val;
__isset.triggerName = true;
}
std::ostream& operator<<(std::ostream& out, const WMDropTriggerRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMDropTriggerRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          this->__isset.resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->triggerName);
          this->__isset.triggerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMDropTriggerRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMDropTriggerRequest");

  if (this->__isset.resourcePlanName) {
    xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resourcePlanName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.triggerName) {
    xfer += oprot->writeFieldBegin("triggerName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->triggerName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMDropTriggerRequest &a, WMDropTriggerRequest &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.triggerName, b.triggerName);
  swap(a.__isset, b.__isset);
}

WMDropTriggerRequest::WMDropTriggerRequest(const WMDropTriggerRequest& other936) {
  resourcePlanName = other936.resourcePlanName;
  triggerName = other936.triggerName;
  __isset = other936.__isset;
}
WMDropTriggerRequest& WMDropTriggerRequest::operator=(const WMDropTriggerRequest& other937) {
  resourcePlanName = other937.resourcePlanName;
  triggerName = other937.triggerName;
  __isset = other937.__isset;
  return *this;
}
void WMDropTriggerRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMDropTriggerRequest(";
  out << "resourcePlanName="; (__isset.resourcePlanName ? (out << to_string(resourcePlanName)) : (out << "<null>"));
  out << ", " << "triggerName="; (__isset.triggerName ? (out << to_string(triggerName)) : (out << "<null>"));
  out << ")";
}


WMDropTriggerResponse::~WMDropTriggerResponse() noexcept {
}

std::ostream& operator<<(std::ostream& out, const WMDropTriggerResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMDropTriggerResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMDropTriggerResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMDropTriggerResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMDropTriggerResponse &a, WMDropTriggerResponse &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WMDropTriggerResponse::WMDropTriggerResponse(const WMDropTriggerResponse& other938) {
  (void) other938;
}
WMDropTriggerResponse& WMDropTriggerResponse::operator=(const WMDropTriggerResponse& other939) {
  (void) other939;
  return *this;
}
void WMDropTriggerResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMDropTriggerResponse(";
  out << ")";
}


WMGetTriggersForResourePlanRequest::~WMGetTriggersForResourePlanRequest() noexcept {
}


void WMGetTriggersForResourePlanRequest::__set_resourcePlanName(const std::string& val) {
  this->resourcePlanName = val;
__isset.resourcePlanName = true;
}
std::ostream& operator<<(std::ostream& out, const WMGetTriggersForResourePlanRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetTriggersForResourePlanRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePlanName);
          this->__isset.resourcePlanName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetTriggersForResourePlanRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetTriggersForResourePlanRequest");

  if (this->__isset.resourcePlanName) {
    xfer += oprot->writeFieldBegin("resourcePlanName", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resourcePlanName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetTriggersForResourePlanRequest &a, WMGetTriggersForResourePlanRequest &b) {
  using ::std::swap;
  swap(a.resourcePlanName, b.resourcePlanName);
  swap(a.__isset, b.__isset);
}

WMGetTriggersForResourePlanRequest::WMGetTriggersForResourePlanRequest(const WMGetTriggersForResourePlanRequest& other940) {
  resourcePlanName = other940.resourcePlanName;
  __isset = other940.__isset;
}
WMGetTriggersForResourePlanRequest& WMGetTriggersForResourePlanRequest::operator=(const WMGetTriggersForResourePlanRequest& other941) {
  resourcePlanName = other941.resourcePlanName;
  __isset = other941.__isset;
  return *this;
}
void WMGetTriggersForResourePlanRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetTriggersForResourePlanRequest(";
  out << "resourcePlanName="; (__isset.resourcePlanName ? (out << to_string(resourcePlanName)) : (out << "<null>"));
  out << ")";
}


WMGetTriggersForResourePlanResponse::~WMGetTriggersForResourePlanResponse() noexcept {
}


void WMGetTriggersForResourePlanResponse::__set_triggers(const std::vector<WMTrigger> & val) {
  this->triggers = val;
__isset.triggers = true;
}
std::ostream& operator<<(std::ostream& out, const WMGetTriggersForResourePlanResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WMGetTriggersForResourePlanResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->triggers.clear();
            uint32_t _size942;
            ::apache::thrift::protocol::TType _etype945;
            xfer += iprot->readListBegin(_etype945, _size942);
            this->triggers.resize(_size942);
            uint32_t _i946;
            for (_i946 = 0; _i946 < _size942; ++_i946)
            {
              xfer += this->triggers[_i946].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.triggers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WMGetTriggersForResourePlanResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WMGetTriggersForResourePlanResponse");

  if (this->__isset.triggers) {
    xfer += oprot->writeFieldBegin("triggers", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->triggers.size()));
      std::vector<WMTrigger> ::const_iterator _iter947;
      for (_iter947 = this->triggers.begin(); _iter947 != this->triggers.end(); ++_iter947)
      {
        xfer += (*_iter947).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WMGetTriggersForResourePlanResponse &a, WMGetTriggersForResourePlanResponse &b) {
  using ::std::swap;
  swap(a.triggers, b.triggers);
  swap(a.__isset, b.__isset);
}

WMGetTriggersForResourePlanResponse::WMGetTriggersForResourePlanResponse(const WMGetTriggersForResourePlanResponse& other948) {
  triggers = other948.triggers;
  __isset = other948.__isset;
}
WMGetTriggersForResourePlanResponse& WMGetTriggersForResourePlanResponse::operator=(const WMGetTriggersForResourePlanResponse& other949) {
  triggers = other949.triggers;
  __isset = other949.__isset;
  return *this;
}
void WMGetTriggersForResourePlanResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WMGetTriggersForResourePlanResponse(";
  out << "triggers="; (__isset.triggers ? (out << to_string(triggers)) : (out << "<null>"));
  out << ")";
}


MetaException::~MetaException() noexcept {
}


void MetaException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const MetaException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MetaException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MetaException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MetaException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MetaException &a, MetaException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

MetaException::MetaException(const MetaException& other950) : TException() {
  message = other950.message;
  __isset = other950.__isset;
}
MetaException& MetaException::operator=(const MetaException& other951) {
  message = other951.message;
  __isset = other951.__isset;
  return *this;
}
void MetaException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MetaException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* MetaException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: MetaException";
  }
}


UnknownTableException::~UnknownTableException() noexcept {
}


void UnknownTableException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const UnknownTableException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UnknownTableException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnknownTableException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnknownTableException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnknownTableException &a, UnknownTableException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

UnknownTableException::UnknownTableException(const UnknownTableException& other952) : TException() {
  message = other952.message;
  __isset = other952.__isset;
}
UnknownTableException& UnknownTableException::operator=(const UnknownTableException& other953) {
  message = other953.message;
  __isset = other953.__isset;
  return *this;
}
void UnknownTableException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnknownTableException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* UnknownTableException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: UnknownTableException";
  }
}


UnknownDBException::~UnknownDBException() noexcept {
}


void UnknownDBException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const UnknownDBException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UnknownDBException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnknownDBException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnknownDBException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnknownDBException &a, UnknownDBException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

UnknownDBException::UnknownDBException(const UnknownDBException& other954) : TException() {
  message = other954.message;
  __isset = other954.__isset;
}
UnknownDBException& UnknownDBException::operator=(const UnknownDBException& other955) {
  message = other955.message;
  __isset = other955.__isset;
  return *this;
}
void UnknownDBException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnknownDBException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* UnknownDBException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: UnknownDBException";
  }
}


AlreadyExistsException::~AlreadyExistsException() noexcept {
}


void AlreadyExistsException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const AlreadyExistsException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AlreadyExistsException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AlreadyExistsException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AlreadyExistsException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlreadyExistsException &a, AlreadyExistsException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

AlreadyExistsException::AlreadyExistsException(const AlreadyExistsException& other956) : TException() {
  message = other956.message;
  __isset = other956.__isset;
}
AlreadyExistsException& AlreadyExistsException::operator=(const AlreadyExistsException& other957) {
  message = other957.message;
  __isset = other957.__isset;
  return *this;
}
void AlreadyExistsException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AlreadyExistsException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* AlreadyExistsException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: AlreadyExistsException";
  }
}


InvalidPartitionException::~InvalidPartitionException() noexcept {
}


void InvalidPartitionException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const InvalidPartitionException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InvalidPartitionException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidPartitionException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidPartitionException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidPartitionException &a, InvalidPartitionException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

InvalidPartitionException::InvalidPartitionException(const InvalidPartitionException& other958) : TException() {
  message = other958.message;
  __isset = other958.__isset;
}
InvalidPartitionException& InvalidPartitionException::operator=(const InvalidPartitionException& other959) {
  message = other959.message;
  __isset = other959.__isset;
  return *this;
}
void InvalidPartitionException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidPartitionException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* InvalidPartitionException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidPartitionException";
  }
}


UnknownPartitionException::~UnknownPartitionException() noexcept {
}


void UnknownPartitionException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const UnknownPartitionException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UnknownPartitionException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnknownPartitionException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnknownPartitionException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnknownPartitionException &a, UnknownPartitionException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

UnknownPartitionException::UnknownPartitionException(const UnknownPartitionException& other960) : TException() {
  message = other960.message;
  __isset = other960.__isset;
}
UnknownPartitionException& UnknownPartitionException::operator=(const UnknownPartitionException& other961) {
  message = other961.message;
  __isset = other961.__isset;
  return *this;
}
void UnknownPartitionException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnknownPartitionException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* UnknownPartitionException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: UnknownPartitionException";
  }
}


InvalidObjectException::~InvalidObjectException() noexcept {
}


void InvalidObjectException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const InvalidObjectException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InvalidObjectException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidObjectException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidObjectException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidObjectException &a, InvalidObjectException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

InvalidObjectException::InvalidObjectException(const InvalidObjectException& other962) : TException() {
  message = other962.message;
  __isset = other962.__isset;
}
InvalidObjectException& InvalidObjectException::operator=(const InvalidObjectException& other963) {
  message = other963.message;
  __isset = other963.__isset;
  return *this;
}
void InvalidObjectException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidObjectException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* InvalidObjectException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidObjectException";
  }
}


NoSuchObjectException::~NoSuchObjectException() noexcept {
}


void NoSuchObjectException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const NoSuchObjectException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NoSuchObjectException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoSuchObjectException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoSuchObjectException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoSuchObjectException &a, NoSuchObjectException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NoSuchObjectException::NoSuchObjectException(const NoSuchObjectException& other964) : TException() {
  message = other964.message;
  __isset = other964.__isset;
}
NoSuchObjectException& NoSuchObjectException::operator=(const NoSuchObjectException& other965) {
  message = other965.message;
  __isset = other965.__isset;
  return *this;
}
void NoSuchObjectException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoSuchObjectException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* NoSuchObjectException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoSuchObjectException";
  }
}


IndexAlreadyExistsException::~IndexAlreadyExistsException() noexcept {
}


void IndexAlreadyExistsException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const IndexAlreadyExistsException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t IndexAlreadyExistsException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IndexAlreadyExistsException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IndexAlreadyExistsException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IndexAlreadyExistsException &a, IndexAlreadyExistsException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

IndexAlreadyExistsException::IndexAlreadyExistsException(const IndexAlreadyExistsException& other966) : TException() {
  message = other966.message;
  __isset = other966.__isset;
}
IndexAlreadyExistsException& IndexAlreadyExistsException::operator=(const IndexAlreadyExistsException& other967) {
  message = other967.message;
  __isset = other967.__isset;
  return *this;
}
void IndexAlreadyExistsException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IndexAlreadyExistsException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* IndexAlreadyExistsException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: IndexAlreadyExistsException";
  }
}


InvalidOperationException::~InvalidOperationException() noexcept {
}


void InvalidOperationException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const InvalidOperationException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InvalidOperationException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidOperationException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidOperationException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidOperationException &a, InvalidOperationException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

InvalidOperationException::InvalidOperationException(const InvalidOperationException& other968) : TException() {
  message = other968.message;
  __isset = other968.__isset;
}
InvalidOperationException& InvalidOperationException::operator=(const InvalidOperationException& other969) {
  message = other969.message;
  __isset = other969.__isset;
  return *this;
}
void InvalidOperationException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidOperationException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* InvalidOperationException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidOperationException";
  }
}


ConfigValSecurityException::~ConfigValSecurityException() noexcept {
}


void ConfigValSecurityException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const ConfigValSecurityException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ConfigValSecurityException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConfigValSecurityException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ConfigValSecurityException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ConfigValSecurityException &a, ConfigValSecurityException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

ConfigValSecurityException::ConfigValSecurityException(const ConfigValSecurityException& other970) : TException() {
  message = other970.message;
  __isset = other970.__isset;
}
ConfigValSecurityException& ConfigValSecurityException::operator=(const ConfigValSecurityException& other971) {
  message = other971.message;
  __isset = other971.__isset;
  return *this;
}
void ConfigValSecurityException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ConfigValSecurityException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* ConfigValSecurityException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: ConfigValSecurityException";
  }
}


InvalidInputException::~InvalidInputException() noexcept {
}


void InvalidInputException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const InvalidInputException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InvalidInputException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidInputException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidInputException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidInputException &a, InvalidInputException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

InvalidInputException::InvalidInputException(const InvalidInputException& other972) : TException() {
  message = other972.message;
  __isset = other972.__isset;
}
InvalidInputException& InvalidInputException::operator=(const InvalidInputException& other973) {
  message = other973.message;
  __isset = other973.__isset;
  return *this;
}
void InvalidInputException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidInputException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* InvalidInputException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidInputException";
  }
}


NoSuchTxnException::~NoSuchTxnException() noexcept {
}


void NoSuchTxnException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const NoSuchTxnException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NoSuchTxnException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoSuchTxnException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoSuchTxnException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoSuchTxnException &a, NoSuchTxnException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NoSuchTxnException::NoSuchTxnException(const NoSuchTxnException& other974) : TException() {
  message = other974.message;
  __isset = other974.__isset;
}
NoSuchTxnException& NoSuchTxnException::operator=(const NoSuchTxnException& other975) {
  message = other975.message;
  __isset = other975.__isset;
  return *this;
}
void NoSuchTxnException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoSuchTxnException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* NoSuchTxnException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoSuchTxnException";
  }
}


TxnAbortedException::~TxnAbortedException() noexcept {
}


void TxnAbortedException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const TxnAbortedException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TxnAbortedException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TxnAbortedException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TxnAbortedException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TxnAbortedException &a, TxnAbortedException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

TxnAbortedException::TxnAbortedException(const TxnAbortedException& other976) : TException() {
  message = other976.message;
  __isset = other976.__isset;
}
TxnAbortedException& TxnAbortedException::operator=(const TxnAbortedException& other977) {
  message = other977.message;
  __isset = other977.__isset;
  return *this;
}
void TxnAbortedException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TxnAbortedException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* TxnAbortedException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TxnAbortedException";
  }
}


TxnOpenException::~TxnOpenException() noexcept {
}


void TxnOpenException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const TxnOpenException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TxnOpenException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TxnOpenException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TxnOpenException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TxnOpenException &a, TxnOpenException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

TxnOpenException::TxnOpenException(const TxnOpenException& other978) : TException() {
  message = other978.message;
  __isset = other978.__isset;
}
TxnOpenException& TxnOpenException::operator=(const TxnOpenException& other979) {
  message = other979.message;
  __isset = other979.__isset;
  return *this;
}
void TxnOpenException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TxnOpenException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* TxnOpenException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TxnOpenException";
  }
}


NoSuchLockException::~NoSuchLockException() noexcept {
}


void NoSuchLockException::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const NoSuchLockException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NoSuchLockException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoSuchLockException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoSuchLockException");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoSuchLockException &a, NoSuchLockException &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NoSuchLockException::NoSuchLockException(const NoSuchLockException& other980) : TException() {
  message = other980.message;
  __isset = other980.__isset;
}
NoSuchLockException& NoSuchLockException::operator=(const NoSuchLockException& other981) {
  message = other981.message;
  __isset = other981.__isset;
  return *this;
}
void NoSuchLockException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoSuchLockException(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* NoSuchLockException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoSuchLockException";
  }
}

}}} // namespace
