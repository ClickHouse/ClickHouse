<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>praktika report</title>
    <link rel="icon" href="https://w4z3pajszlbkfcw2wcylfei5km0xmwag.lambda-url.us-east-1.on.aws/" type="image/x-icon">
    <style>

        /* Default (Day Theme) */
        :root {
            --background-color: white;
            --text-color: #000;
            --tile-background: #f9f9f9;
            --footer-background: #f1f1f1;
            --footer-text-color: #000;
            --status-width: 300px;
            --pending-bar-color: #f5e6a3;
            --skipped-bar-color: #ccc;
        }

        .hidden {
            transform: translateX(-100%); /* Moves status-container out of view */
        }

        .expanded {
            left: 10px !important; /* Move result-container to the left */
        }

        .button-moved {
            left: 0 !important; /* Move button to the left when sidebar is hidden */
        }

        body {
            background-color: var(--background-color);
            color: var(--text-color);
            height: 100%;
            margin: 0;
            display: flex;
            flex-direction: column;
            font-family: 'Source Code Pro', monospace, sans-serif;
            letter-spacing: -0.5px;
            --header-background-color: #f4f4f4;
            --link-color: blue;
            --link-hover-color: darkblue;
            --file-link-color: blue;
            --file-link-hover-color: darkblue;
        }

        body.night-theme {
            --background-color: #1F1F1C;
            --text-color: #dedede;
            --tile-background: #1F1F1C;
            --header-background-color: #1F1F1C;
            --pending-bar-color: #595801;
            --skipped-bar-color: #575757;
            --table-border-color: #444;
            --link-color: #ffea00;
            --link-hover-color: #ffaa00;
            --file-link-color: #007efc;
            --file-link-hover-color: #004d9a;
        }

        #status-container {
            position: fixed;
            top: 0;
            bottom: 40px;
            left: 0;
            width: var(--status-width);
            background-color: var(--tile-background);
            padding-left: 15px;
            padding-right: 15px;
            box-sizing: border-box;
            /*font-size: 18px;*/
            margin: 0;
            overflow-y: auto;
        }

        #toggle-status-bar {
            position: fixed;
            top: 40%;
            left: calc(var(--status-width));
            background-color: var(--pending-bar-color);
            color: var(--tile-background);
            border: none;
            padding: 20px 4px 20px 4px;
            cursor: pointer;
            border-top-right-radius: 8px;
            border-bottom-right-radius: 8px;
        }

        @media (min-width: 1200px) {
            #toggle-status-bar {
                display: none;
            }
        }

        .file-link {
            color: var(--file-link-color);
            font-weight: bold;
            font-size: 0.7em;
            font-family: 'Roboto Condensed', sans-serif;
            font-stretch: ultra-condensed;
            cursor: pointer;
            display: inline-block;
            margin-top: 5px;
            text-decoration: none;
        }

        .file-link:hover {
            color: var(--file-link-hover-color);
            text-decoration: none;
        }

        .key-value-pair {
            display: flex;               /* Enable Flexbox for alignment */
            justify-content: space-between; /* Distribute space between key and value */
            padding-bottom: 15px;
            padding-top: 15px;
        }

        .json-key {
            font-weight: bold;
        }

        .json-value {
            font-weight: normal;
            font-family: 'Source Code Pro', monospace, sans-serif;
        }
        .external-link {
            color: var(--file-link-color);
            font-family: 'Source Code Pro', monospace, sans-serif;
            cursor: pointer;
            display: inline-block;
            text-decoration: none;
        }

        .external-link:hover {
            color: var(--file-link-hover-color);
            text-decoration: underline;
        }
        .json-value-small {
            font-weight: normal;
            font-family: 'Source Code Pro', monospace, sans-serif;
            font-size: 0.75rem;
            justify-content: left;
        }
        .dropdown-value {
            width: 100px;
            font-weight: normal;
            font-family: inherit;
            background-color: transparent;
            color: inherit;
            /*border: none;*/
            /*outline: none;*/
            /*cursor: pointer;*/
        }

        #result-container {
            background-color: var(--tile-background);
            position: fixed;
            top: 0;
            bottom: 40px;
            left: calc(var(--status-width) + 10px); /* Align with status container */
            right: 0; /* Stretch to the right edge */

            padding: 0;
            box-sizing: border-box;
            font-weight: normal;

            overflow: auto;
            white-space: nowrap;
        }

        .info-text {
            white-space: normal; /* Allow text to wrap */
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 100%; /* Prevent overflow */
        }
        #info-content {
            text-align: left;
            padding: 10px;
        }

        #footer {
            padding: 10px;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: #1F1F1C;
            color: white;
            font-size: 14px;
            display: flex;
            justify-content: space-between; /* Ensure the .left expands, and .right and .settings are aligned to the right */
            align-items: center;
        }

        #footer a {
            color: white;
            text-decoration: none;
        }

        #footer .left {
            flex-grow: 1; /* Takes up all the available space */
        }

        #footer .left span.separator {
            margin-left: 5px;
            margin-right: 5px;
        }

        #footer .right, #footer .settings {
            display: flex;
            align-items: center;
            margin-right: 20px;
        }

        #footer .right a::before {
            content: "#";
            margin-left: 10px;
            color: #e0e0e0;
        }

        #footer .right::before, #footer .settings::before {
            content: "|"; /* Add separator before right and settings sections */
            margin-left: 0px;
            margin-right: 10px;
            color: #e0e0e0;
        }

        #theme-toggle {
            cursor: pointer;
            color: white;
        }

        #theme-toggle:hover {
            color: #e0e0e0;
        }

        #footer a:hover {
            text-decoration: underline;
        }

        table {
            table-layout: auto;
            border-collapse: collapse;
        }

        th.name-column, td.name-column {
            white-space: nowrap;
        }

        .name-column a {
            color: var(--link-color);
            text-decoration: underline;
            display: inline-block;
        }

        .name-column a:hover {
            color: var(--link-hover-color);
        }

        /* Non-clickable text should look similar but without underline */
        .name-column .disabled {
            color: var(--link-color); /* Same color as links */
            cursor: default; /* No pointer cursor */
            text-decoration: none; /* No underline */
        }

        th.status-column, td.status-column {
            white-space: nowrap; /* Prevent text from wrapping */
            overflow: hidden; /* Hide the overflowed text */
        }

        .status-column span[style*="pointer"] {
            text-decoration: underline;
        }

        th.time-column, td.time-column {
            max-width: 120px; /* Set the maximum width for the column */
            white-space: nowrap; /* Prevent text from wrapping */
            text-align: right;
        }

        th.info-column, td.info-column {
            width: 100%; /* Allow the column to take all the remaining space */
        }

        th, td {
            padding: 8px;
            border: 1px solid var(--table-border-color, #ccc);
            text-align: left;
        }

        th {
            background-color: var(--header-background-color);
        }

        .status-success {
            color: green;
            font-weight: bold;
        }

        .status-fail {
            color: red;
            font-weight: bold;
        }

        .status-pending {
            color: #d4a017;
            font-weight: bold;
        }

        .status-broken {
            color: purple;
            font-weight: bold;
        }

        .status-run {
            color: #0080ff;
            font-weight: bold;
        }

        .status-error {
            color: darkred;
            font-weight: bold;
        }

        .status-other {
            color: grey;
            font-weight: bold;
        }
    </style>
</head>
<body>
<div id="status-container"></div>
<div id="result-container"></div>
<button id="toggle-status-bar" onclick="toggleStatusBar()">‚Äñ</button>

<footer id="footer">
    <div class="left"></div>
    <div class="right"></div>
    <div class="settings">
        <span id="theme-toggle">üîÜÔ∏è</span>
    </div>
</footer>

<script>
    function toggleTheme() {
        document.body.classList.toggle('night-theme');
        if (document.body.classList.contains('night-theme')) {
            localStorage.setItem('theme', 'night');
        } else {
            localStorage.setItem('theme', 'day');
        }
    }

    function toggleStatusBar() {
        var statusContainer = document.getElementById("status-container");
        var resultContainer = document.getElementById("result-container");
        var toggleButton = document.getElementById("toggle-status-bar");

        if (statusContainer.classList.contains("hidden")) {
            statusContainer.classList.remove("hidden");
            resultContainer.classList.remove("expanded");
            toggleButton.classList.remove("button-moved");
        } else {
            statusContainer.classList.add("hidden");
            resultContainer.classList.add("expanded");
            toggleButton.classList.add("button-moved");
        }
    }

    function updateUrlParameter(paramName, paramValue) {
        const url = new URL(window.location.href);
        url.searchParams.set(paramName, paramValue);
        window.location.href = url.toString();
    }

    document.getElementById('theme-toggle').addEventListener('click', toggleTheme);

    function formatTimestamp(timestamp, showDate = true) {
        const date = new Date(timestamp * 1000);
        const day = String(date.getDate()).padStart(2, '0');
        const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        const month = monthNames[date.getMonth()];
        //const year = date.getFullYear();
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        //const milliseconds = String(date.getMilliseconds()).padStart(2, '0');

        return showDate
            ? `${day}'${month} ${hours}:${minutes}:${seconds}`
            : `${hours}:${minutes}:${seconds}`;
    }

    function formatDuration(durationInSeconds, detailed = false) {
        // Check if the duration is empty, null, or not a number
        if (!durationInSeconds || isNaN(durationInSeconds)) {
            return '';
        }

        // Ensure duration is a floating-point number
        const duration = parseFloat(durationInSeconds);

        if (detailed) {
            // Format in the detailed format with hours, minutes, and seconds
            const hours = Math.floor(duration / 3600);
            const minutes = Math.floor((duration % 3600) / 60);
            const seconds = Math.floor(duration % 60);

            const formattedHours = hours > 0 ? `${hours}h ` : '';
            const formattedMinutes = minutes > 0 ? `${minutes}m ` : '';
            const formattedSeconds = `${String(seconds).padStart(2, '0')}s`;

            return `${formattedHours}${formattedMinutes}${formattedSeconds}`.trim();
        } else {
            // Format in the default format with seconds and milliseconds
            const seconds = Math.floor(duration);
            const milliseconds = Math.floor((duration % 1) * 1000);

            const formattedSeconds = String(seconds);
            const formattedMilliseconds = String(milliseconds).padStart(2, '0').slice(-2);

            return `${formattedSeconds}.${formattedMilliseconds}`;
        }
    }

    // Function to determine status class based on value
    function getStatusClass(status) {
        const lowerStatus = status.toLowerCase();
        if (lowerStatus.includes('success') || lowerStatus === 'ok') return 'status-success';
        if (lowerStatus.includes('fail')) return 'status-fail';
        if (lowerStatus.includes('pending')) return 'status-pending';
        if (lowerStatus.includes('broken')) return 'status-broken';
        if (lowerStatus.includes('run')) return 'status-run';
        if (lowerStatus.includes('error')) return 'status-error';
        return 'status-other';
    }

    function addInfoLineToStatus(info) {
        const statusContainer = document.getElementById('status-container');
        const line = document.createElement('div');
        line.className = 'json-value-small';
        line.textContent = info;
        statusContainer.appendChild(line);
    }

    function addKeyValueToStatus(key, value, options = null, optionValues = null, link = null) {
        const statusContainer = document.getElementById('status-container');

        let keyValuePair = document.createElement('div');
        keyValuePair.className = 'key-value-pair';

        const keyElement = document.createElement('div');
        keyElement.className = 'json-key';
        keyElement.textContent = key !== "" ? key + ":" : "";

        let valueElement;

        if (options) {
            // Create dropdown if options are provided
            valueElement = document.createElement('select');
            valueElement.className = 'dropdown-value';

            options.forEach((optionTextContent, i) => {
                const option = document.createElement('option');
                option.value = optionValues?.[i] ?? optionTextContent;
                option.textContent = optionTextContent;

                // Set the initially selected option
                if (option.value === value) {
                    option.selected = true;
                }
                valueElement.appendChild(option);
            });

            // Update the URL parameter when the selected value changes
            valueElement.addEventListener('change', (event) => {
                const selectedValue = event.target.value;
                updateUrlParameter(key, selectedValue);
            });
        } else {
            if (link) {
                // Create clickable link if `link` is provided
                valueElement = document.createElement('a');
                valueElement.href = link;
                valueElement.className = "external-link";
                valueElement.textContent = value || 'N/A'; // Display 'N/A' if value is null
                valueElement.target = "_blank"; // Open in a new tab
            } else {
                // Create a simple text display if no options or link are provided
                valueElement = document.createElement('div');
                valueElement.className = "json-value";
                valueElement.textContent = value || 'N/A';
            }
        }

        keyValuePair.appendChild(keyElement);
        keyValuePair.appendChild(valueElement);
        statusContainer.appendChild(keyValuePair);
    }

    function addFileButtonToStatus(key, links) {
        function getPRandShaFromLink(link) {
            const url = new URL(link);
            const params = new URLSearchParams(url.search);

            const PR = params.get('PR');
            const sha = params.get('sha');

            return { PR, sha };
        }

        if (links == null) {
            return
        }
        const statusContainer = document.getElementById('status-container');

        const keyElement = document.createElement('div');
        keyElement.className = 'json-key';
        //keyElement.textContent = columnSymbols[key] + ':' || key;
        keyElement.textContent = '';
        statusContainer.appendChild(keyElement);

        if (Array.isArray(links) && links.length > 0) {
            let base_url = window.location.origin + window.location.pathname;
            links.forEach(link => {
                const textLink = document.createElement('a');
                textLink.href = link;

                if (!link.includes(base_url)) {
                    textLink.textContent = link.split('/').pop();
                } else {
                    // it's a link to another report:
                    const {PR, sha} = getPRandShaFromLink(link)
                    textLink.textContent = `Report PR#${PR}, sha#${sha.substring(0, 10)}`;
                }
                textLink.classList.add("file-link")

                textLink.target = '_blank';
                statusContainer.appendChild(textLink);
                statusContainer.appendChild(document.createElement('br'));
            });
        }
    }

    function addTimeTraceWidget(results) {
        const statusContainer = document.getElementById("status-container");
        if (!results || results.length === 0) {
            console.error("No results to visualize.");
            return;
        }

        // Constants
        const lineWidth = 5; // Height per task
        const padding = 1; // Space between lines
        const totalHeight = (lineWidth + padding) * results.length;

        // Create and configure canvas
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        const tooltip = document.createElement("div");

        canvas.style.position = "absolute";
        canvas.style.left = "0px"; // Force canvas to start from the very left
        canvas.style.width = "100%"; // Make it stretch within container
        canvas.style.height = `${totalHeight}px`;

        function resizeCanvas() {
            canvas.width = statusContainer.clientWidth; // Full width of container
            canvas.height = totalHeight;
            drawTimeline(); // Redraw after resizing
        }

        statusContainer.appendChild(canvas);
        resizeCanvas();

        // Tooltip styles
        tooltip.style.position = "absolute";
        tooltip.style.background = "black";
        tooltip.style.color = "white";
        tooltip.style.padding = "5px 10px";
        tooltip.style.borderRadius = "4px";
        tooltip.style.fontSize = "12px";
        tooltip.style.display = "none";
        tooltip.style.pointerEvents = "none";
        statusContainer.appendChild(tooltip);

        window.addEventListener("resize", resizeCanvas);

        function getColorFromName(name) {
            let hash = 0;
            for (let i = 0; i < name.length; i++) {
                hash = name.charCodeAt(i) + ((hash << 5) - hash); // Simple hash function
            }
            const hue = Math.abs(hash % 360); // Map hash to 0-360 for color hue
            return `hsl(${hue}, 70%, 60%)`; // Use HSL for vibrant, distinct colors
        }

        function drawTimeline() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Store task positions for hover detection
            let taskRects = [];

            const minStartTime = runtimeCache.json0.start_time;
            const currentUtcTimestamp = Date.now() / 1000;
            const maxTime = runtimeCache.json0?.duration ?? (currentUtcTimestamp - minStartTime);
            const scaleX = canvas.width / maxTime;

            results.forEach((task, index) => {
                const y = index * (lineWidth + padding);
                const height = lineWidth;

                let x, width, color;
                if (task.start_time === null) {
                    x = 0;
                    width = canvas.width;
                    function getCssVariable(name) {
                        return getComputedStyle(document.body).getPropertyValue(name).trim();
                    }

                    if (task.status === "pending") {
                        color = getCssVariable('--pending-bar-color');
                    } else {
                        color = getCssVariable('--skipped-bar-color');
                    }
                } else if (task.duration === null) {
                    x = (task.start_time - minStartTime) * scaleX;
                    width = (maxTime - (task.start_time - minStartTime)) * scaleX;
                    color = getColorFromName(task.name);
                } else {
                    x = (task.start_time - minStartTime) * scaleX;
                    width = task.duration * scaleX;
                    color = getColorFromName(task.name);
                }

                // Draw the bar
                ctx.fillStyle = color;
                ctx.fillRect(x, y, width, height);

                // Store task row position (entire row for hover detection)
                taskRects.push({ x, y, width, height, name: task.name });
            });

            // Mouse move event for hover detection
            canvas.addEventListener("mousemove", (event) => {
                const rect = canvas.getBoundingClientRect();
                const tooltipRect = tooltip.getBoundingClientRect();
                const mouseY = event.clientY - rect.top;

                let hoveredTask = null;
                for (let task of taskRects) {
                    if (mouseY >= task.y && mouseY <= task.y + task.height) {
                        hoveredTask = task;
                        break;
                    }
                }

                if (hoveredTask) {
                    let tooltipX = event.clientX + 10; // Default tooltip position (right of mouse)
                    // Prevent tooltip from going outside the right edge
                    if (tooltipX + tooltipRect.width > rect.right) {
                        tooltipX = rect.right - tooltipRect.width; // Stop moving right
                    }
                    tooltip.textContent = hoveredTask.name;
                    tooltip.style.left = `${tooltipX}px`;
                    tooltip.style.top = `${event.clientY + 10}px`;
                    tooltip.style.display = "block";
                } else {
                    tooltip.style.display = "none";
                }
            });

            // Hide tooltip on mouse out
            canvas.addEventListener("mouseleave", () => {
                tooltip.style.display = "none";
            });
        }

        drawTimeline();

        // Redraw traces every 5 seconds
        setInterval(() => {
            drawTimeline();
        }, 5000);
    }

    function addStatusToStatus(status, start_time, duration) {
        const statusContainer = document.getElementById('status-container')

        let keyValuePair = document.createElement('div');
        keyValuePair.className = 'key-value-pair';
        let keyElement = document.createElement('div');
        let valueElement = document.createElement('div');
        keyElement.className = 'json-key';
        valueElement.className = 'json-value';
        //keyElement.textContent = columnSymbols['status'] + ':' || 'status:';
        keyElement.textContent = '';
        valueElement.classList.add('status-value');
        valueElement.classList.add(getStatusClass(status));
        valueElement.textContent = status;
        keyValuePair.appendChild(keyElement);
        keyValuePair.appendChild(valueElement);
        statusContainer.appendChild(keyValuePair);

        keyValuePair = document.createElement('div');
        keyValuePair.className = 'key-value-pair';
        keyElement = document.createElement('div');
        valueElement = document.createElement('div');
        keyElement.className = 'json-key';
        valueElement.className = 'json-value';
        //keyElement.textContent = columnSymbols['start_time'] + ':' || 'start_time:';
        keyElement.textContent = ''
        valueElement.textContent = formatTimestamp(start_time);
        keyValuePair.appendChild(keyElement);
        keyValuePair.appendChild(valueElement);
        statusContainer.appendChild(keyValuePair);

        keyValuePair = document.createElement('div');
        keyValuePair.className = 'key-value-pair';
        keyElement = document.createElement('div');
        valueElement = document.createElement('div');
        keyElement.className = 'json-key';
        valueElement.className = 'json-value';
        //keyElement.textContent = columnSymbols['duration'] + ':' || 'duration:';
        keyElement.textContent = ''
        if (duration === null) {
            // Set initial value to 0 and add a unique ID or data attribute to identify the duration element
            valueElement.textContent = '00:00:00';
            valueElement.setAttribute('id', 'duration-value');
            if (start_time) {
                let duration = Math.floor(Date.now() / 1000 - start_time);
                setInterval(() => {
                    duration++;
                    valueElement.textContent = formatDuration(duration, true);
                }, 1000);
            }
        } else {
            // Format the duration if it's a valid number
            valueElement.textContent = formatDuration(duration, true);
        }
        keyValuePair.appendChild(keyElement);
        keyValuePair.appendChild(valueElement);
        statusContainer.appendChild(keyValuePair);
    }

    // Define the fixed columns globally, so both functions can use it
    const columns = ['status', 'name', 'start_time', 'duration'];
    // const columns = ['status', 'name', 'start_time', 'duration', 'info'];

    const columnSymbols = {
        // name: 'üóÇÔ∏è',
        // status: '‚úÖ',
        start_time: 'start',
        duration: 'dur',
        // info: 'üìù',
        files: 'üìé'
    };

    function createResultsTable(results, nest_level) {
        if (results && Array.isArray(results) && results.length > 0) {
            const table = document.createElement('table');
            const thead = document.createElement('thead');
            const tbody = document.createElement('tbody');

            // Create table headers based on the fixed columns
            const headerRow = document.createElement('tr');
            columns.forEach(column => {
                const th = document.createElement('th');
                th.textContent = columnSymbols[column] || column;
                th.style.cursor = 'pointer'; // Make headers clickable
                th.setAttribute('data-sort-direction', 'asc'); // Default sort direction
                th.addEventListener('click', () => sortTable(results, column, columnSymbols[column] || column, tbody, nest_level, columns)); // Add click event to sort the table
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);

            // Create table rows
            populateTableRows(tbody, results, nest_level);

            table.appendChild(thead);
            table.appendChild(tbody);

            return table;
        }
        return null;
    }

    function populateTableRows(tbody, results, nest_level) {
        const currentUrl = new URL(window.location.href);

        // Clear existing rows if re-rendering (used in sorting)
        tbody.innerHTML = '';

        results.forEach((result, _index) => {
            const row = document.createElement('tr');

            columns.forEach(column => {
                const td = document.createElement('td');
                const value = result[column];

                if (column === 'status') {
                    // Apply status formatting and make it clickable
                    const span = document.createElement('span');
                    span.className = getStatusClass(value);
                    span.textContent = value;
                    td.classList.add('status-column');
                    row.dataset.status = value ? value.toLowerCase() : "";
                    if ((result.info && result.info.trim() !== "") || (Array.isArray(result.links) && result.links.length > 0)) {
                        span.style.cursor = "pointer";
                        span.addEventListener('click', () => toggleInfoRow(row, result.info, result.links));
                    }
                    td.appendChild(span);

                } else if (column === 'name') {
                    const statusValue = result["status"] ? result["status"].toLowerCase() : "";

                    if (
                        (nest_level === 1 && ["pending", "skipped", "running"].includes(statusValue)) ||
                        (nest_level > 1 && (!Array.isArray(result.results) || result.results.length === 0))
                    ) {
                        // If status is pending, just show plain text
                        const span = document.createElement('span');
                        span.textContent = value;
                        span.classList.add('disabled');
                        td.classList.add('name-column');
                        td.appendChild(span);
                    } else {
                        // Create a link for the name field
                        const newUrl = new URL(currentUrl);
                        newUrl.searchParams.set(`name_${nest_level}`, value);

                        const link = document.createElement('a');
                        link.href = newUrl.toString();
                        link.textContent = value;
                        td.classList.add('name-column');
                        td.appendChild(link);
                    }

                } else if (column === 'start_time') {
                    td.classList.add('time-column');
                    td.textContent = value ? formatTimestamp(value, false) : '';

                } else if (column === 'duration') {
                    td.classList.add('time-column');
                    td.textContent = value ? formatDuration(value) : '';

                } else if (column === 'info') {
                    td.textContent = value && value.includes('\n') ? '‚Üµ' : (value || '');
                    td.classList.add('info-column');
                }

                row.appendChild(td);
            });

            tbody.appendChild(row);
        });
    }

    /**
     * Toggles an additional row below the clicked row to display the "info" text.
     */
    function toggleInfoRow(row, infoText, links = []) {
        if (!infoText && links.length === 0) return;

        let nextRow = row.nextElementSibling;

        // Check if the next row is already an "info" row
        if (nextRow && nextRow.classList.contains('info-row')) {
            nextRow.remove(); // If it's there, remove it
        } else {
            // Otherwise, create a new row for the info text
            const infoRow = document.createElement('tr');
            infoRow.classList.add('info-row');

            const infoCell = document.createElement('td');
            infoCell.colSpan = row.children.length; // Make it span the full width
            infoCell.classList.add('info-text');

            if (infoText) {
                let content = document.createElement('div');
                infoCell.innerHTML = '<pre></pre>';
                // Append content securely, without interpreting HTML tags.
                infoCell.firstChild.textContent = infoText;
                infoCell.appendChild(content);
            }

            // If there are links, create a list of links
            if (Array.isArray(links) && links.length > 0) {
                const linksContainer = document.createElement('div');
                linksContainer.classList.add('file-link');
                let base_url = window.location.origin + window.location.pathname;

                links.forEach(link => {
                    let linkElement = document.createElement('a');
                    linkElement.href = link;
                    linkElement.target = "_blank"; // Open in a new tab
                    linkElement.style.display = "block"; // Each link on a new line

                    if (!link.includes(base_url)) {
                        // External link: Show file name
                        linkElement.textContent = link.split('/').pop();
                    } else {
                        // Internal report link: Extract PR and SHA
                        if (typeof getPRandShaFromLink === "function") {
                            const { PR, sha } = getPRandShaFromLink(link);
                            linkElement.textContent = `Report PR#${PR}, sha#${sha.substring(0, 10)}`;
                        } else {
                            linkElement.textContent = "Unknown Report Link";
                        }
                    }
                    linksContainer.appendChild(linkElement);
                });

                infoCell.appendChild(linksContainer);
            }

            infoRow.appendChild(infoCell);
            row.parentNode.insertBefore(infoRow, row.nextSibling); // Insert below the clicked row
        }
    }

    function sortTable(results, column, key, tbody, nest_level, columns) {
        // Find the table header element for the given key
        const tableHeaders = document.querySelectorAll('th');
        let th = Array.from(tableHeaders).find(header => header.textContent === key);

        if (!th) {
            console.error(`No table header found for key: ${key}`);
            return;
        }

        const ascending = th.getAttribute('data-sort-direction') === 'asc';
        th.setAttribute('data-sort-direction', ascending ? 'desc' : 'asc');

        results.sort((a, b) => {
            if (a[column] < b[column]) return ascending ? -1 : 1;
            if (a[column] > b[column]) return ascending ? 1 : -1;
            return 0;
        });

        // Clear the existing rows in tbody
        tbody.innerHTML = '';

        // Re-populate the table with sorted data
        populateTableRows(tbody, results, nest_level);
    }

    async function fetchJson(path, lastModifiedTime = null, eTag = null) {
        try {
            // Set headers if lastModifiedTime or eTag are available
            const headers = {};
            if (lastModifiedTime) headers["If-Modified-Since"] = lastModifiedTime;
            if (eTag) headers["If-None-Match"] = eTag;

            // Fetch with conditional headers
            const response = await fetch(path, {
                cache: "no-cache",
                headers
            });

            // If the response is 304 (Not Modified), return existing metadata without fetching new data
            if (response.status === 304) {
                return { data: null, lastModifiedTime, eTag, updated: false };
            } else if (response.status === 403)
                return { data: null, lastModifiedTime: null, eTag: null, updated: true };
            // Extract headers
            const newLastModifiedTime = response.headers.get('Last-Modified');
            const newETag = response.headers.get('ETag');
            const jsonData = await response.json();

            return { data: jsonData, lastModifiedTime: newLastModifiedTime, eTag: newETag, updated: true };
        } catch (error) {
            console.error('Error loading Results:', error);
            if (infoElement) {
                infoElement.textContent = 'Error loading data';
                infoElement.style.display = 'block';
            }
            return { data: null, lastModifiedTime: null, eTag: null, updated: true };
        }
    }

    const runtimeCache = {
        commits: null,
        json0: null,
        json1: null,
        prLink: null,
        commitLink: null,
        runLink: null,
        sha: null
    };

    function storeLink(link) {
        if (link.includes('/pull/')) runtimeCache.prLink = link;
        else if (link.includes('/commit/')) runtimeCache.commitLink = link;
        else if (link.includes('/actions/runs/')) runtimeCache.runLink = link;
    }

    function getTargetResults(nameParams) {
        let resolvedNames = [];
        let data = runtimeCache.json0;

        if (data !== null) {
            resolvedNames.push(nameParams[0]);  // Initialize resolvedNames with the first parameter
        } else {
            return null;  // Return an object containing data and resolvedNames
        }

        // Check if we have more than one name to resolve
        if (nameParams.length > 1) {
            if (runtimeCache.json1) {
                data = runtimeCache.json1;  // If json1 exists, use it directly
            } else {
                let found = false;
                // Iterate through data.results to find the target name in json0
                for (let result of data.results) {
                    if (result.name === nameParams[1]) {
                        resolvedNames.push(nameParams[1]);
                        data = result;
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    console.log("No data for", nameParams[1]);
                    return data;  // Return current data and resolvedNames if no match is found
                }
            }

            // Now resolve remaining names starting from index 2
            for (let i = 2; i < nameParams.length; i++) {
                let name = nameParams[i];
                let found = false;

                // Iterate through data.results to find the target name
                for (let result of data.results) {
                    if (result.name === name) {
                        resolvedNames.push(name);
                        data = result;
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    console.log("No data for", name);
                    return data;  // Return current data and resolvedNames if no match is found
                }
            }
        }

        return data;  // Return the resolved data and names at the end
    }

    function fillInNavigationBar(nameArray) {
        let baseParams = new URLSearchParams(window.location.search);
        let keysToDelete = [];
        baseParams.forEach((value, key) => {
            if (key.startsWith('name_')) {
                keysToDelete.push(key);
            }
        });
        keysToDelete.forEach((key) => baseParams.delete(key));

        let pathNames = [];
        let pathLinks = [];
        for (const [index, name] of nameArray.entries()) {
            baseParams.set(`name_${index}`, name);
            pathNames.push(name);
            pathLinks.push(`<span class="separator">/</span><a href="${window.location.pathname}?${baseParams.toString()}" class="nav-link">${name}</a>`);
        }

        const footerLeft = document.querySelector('#footer .left');
        footerLeft.innerHTML = pathLinks.join('');
    }

    function renderFooter(nameParams) {
        const footerRight = document.querySelector('#footer .right');
        function createLinkElement(href, textContent, footer) {
            const a = document.createElement('a');
            a.href = href;
            a.textContent = textContent;
            a.target = '_blank';
            footer.appendChild(a);
        }
        if (runtimeCache.prLink) createLinkElement(runtimeCache.prLink, 'PR', footerRight);
        if (runtimeCache.commitLink) createLinkElement(runtimeCache.commitLink, 'Commit', footerRight);
        if (runtimeCache.runLink) createLinkElement(runtimeCache.runLink, 'Run', footerRight);
        const result = getTargetResults(nameParams)
        let i = 1;
        for (const name of nameParams) {
            if (name === result.name) {
                break;
            }
            i++;
        }
        fillInNavigationBar(nameParams.slice(0, i + 1))
    }

    async function renderResults(PR, sha, nameParams) {
        const result = getTargetResults(nameParams)
        let i = 1;
        for (const name of nameParams) {
            if (name === result.name) {
                break;
            }
            i++;
        }

        const resultsDiv = document.getElementById('result-container');
        if (result.info) {
            const textDiv = document.createElement('div');
            textDiv.id = 'info-content';
            textDiv.innerHTML = (result.info || '').replace(/\n/g, '<br>');
            resultsDiv.appendChild(textDiv);
        }

        const resultsData = result.results;
        if (Array.isArray(resultsData) && resultsData.length > 0) {
            const table = createResultsTable(resultsData, i);
            if (table) {
                resultsDiv.appendChild(table); // Appends table correctly
            }
        }
        // Status and info
        if (PR > 0) {
            addKeyValueToStatus("PR", PR, null, null, runtimeCache.prLink);
        }
        let current_sha = sha === "latest" ? (runtimeCache.commits.at(-1).sha || sha) : sha;
        const shaSelectorText = [];
        const shaSelectorValues = [];

        runtimeCache.commits.forEach(({ sha, message }) => {
            const shortSha = (sha || "").substring(0, 8);
            shaSelectorText.push(message ? `${shortSha}: ${message}` : shortSha);
            shaSelectorValues.push(sha);
        });
        shaSelectorText.push("latest");
        shaSelectorValues.push("latest");
        addKeyValueToStatus("sha", sha || "latest", shaSelectorText, shaSelectorValues);

        if (PR > 0) {
            const { pr_title, git_branch } = runtimeCache.json0?.ext || {};
            if (pr_title) addInfoLineToStatus(pr_title);
            if (git_branch) addInfoLineToStatus(git_branch);
        }
        addInfoLineToStatus(current_sha);
        addStatusToStatus(result.status, result.start_time, result.duration);
        if (nameParams.length > 1) {
            addFileButtonToStatus('files', result.links);
        } else {
            addTimeTraceWidget(result.results)
        }
    }

    async function fetchData(PR, REF, sha, nameParams) {
        function normalizeTaskName(name) {
            return name.toLowerCase()
                .replace(/[^a-z0-9]/g, '_')
                .replace(/_+/g, '_')
                .replace(/_+$/, '');
        }

        const baseUrl = window.location.origin + window.location.pathname.split('/').slice(0, -1).join('/');
        let suffix = '';

        if (PR) {
            suffix = `PRs/${encodeURIComponent(PR)}`;
        } else if (REF) {
            suffix = `REFs/${encodeURIComponent(REF)}`;
        }

        let hasNewData = false;

        if (!runtimeCache.commits || sha === 'latest') {
            const { data, updated } = await fetchJson(`${baseUrl}/${suffix}/commits.json`);
            if (updated) {
                runtimeCache.commits = data ? data : [];
                hasNewData = true;
            }
        }

        const shaToLoad = (sha === 'latest') ? runtimeCache.commits[runtimeCache.commits.length - 1]?.sha : sha;

        const fetchTasks = [];
        if (nameParams.length > 1) {
            const task1 = normalizeTaskName(nameParams[1]);
            const path1 = `${baseUrl}/${suffix}/${encodeURIComponent(shaToLoad)}/result_${task1}.json`;
            fetchTasks.push(fetchJson(path1));
        }

        const task0 = normalizeTaskName(nameParams[0]);
        const path0 = `${baseUrl}/${suffix}/${encodeURIComponent(shaToLoad)}/result_${task0}.json`;
        fetchTasks.push(fetchJson(path0));

        // Run fetchJson calls in parallel
        const results = await Promise.all(fetchTasks);

        if (nameParams.length > 1) {
            const { data, updated } = results[0]; // First request result
            if (updated) {
                runtimeCache.json1 = data;
                hasNewData = true;
            }
        }

        const { data, updated } = results[fetchTasks.length - 1]; // Last request result (always task0)
        if (updated) {
            runtimeCache.json0 = data;
            hasNewData = true;
            data.links.forEach(storeLink);
        }

        return hasNewData;
    }

    function startAutoRefresh(PR, REF, sha, nameParams) {
        function clearPage() {
            // Clear the main content areas
            // document.getElementById('content').innerHTML = '';
            document.getElementById('result-container').innerHTML = '';
            document.getElementById('status-container').innerHTML = '';
        }
        async function checkForUpdates() {
            if (await fetchData(PR, REF, sha, nameParams)) {
                clearPage();
                await renderResults(PR, sha, nameParams);
            }
        }
        setInterval(checkForUpdates, 30000);
    }

    function updatePageTitle(PR, REF, sha, nameParams) {
        let title = "";
        if (Array.isArray(nameParams) && nameParams.length > 0) {
            title += ` ${nameParams[0]}`;
        }
        if (Array.isArray(nameParams) && nameParams.length > 1) {
            title += `/${nameParams[1]}`;
        }
        if (PR > 0) {
            title += `, PR#${PR}`;
        } else {
            title += `, sha#${sha.substring(0, 8)}`;
        }
        document.title = title.trim();
    }

    async function init() {
        const urlParams = new URLSearchParams(window.location.search);
        const PR = urlParams.get('PR');
        const REF = urlParams.get('REF');
        const sha = urlParams.get('sha');
        const nameParams = [];

        urlParams.forEach((value, key) => {
            if (key.startsWith('name_')) {
                const index = parseInt(key.split('_')[1], 10);
                nameParams[index] = value;
            }
        });

        await fetchData(PR, REF, sha, nameParams);
        await renderResults(PR, sha, nameParams);
        renderFooter(nameParams)
        updatePageTitle(PR, REF, sha, nameParams)

        if (
            (nameParams?.length === 1 &&
                ["running", "pending"].includes(runtimeCache?.json0?.status)) ||
            (nameParams?.length === 2 &&
                (["running", "pending"].includes(runtimeCache?.json1?.status) || runtimeCache?.json1 == null))
        ) {
            console.log("Auto-reload started");
            startAutoRefresh(PR, REF, sha, nameParams);
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'night') {
            document.body.classList.add('night-theme');
        }
        init();
    });
</script>
</body>
</html>
