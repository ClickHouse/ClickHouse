#!/usr/bin/env python3
import os
import re
import sys
from pathlib import Path
from shlex import quote
from typing import Tuple

from praktika.info import Info
from praktika.utils import Shell

from ci.praktika import Secret
from ci.praktika.gh import GH


class CIAgent:

    def __init__(self):
        self.info = Info()

    def is_ready(self):
        if not self.ensure_claude_auth():
            return False
        if not self.ensure_claude_code_cli():
            return False
        return True

    def extract_autogenerated_content(self, filename: str) -> str:
        """LLM responses are written to .txt file by subagent and read back by this function"""
        try:
            with open(filename, "r", encoding="utf-8", errors="replace") as f:
                file_content = f.read()

            # Remove "EOF < /dev/null" if it exists
            file_content = file_content.replace("EOF < /dev/null", "")

            # Check for API errors in the response
            if file_content.strip().startswith("API Error: "):
                raise RuntimeError(
                    f"Claude API Error detected in {filename}: {file_content.strip()}"
                )

            return file_content
        except FileNotFoundError:
            print(f"Warning: {filename} not found")
            return ""
        except Exception as e:
            print(f"Error reading {filename}: {e}")
            raise

    def ensure_claude_auth(self) -> bool:
        try:
            if not os.environ.get("CLAUDE_CODE_USE_BEDROCK"):
                print("CLAUDE_CODE_USE_BEDROCK not set")
                return False
            if not os.environ.get("AWS_REGION"):
                print("AWS_REGION not set")
                return False
            return True
        except Exception as e:
            print(f"Something went wrong with setup of Claude environment: {e}")
            return False

    def ensure_claude_code_cli(self) -> bool:
        try:
            Shell.run("node --version", verbose=True)
            exit_code = Shell.run("command -v claude", verbose=False)
            if exit_code == 0:
                claude_path = Shell.get_output("command -v claude").strip()
                print(f"claude-code CLI found at: {claude_path}")
                return True
            else:
                raise Exception("claude command not found")
        except:
            print("claude-code not found")
            return False

    def extract_content_and_format_flag(
        self, body: str, tag_prefix: str
    ) -> Tuple[str, bool]:
        """
        PR body contains:

        <!---
        The PR description will be automatically generated based on the contents of this PR
        and the description will be inserted between the BEGIN and END tags below

        1. If you wish to write your own description but have the LLM format it for you
           place it between the tags below and change the comment to format=true
        2. If you don't want any LLM help at all, you can remove the tags below
           and add your own description instead.
        -->

        <!--- BEGIN_DESCRIPTION format=false -->
        <!--- END_DESCRIPTION -->

        ...

        <!--- BEGIN: AUTOGENERATED CHANGELOG ENTRY
        The Changelog entry will be automatically generated based on the contents of this PR
        and the changelog entry will be inserted between the BEGIN and END tags below.

        1. If you wish to write your own and have the LLM format it for you, place it between
           the BEGIN and END tags below and set format=true
        2. If you don't want any LLM help at all, remove the tags below and add your changelog entry instead
        -->

        <!--- BEGIN_CHANGELOG_ENTRY format=false -->
        <!--- END_CHANGELOG_ENTRY -->
        """

        # Look for BEGIN tag which has a format attribute
        begin_pattern = f"<!--- {tag_prefix} format=(true|false) -->"
        # Extract the end tag name by removing "BEGIN_" prefix
        end_tag_name = tag_prefix.replace("BEGIN_", "")
        end_pattern = f"<!--- END_{end_tag_name} -->"

        begin_match = re.search(begin_pattern, body, re.IGNORECASE)
        end_match = re.search(end_pattern, body, re.IGNORECASE)

        if begin_match and end_match:
            # Check if user wants the text between BEGIN and END tags needs
            format_flag = begin_match.group(1).lower() == "true"

            # Extract content between tags
            start = begin_match.end()
            end = end_match.start()
            content = body[start:end].strip()

            return content, format_flag
        return "", False

    def insert_content_between_tags(
        self, text: str, tag_prefix: str, new_content: str
    ) -> str:
        """
        Function to format tags with either LLM generated body (if no text between BEGIN and END tags and format=false)
        or a human written body formatted by the LLM (if there is text between BEGIN and END tags but format=true)
        """

        # Look for a BEGIN tag with the format attribute
        begin_pattern = f"<!--- {tag_prefix} format=(true|false) -->"
        # Extract the end tag name by removing "BEGIN_" prefix
        end_tag_name = tag_prefix.replace("BEGIN_", "")
        end_pattern = f"<!--- END_{end_tag_name} -->"

        begin_match = re.search(begin_pattern, text, re.IGNORECASE)
        end_match = re.search(end_pattern, text, re.IGNORECASE)

        if begin_match and end_match:
            new_begin_tag = f"<!--- {tag_prefix} format=false -->"

            # Replace everything from BEGIN tag to END tag
            before = text[: begin_match.start()]
            after = text[end_match.end() :]

            return f"{before}{new_begin_tag}\n{new_content}\n<!--- END_{end_tag_name} -->{after}"
        return text

    def generate_description(self, diff_file: str, human_description: str) -> str:
        try:
            prompt = f"Use the pr-description-generator agent to generate a PR description for this PR. Read the diff from file: {diff_file}"
            # Write prompt to file and pipe it to claude to avoid shell escaping issues
            with open("prompt_description.txt", "w", encoding="utf-8") as f:
                f.write(prompt)

            command = f"cat prompt_description.txt | claude --output-format text --allowedTools 'Bash,Read' --permission-mode acceptEdits -p 'Generate PR description' > pr_description.txt"
            Shell.check(command)
            description = self.extract_autogenerated_content("pr_description.txt")
            return description
        except RuntimeError as e:
            if "API Error: " in str(e):
                # Re-raise API errors so they can be caught by the main job
                raise
            print(f"Error running claude command: {e}")
            return f"Error generating PR description: {e}"
        except Exception as e:
            print(f"Error running claude command: {e}")
            return f"Error generating PR description: {e}"

    def generate_changelog_entry(
        self, diff_file: str, human_changelog_entry: str
    ) -> str:
        try:
            prompt = f"Use the pr-changelog-generator agent to generate a PR changelog entry for this PR. Read the diff from file: {diff_file}"
            # Write prompt to file and pipe it to claude to avoid shell escaping issues
            with open("prompt_changelog.txt", "w", encoding="utf-8") as f:
                f.write(prompt)

            command = f"cat prompt_changelog.txt | claude --output-format text --allowedTools 'Bash,Read' --permission-mode acceptEdits -p 'Generate changelog entry' > changelog_entry.txt"
            Shell.check(command)
            changelog = self.extract_autogenerated_content("changelog_entry.txt")
            return changelog
        except RuntimeError as e:
            if "API Error: " in str(e):
                # Re-raise API errors so they can be caught by the main job
                raise
            print(f"Error running claude command: {e}")
            return f"Error generating changelog entry: {e}"
        except Exception as e:
            print(f"Error running claude command: {e}")
            return f"Error generating changelog entry: {e}"

    def format_description_or_changelog(self, type: str, content: str):
        if type == "description":
            try:
                with open("user_pr_description.txt", "w", encoding="utf-8") as f:
                    f.write(content)
                prompt = f"Use the pr-description-formatter agent to read the user provided description stored in user_pr_description.txt and format it."

                # Write prompt to file and pipe it to claude to avoid shell escaping issues
                with open("prompt_user_description.txt", "w", encoding="utf-8") as f:
                    f.write(prompt)

                command = f"cat prompt_user_description.txt | claude --output-format text --allowedTools 'Bash,Read' --permission-mode acceptEdits -p 'format' > formatted_user_description.txt"
                Shell.check(command)
                changelog = self.extract_autogenerated_content(
                    "formatted_user_description.txt"
                )
                return changelog
            except Exception as e:
                print(f"Error running claude command: {e}")
                return f"Error formatting user description: {e}"

        elif type == "changelog":
            try:
                with open("user_changelog_entry.txt", "w", encoding="utf-8") as f:
                    f.write(content)
                prompt = f"Use the pr-changelog-formatter agent to read the user provided changelog entry stored in user_changelog_entry.txt and format it."

                # Write prompt to file and pipe it to claude to avoid shell escaping issues
                with open("prompt_user_changelog.txt", "w", encoding="utf-8") as f:
                    f.write(prompt)

                command = f"cat prompt_user_changelog.txt | claude --output-format text --allowedTools 'Bash,Read' --permission-mode acceptEdits -p 'format' > formatted_user_changelog.txt"
                Shell.check(command)
                changelog = self.extract_autogenerated_content(
                    "formatted_user_changelog.txt"
                )
                return changelog
            except Exception as e:
                print(f"Error running claude command: {e}")
                return f"Error formatting user description: {e}"
        else:
            raise Exception(
                "No valid type was provided. Please specify either 'description' or 'changelog'"
            )
            sys.exit(1)

    def update_pr_body_with_generated_content(
        self, pr_body: str, description: str, changelog_entry: str
    ) -> str:
        updated_body = pr_body
        updated_body = insert_content_between_tags(
            updated_body, "BEGIN_DESCRIPTION", description
        )
        updated_body = insert_content_between_tags(
            updated_body, "BEGIN_CHANGELOG_ENTRY", changelog_entry
        )

        return updated_body

    def should_process_section(self, tag_prefix: str) -> Tuple[bool, Tuple[bool, str]]:
        content, should_format = self.extract_content_and_format_flag(
            self.info.pr_body, tag_prefix
        )

        """
        Processing happens if:
        1. The BEGIN and END tags have nothing between them -> LLM generates the content
        2. The BEGIN and END tags do have content and format=true (false by default) -> Format the existing content
    
        No processing occurs if format=false and there is content between the tags i.e user written without LLM assistance
        """
        should_process = not content.strip() or should_format
        return (should_process, (should_format, content))


if __name__ == "__main__":
    CIAgent = CIAgent()
    assert CIAgent.is_ready()
