#!/usr/bin/env python3
import os
import re
from typing import Tuple

from ci.praktika.info import Info
from ci.praktika.utils import Shell

# Section name constants used in PR templates
SECTION_DESCRIPTION = "LLM-generated Change Description"
SECTION_CHANGELOG = "LLM-generated Changelog Entry"


class CIAgent:

    def __init__(self):
        self.info = Info()

    def is_ready(self):
        if not self.ensure_claude_auth():
            return False
        if not self.ensure_claude_code_cli():
            return False
        return True

    def extract_autogenerated_content(self, filename: str) -> str:
        """LLM responses are written to .txt file by subagent and read back by this function"""
        try:
            with open(filename, "r", encoding="utf-8", errors="replace") as f:
                file_content = f.read()

            # Remove "EOF < /dev/null" if it exists
            file_content = file_content.replace("EOF < /dev/null", "")

            # Check for API errors in the response
            if file_content.strip().startswith("API Error: "):
                raise RuntimeError(
                    f"Claude API Error detected in {filename}: {file_content.strip()}"
                )

            return file_content
        except FileNotFoundError:
            print(f"Warning: {filename} not found")
            return ""
        except Exception as e:
            print(f"Error reading {filename}: {e}")
            raise

    def ensure_claude_auth(self) -> bool:
        try:
            if not os.environ.get("CLAUDE_CODE_USE_BEDROCK"):
                print("CLAUDE_CODE_USE_BEDROCK not set")
                return False
            if not os.environ.get("AWS_REGION"):
                print("AWS_REGION not set")
                return False
            return True
        except Exception as e:
            print(f"Something went wrong with setup of Claude environment: {e}")
            return False

    def ensure_claude_code_cli(self) -> bool:
        try:
            Shell.run("node --version", verbose=True)
            exit_code = Shell.run("command -v claude", verbose=False)
            if exit_code == 0:
                claude_path = Shell.get_output("command -v claude").strip()
                print(f"claude-code CLI found at: {claude_path}")
                return True
            else:
                raise Exception("claude command not found")
        except:
            print("claude-code not found")
            return False

    @staticmethod
    def _begin_re(section_name: str):
        # Match markers with or without explicit BEGIN (backward compatible),
        # allow any attributes lazily until the closing, support '-->' or '--->'
        pattern = rf"<!---\s*{re.escape(section_name)}\s+BEGIN\b[^>]*?-->"
        return re.compile(pattern, re.IGNORECASE | re.DOTALL)

    @staticmethod
    def _end_re(section_name: str):
        # Match literal END, allow optional trailing attributes/spaces, support '-->' or '--->'
        pattern = rf"<!---\s*{re.escape(section_name)}\s+END\b[^>]*?-->"
        return re.compile(pattern, re.IGNORECASE)

    @staticmethod
    def _normalized_begin_tag(
        section_name: str, enabled: bool, format_only: bool
    ) -> str:
        return f"<!--- {section_name} BEGIN enabled={'true' if enabled else 'false'} format_only={'true' if format_only else 'false'} -->"

    @staticmethod
    def _normalized_end_tag(section_name: str) -> str:
        return f"<!--- {section_name} END -->"

    def insert_content_between_tags(
        self, text: str, section_name: str, new_content: str, format_only: bool
    ) -> str:
        """
        Replace the content between the new-style LLM markers in the PR body.
        Markers look like:
        <!--- LLM-generated Change Description BEGIN enabled=false format_only=false -->
        ... content ...
        <!--- LLM-generated Change Description END -->
        """
        # Look for a begin tag for this section, allowing any attributes/order, but DO NOT match the END line
        # The tempered pattern below matches up to the nearest '-->' on the same tag, excluding ' END '
        # Use shared helpers
        begin_re = self._begin_re(section_name)
        end_re = self._end_re(section_name)

        begin_match = begin_re.search(text)
        end_match = end_re.search(text, begin_match.end()) if begin_match else None
        if begin_match and end_match:
            # Always normalize markers after processing
            new_begin_tag = self._normalized_begin_tag(
                section_name, enabled=not format_only, format_only=format_only
            )

            # Replace everything from BEGIN tag to END tag
            before = text[: begin_match.start()]
            after = text[end_match.end() :]

            replaced = f"{before}{new_begin_tag}\n{new_content}\n{self._normalized_end_tag(section_name)}{after}"
            return replaced
        assert False, "Markers are not found"

    def generate_description(self, diff_file: str, human_description: str) -> str:
        try:
            prompt = f"Use the pr-description-generator agent to generate a PR description for this PR. Read the diff from file: {diff_file}"
            # Write prompt to file and pipe it to claude to avoid shell escaping issues
            with open("prompt_description.txt", "w", encoding="utf-8") as f:
                f.write(prompt)

            command = f"cat prompt_description.txt | claude --output-format text --allowedTools 'Bash,Read' --permission-mode acceptEdits -p 'Generate PR description' > pr_description.txt"
            Shell.check(command)
            description = self.extract_autogenerated_content("pr_description.txt")
            return description
        except RuntimeError as e:
            if "API Error: " in str(e):
                # Re-raise API errors so they can be caught by the main job
                raise
            print(f"Error running claude command: {e}")
            return f"Error generating PR description: {e}"
        except Exception as e:
            print(f"Error running claude command: {e}")
            return f"Error generating PR description: {e}"

    def generate_changelog_entry(
        self, diff_file: str, human_changelog_entry: str
    ) -> str:
        try:
            prompt = f"Use the pr-changelog-generator agent to generate a PR changelog entry for this PR. Read the diff from file: {diff_file}"
            # Write prompt to file and pipe it to claude to avoid shell escaping issues
            with open("prompt_changelog.txt", "w", encoding="utf-8") as f:
                f.write(prompt)

            command = f"cat prompt_changelog.txt | claude --output-format text --allowedTools 'Bash,Read' --permission-mode acceptEdits -p 'Generate changelog entry' > changelog_entry.txt"
            Shell.check(command)
            changelog = self.extract_autogenerated_content("changelog_entry.txt")
            return changelog
        except RuntimeError as e:
            if "API Error: " in str(e):
                # Re-raise API errors so they can be caught by the main job
                raise
            print(f"Error running claude command: {e}")
            return f"Error generating changelog entry: {e}"
        except Exception as e:
            print(f"Error running claude command: {e}")
            return f"Error generating changelog entry: {e}"

    def format_description_or_changelog(self, type: str, content: str):
        if type == "description":
            try:
                with open("user_pr_description.txt", "w", encoding="utf-8") as f:
                    f.write(content)
                prompt = f"Use the pr-description-formatter agent to read the user provided description stored in user_pr_description.txt and format it."

                # Write prompt to file and pipe it to claude to avoid shell escaping issues
                with open("prompt_user_description.txt", "w", encoding="utf-8") as f:
                    f.write(prompt)

                command = f"cat prompt_user_description.txt | claude --output-format text --allowedTools 'Bash,Read' --permission-mode acceptEdits -p 'format' > formatted_user_description.txt"
                Shell.check(command)
                changelog = self.extract_autogenerated_content(
                    "formatted_user_description.txt"
                )
                return changelog
            except Exception as e:
                print(f"Error running claude command: {e}")
                return f"Error formatting user description: {e}"

        elif type == "changelog":
            try:
                with open("user_changelog_entry.txt", "w", encoding="utf-8") as f:
                    f.write(content)
                prompt = f"Use the pr-changelog-formatter agent to read the user provided changelog entry stored in user_changelog_entry.txt and format it."

                # Write prompt to file and pipe it to claude to avoid shell escaping issues
                with open("prompt_user_changelog.txt", "w", encoding="utf-8") as f:
                    f.write(prompt)

                command = f"cat prompt_user_changelog.txt | claude --output-format text --allowedTools 'Bash,Read' --permission-mode acceptEdits -p 'format' > formatted_user_changelog.txt"
                Shell.check(command)
                changelog = self.extract_autogenerated_content(
                    "formatted_user_changelog.txt"
                )
                return changelog
            except Exception as e:
                print(f"Error running claude command: {e}")
                return f"Error formatting user description: {e}"
        else:
            raise Exception(
                "No valid type was provided. Please specify either 'description' or 'changelog'"
            )

    def should_process_section(self, section_name: str) -> Tuple[bool, bool, str]:
        """
        Processing happens if:
        - The section has enabled=true and there is no content between the begin and end markers -> LLM generates the content
        - The section has enabled=true, there is user-provided content, and the format_only flag is set to true -> LLM formats the content

        No processing occurs if:
        - enabled=false; or
        - there is user-provided content and the format_only flag is false
        """
        content = ""
        # Determine if the section is enabled
        begin_match = self._begin_re(section_name).search(self.info.pr_body)
        end_match = self._end_re(section_name).search(self.info.pr_body)
        if begin_match and end_match:
            content = self.info.pr_body[begin_match.end() : end_match.start()].strip()

        if begin_match:
            should_format = "format_only=true" in begin_match.group(0).lower() and bool(
                content
            )
            should_process = "enabled=true" in begin_match.group(0).lower() and (
                not bool(content) or should_format
            )
            print(
                f"begin marker found in PR body for section {section_name}, should_process: {should_process}, should_format: {should_format}, content present: {bool(content)}"
            )
        else:
            print(f"begin marker not found in PR body for section {section_name}")
            should_format = False
            should_process = False

        return should_process, should_format, content


if __name__ == "__main__":
    CIAgent = CIAgent()
    assert CIAgent.is_ready()
