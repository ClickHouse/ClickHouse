---
description: 'Documentation for Arithmetic Functions'
sidebar_label: 'Arithmetic'
slug: /sql-reference/functions/arithmetic-functions
title: 'Arithmetic Functions'
---

# Arithmetic functions

## Overview {#overview}

Arithmetic functions work for any two operands of type `UInt8`, `UInt16`, `UInt32`, `UInt64`, `Int8`, `Int16`, `Int32`, `Int64`, `Float32`, or `Float64`.

Before performing the operation, both operands are cast to the result type. The result type is determined as follows (unless specified
differently in the function documentation below):

- If both operands are up to 32 bits wide, the size of the result type will be the size of the next bigger type following the bigger of the
  two operands (integer size promotion). For example, `UInt8 + UInt16 = UInt32` or `Float32 * Float32 = Float64`.
- If one of the operands has 64 or more bits, the size of the result type will be the same size as the bigger of the two operands. For
  example, `UInt32 + UInt128 = UInt128` or `Float32 * Float64 = Float64`.
- If one of the operands is signed, the result type will also be signed, otherwise it will be signed. For example, `UInt32 * Int32 = Int64`.

These rules make sure that the result type will be the smallest type which can represent all possible results. While this introduces a risk
of overflows around the value range boundary, it ensures that calculations are performed quickly using the maximum native integer width of
64 bit. This behavior also guarantees compatibility with many other databases which provide 64 bit integers (BIGINT) as the biggest integer
type.

Example:

```sql
SELECT toTypeName(0), toTypeName(0 + 0), toTypeName(0 + 0 + 0), toTypeName(0 + 0 + 0 + 0)
```

```text
┌─toTypeName(0)─┬─toTypeName(plus(0, 0))─┬─toTypeName(plus(plus(0, 0), 0))─┬─toTypeName(plus(plus(plus(0, 0), 0), 0))─┐
│ UInt8         │ UInt16                 │ UInt32                          │ UInt64                                   │
└───────────────┴────────────────────────┴─────────────────────────────────┴──────────────────────────────────────────┘
```

Overflows are produced the same way as in C++.

<!-- 
The inner content of the tags below are replaced at doc framework build time with 
docs generated from system.functions. Please do not modify or remove the tags.
See: https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->

<!--AUTOGENERATED_START-->
## abs {#abs}

Introduced in: v1.1

Calculates the absolute value of `x`. Has no effect if `x` is of an unsigned type. If `x` is of a signed type, it returns an unsigned number.

**Syntax**

```sql
abs(x)
```

**Arguments**

- `x` — Value to get the absolute value of

**Returned value**

The absolute value of `x`

**Examples**

**Usage example**

```sql title=Query
SELECT abs(-0.5)
```

```response title=Response
0.5
```

## byteSwap {#byteSwap}

Introduced in: v23.10

Reverses the bytes of an integer, i.e. changes its [endianness](https://en.wikipedia.org/wiki/Endianness).

The below example can be worked out in the following manner:

1.Convert the base-10 integer to its equivalent hexadecimal format in big-endian format, i.e. 3351772109 -> C7 C7 FB CD (4 bytes)
2.Reverse the bytes, i.e. C7 C7 FB CD -> CD FB C7 C7
3.Convert the result back to an integer assuming big-endian, i.e. CD FB C7 C7 -> 3455829959
One use case of this function is reversing IPv4s:

```result
┌─toIPv4(byteSwap(toUInt32(toIPv4('205.251.199.199'))))─┐
│ 199.199.251.205                                       │
└───────────────────────────────────────────────────────┘
```

**Syntax**

```sql
byteSwap(x)
```

**Arguments**

- `x` — An integer value. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Returned value**

Returns `x` with bytes reversed. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT byteSwap(3351772109)
```

```response title=Response
3455829959
```

**8-bit**

```sql title=Query
SELECT byteSwap(54)
```

```response title=Response
54
```

**16-bit**

```sql title=Query
SELECT byteSwap(4135)
```

```response title=Response
10000
```

**32-bit**

```sql title=Query
SELECT byteSwap(3351772109)
```

```response title=Response
3455829959
```

**64-bit**

```sql title=Query
SELECT byteSwap(123294967295)
```

```response title=Response
18439412204227788800
```

## divide {#divide}

Introduced in: v1.1

    Calculates the quotient of two values `a` and `b`. The result type is always [Float64](/sql-reference/data-types/float).
    Integer division is provided by the `intDiv` function.

    :::note
    Division by `0` returns `inf`, `-inf`, or `nan`.
    :::
    

**Syntax**

```sql
divide(x, y)
```

**Arguments**

- `x` — Dividend - `y` — Divisor

**Returned value**

The quotient of x and y

**Examples**

**Dividing two numbers**

```sql title=Query
SELECT divide(25,5) AS quotient, toTypeName(quotient)
```

```response title=Response
5 Float64
```

**Dividing by zero**

```sql title=Query
SELECT divide(25,0)
```

```response title=Response
inf
```

## divideDecimal {#divideDecimal}

Introduced in: v22.12

Performs division on two decimals. Result value will be of type [Decimal256](/sql-reference/data-types/decimal).
Result scale can be explicitly specified by `result_scale` argument (const Integer in range `[0, 76]`). If not specified, the result scale is the max scale of given arguments.

:::note
These function work significantly slower than usual `divide`.
In case you don't really need controlled precision and/or need fast computation, consider using [divide](#divide).
:::

**Syntax**

```sql
divideDecimal(x, y[, result_scale])
```

**Arguments**

- `x` — First value: [Decimal](/sql-reference/data-types/decimal). - `y` — Second value: [Decimal](/sql-reference/data-types/decimal). - `result_scale` — Scale of result. Type [Int/UInt](/sql-reference/data-types/int-uint).

**Returned value**

The result of division with given scale. [`Decimal256`](/sql-reference/data-types/decimal)

**Examples**

**Example 1**

```sql title=Query
divideDecimal(toDecimal256(-12, 0), toDecimal32(2.1, 1), 10)
```

```response title=Response
┌─divideDecimal(toDecimal256(-12, 0), toDecimal32(2.1, 1), 10)─┐
│                                                -5.7142857142 │
└──────────────────────────────────────────────────────────────┘
```

**Example 2**

```sql title=Query
SELECT toDecimal64(-12, 1) / toDecimal32(2.1, 1);
SELECT toDecimal64(-12, 1) as a, toDecimal32(2.1, 1) as b, divideDecimal(a, b, 1), divideDecimal(a, b, 5);
```

```response title=Response
┌─divide(toDecimal64(-12, 1), toDecimal32(2.1, 1))─┐
│                                             -5.7 │
└──────────────────────────────────────────────────┘
┌───a─┬───b─┬─divideDecimal(toDecimal64(-12, 1), toDecimal32(2.1, 1), 1)─┬─divideDecimal(toDecimal64(-12, 1), toDecimal32(2.1, 1), 5)─┐
│ -12 │ 2.1 │                                                       -5.7 │                                                   -5.71428 │
└─────┴─────┴────────────────────────────────────────────────────────────┴────────────────────────────────────────────────────────────┘
```

## divideOrNull {#divideOrNull}

Introduced in: v25.5

Same as `divide` but returns NULL when dividing by zero.

**Syntax**

```sql
divideOrNull(x, y)
```

**Arguments**

- `x` — Dividend - `y` — Divisor

**Returned value**

The quotient of x and y, or NULL.

**Examples**

**Dividing by zero**

```sql title=Query
SELECT divideOrNull(25, 0)
```

```response title=Response
\N
```

## gcd {#gcd}

Introduced in: v1.1

    Returns the greatest common divisor of two values a and b.

    An exception is thrown when dividing by zero or when dividing a minimal
    negative number by minus one.
    

**Syntax**

```sql
gcd(x, y)
```

**Arguments**

- `x` — First integer - `y` — Second integer

**Returned value**

The greatest common divisor of `x` and `y`.

**Examples**

**Usage example**

```sql title=Query
SELECT gcd(12, 18)
```

```response title=Response
6
```

## ifNotFinite {#ifNotFinite}

Introduced in: v20.3

Checks whether a floating point value is finite.

You can get a similar result by using the [ternary operator](/sql-reference/functions/conditional-functions#if): `isFinite(x) ? x : y`.

**Syntax**

```sql
ifNotFinite(x,y)
```

**Arguments**

- `x` — Value to check if infinite. [`Float*`](/sql-reference/data-types/float)
- `y` — Fallback value. [`Float*`](/sql-reference/data-types/float)

**Returned value**

- `x` if `x` is finite.
- `y` if `x` is not finite.

**Examples**

**Usage example**

```sql title=Query
SELECT 1/0 AS infimum, ifNotFinite(infimum,42)
```

```response title=Response
inf  42
```

## intDiv {#intDiv}

Introduced in: v1.1

Performs an integer division of two values `x` by `y`. In other words it
computes the quotient rounded down to the next smallest integer.

The result has the same width as the dividend (the first parameter).

An exception is thrown when dividing by zero, when the quotient does not fit
in the range of the dividend, or when dividing a minimal negative number by minus one.

**Syntax**

```sql
intDiv(x, y)
```

**Arguments**

- `x` — Left hand operand. - `y` — Right hand operand.

**Returned value**

Result of integer division of `x` and `y`

**Examples**

**Integer division of two floats**

```sql title=Query
SELECT intDiv(toFloat64(1), 0.001) AS res, toTypeName(res)
```

```response title=Response
┌──res─┬─toTypeName(intDiv(toFloat64(1), 0.001))─┐
│ 1000 │ Int64                                   │
└──────┴─────────────────────────────────────────┘
```

**Quotient does not fit in the range of the dividend**

```sql title=Query
SELECT
intDiv(1, 0.001) AS res,
toTypeName(res)
```

```response title=Response
Received exception from server (version 23.2.1):
Code: 153. DB::Exception: Received from localhost:9000. DB::Exception:
Cannot perform integer division, because it will produce infinite or too
large number: While processing intDiv(1, 0.001) AS res, toTypeName(res).
(ILLEGAL_DIVISION)
```

## intDivOrNull {#intDivOrNull}

Introduced in: v25.5

Same as `intDiv` but returns NULL when dividing by zero or when dividing a
minimal negative number by minus one.

**Syntax**

```sql
intDivOrNull(x, y)
```

**Arguments**

- `x` — Left hand operand. [`(U)Int*`](/sql-reference/data-types/int-uint)
- `y` — Right hand operand. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Returned value**

Result of integer division of `x` and `y`, or NULL.

**Examples**

**Integer division by zero**

```sql title=Query
SELECT intDivOrNull(1, 0)
```

```response title=Response
\N
```

**Dividing a minimal negative number by minus 1**

```sql title=Query
SELECT intDivOrNull(-9223372036854775808, -1)
```

```response title=Response
\N
```

## intDivOrZero {#intDivOrZero}

Introduced in: v1.1

Same as `intDiv` but returns zero when dividing by zero or when dividing a
minimal negative number by minus one.

**Syntax**

```sql
intDivOrZero(a, b)
```

**Arguments**

- `a` — Left hand operand. [`(U)Int*`](/sql-reference/data-types/int-uint)
- `b` — Right hand operand. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Returned value**

Result of integer division of a and b, or zero.

**Examples**

**Integer division by zero**

```sql title=Query
SELECT intDivOrZero(1, 0)
```

```response title=Response
0
```

**Dividing a minimal negative number by minus 1**

```sql title=Query
SELECT intDivOrZero(0.05, -1)
```

```response title=Response
0
```

## isFinite {#isFinite}

Introduced in: v1.1

Returns `1` if the Float32 or Float64 argument not infinite and not a `NaN`,
otherwise this function returns `0`.

**Syntax**

```sql
isFinite(x)
```

**Arguments**

- `x` — Number to check for finiteness. [`Float*`](/sql-reference/data-types/float)

**Returned value**

`1` if x is not infinite and not `NaN`, otherwise `0`.

**Examples**

**Test if a number is finite**

```sql title=Query
SELECT isFinite(inf)
```

```response title=Response
0
```

## isInfinite {#isInfinite}

Introduced in: v1.1

    Returns `1` if the Float32 or Float64 argument is infinite, otherwise this function returns `0`.
    Note that `0` is returned for a `NaN`.
    

**Syntax**

```sql
isInfinite(x)
```

**Arguments**

- `x` — Number to check for infiniteness. [`Float*`](/sql-reference/data-types/float)

**Returned value**

`1` if x is infinite, otherwise `0` (including for `NaN`).

**Examples**

**Test if a number is infinite**

```sql title=Query
SELECT isInfinite(inf), isInfinite(NaN), isInfinite(10))
```

```response title=Response
1 0 0
```

## isNaN {#isNaN}

Introduced in: v1.1

Returns `1` if the Float32 and Float64 argument is `NaN`, otherwise returns `0`.

**Syntax**

```sql
isNaN(x)
```

**Arguments**

- `x` — Argument to evaluate for if it is `NaN`. [`Float*`](/sql-reference/data-types/float)

**Returned value**

`1` if `NaN`, otherwise `0`

**Examples**

**Usage example**

```sql title=Query
SELECT isNaN(NaN)
```

```response title=Response
1
```

## lcm {#lcm}

Introduced in: v1.1

Returns the least common multiple of two values `x` and `y`.

An exception is thrown when dividing by zero or when dividing a minimal negative number by minus one.

**Syntax**

```sql
lcm(x, y)
```

**Arguments**

- `x` — First integer. [`(U)Int*`](/sql-reference/data-types/int-uint)
- `y` — Second integer. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Returned value**

Returns the least common multiple of `x` and `y`. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Examples**

**Usage example**

```sql title=Query
SELECT lcm(6, 8)
```

```response title=Response
24
```

## max2 {#max2}

Introduced in: v21.11

    Returns the bigger of two numeric values `x` and `y`.
    

**Syntax**

```sql
max2(x, y)
```

**Arguments**

- `x` — First value [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal)
- `y` — Second value [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal)

**Returned value**

Returns the bigger value of `x` and `y`. [`Float64`](/sql-reference/data-types/float)

**Examples**

**Usage example**

```sql title=Query
SELECT max2(-1, 2)
```

```response title=Response
2
```

## min2 {#min2}

Introduced in: v21.11

    Returns the smaller of two numeric values `x` and `y`.
    

**Syntax**

```sql
min2(x, y)
```

**Arguments**

- `x` — First value [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal)
- `y` — Second value [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal)

**Returned value**

Returns the smaller value of `x` and `y`. [`Float64`](/sql-reference/data-types/float)

**Examples**

**Usage example**

```sql title=Query
SELECT min2(-1, 2)
```

```response title=Response
- 1
```

## minus {#minus}

Introduced in: v1.1

Calculates the difference of two values `a` and `b`. The result is always signed.
Similar to plus, it is possible to subtract an integer from a date or date with time.
Additionally, subtraction between date with time is supported, resulting in the time difference between them.

**Syntax**

```sql
minus(x, y)
```

**Arguments**

- `x` — Minuend. - `y` — Subtrahend.

**Returned value**

x minus y

**Examples**

**Subtracting two numbers**

```sql title=Query
SELECT minus(10, 5)
```

```response title=Response
5
```

**Subtracting an integer and a date**

```sql title=Query
SELECT minus(toDate('2025-01-01'),5)
```

```response title=Response
2024-12-27
```

## modulo {#modulo}

Introduced in: v1.1

    Calculates the remainder of the division of two values a by b.

    The result type is an integer if both inputs are integers. If one of the
    inputs is a floating-point number, the result type is Float64.

    The remainder is computed like in C++. Truncated division is used for
    negative numbers.

    An exception is thrown when dividing by zero or when dividing a minimal
    negative number by minus one.
    

**Syntax**

```sql
modulo(a, b)
```

**Arguments**

- `a` — The dividend - `b` — The divisor (modulus)

**Returned value**

The remainder of a % b

**Examples**

**Usage example**

```sql title=Query
SELECT modulo(5, 2)
```

```response title=Response
1
```

## moduloOrNull {#moduloOrNull}

Introduced in: v25.5

Calculates the remainder when dividing `a` by `b`. Similar to function `modulo` except that `moduloOrNull` will return NULL
if the right argument is 0.

**Syntax**

```sql
moduloOrNull(x, y)
```

**Arguments**

- `x` — The dividend. [`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float)
- `y` — The divisor (modulus). [`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float)

**Returned value**

Returns the remainder of the division of `x` by `y`, or null when the divisor is zero.

**Examples**

**moduloOrNull by zero**

```sql title=Query
SELECT moduloOrNull(5, 0)
```

```response title=Response
\N
```

## moduloOrZero {#moduloOrZero}

Introduced in: v20.3

Like modulo but returns zero when the divisor is zero, as opposed to an
exception with the modulo function.

**Syntax**

```sql
moduloOrZero(a, b)
```

**Arguments**

- `a` — The dividend. [`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float)
- `b` — The divisor (modulus). [`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float)

**Returned value**

Returns the remainder of a % b, or `0` when the divisor is `0`.

**Examples**

**Usage example**

```sql title=Query
SELECT moduloOrZero(5, 0)
```

```response title=Response
0
```

## multiply {#multiply}

Introduced in: v1.1

Calculates the product of two values `x` and `y`.

**Syntax**

```sql
multiply(x, y)
```

**Arguments**

- `x` — factor. [`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal)
- `y` — factor. [`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal)

**Returned value**

Returns the product of x and y

**Examples**

**Multiplying two numbers**

```sql title=Query
SELECT multiply(5,5)
```

```response title=Response
25
```

## multiplyDecimal {#multiplyDecimal}

Introduced in: v22.12

Performs multiplication on two decimals. Result value will be of type [Decimal256](/sql-reference/data-types/decimal).
Result scale can be explicitly specified by `result_scale` argument (const Integer in range `[0, 76]`). If not specified, the result scale is the max scale of given arguments.

:::note
These functions work significantly slower than usual `multiply`.
In case you don't really need controlled precision and/or need fast computation, consider using [multiply](#multiply)
:::

**Syntax**

```sql
multiplyDecimal(a, b[, result_scale])
```

**Arguments**

- `a` — First value. [`Decimal`](/sql-reference/data-types/decimal)
- `b` — Second value. [`Decimal`](/sql-reference/data-types/decimal)
- `result_scale` — Scale of result. [`(U)Int*`](/sql-reference/data-types/int-uint)

**Returned value**

The result of multiplication with the given scale. Type: [`Decimal256`](/sql-reference/data-types/decimal)

**Examples**

**Usage example**

```sql title=Query
SELECT multiplyDecimal(toDecimal256(-12, 0), toDecimal32(-2.1, 1), 1)
```

```response title=Response
25.2
```

**Difference with regular multiplication**

```sql title=Query
SELECT multiplyDecimal(toDecimal256(-12, 0), toDecimal32(-2.1, 1), 1)
```

```response title=Response
┌─multiply(toDecimal64(-12.647, 3), toDecimal32(2.1239, 4))─┐
│                                               -26.8609633 │
└───────────────────────────────────────────────────────────┘
┌─multiplyDecimal(toDecimal64(-12.647, 3), toDecimal32(2.1239, 4))─┐
│                                                         -26.8609 │
└──────────────────────────────────────────────────────────────────┘
```

**Decimal overflow**

```sql title=Query
SELECT
    toDecimal64(-12.647987876, 9) AS a,
    toDecimal64(123.967645643, 9) AS b,
    multiplyDecimal(a, b);
SELECT
    toDecimal64(-12.647987876, 9) AS a,
    toDecimal64(123.967645643, 9) AS b,
    a * b;
```

```response title=Response
┌─────────────a─┬─────────────b─┬─multiplyDecimal(toDecimal64(-12.647987876, 9), toDecimal64(123.967645643, 9))─┐
│ -12.647987876 │ 123.967645643 │                                                               -1567.941279108 │
└───────────────┴───────────────┴───────────────────────────────────────────────────────────────────────────────┘
Received exception from server (version 22.11.1):
Code: 407. DB::Exception: Received from localhost:9000. DB::Exception: Decimal math overflow:
While processing toDecimal64(-12.647987876, 9) AS a, toDecimal64(123.967645643, 9) AS b, a * b. (DECIMAL_OVERFLOW)
```

## negate {#negate}

Introduced in: v1.1

Negates the argument `x`. The result is always signed.

**Syntax**

```sql
negate(x)
```

**Arguments**

- `x` — The value to negate.

**Returned value**

Returns -x from x

**Examples**

**Usage example**

```sql title=Query
SELECT negate(10)
```

```response title=Response
- 10
```

## numericIndexedVectorAllValueSum {#numericIndexedVectorAllValueSum}

Introduced in: v25.7

Returns sum of all the value in NumericIndexedVector.

**Syntax**

```sql
numericIndexedVectorAllValueSum(numericIndexedVector)
```

**Arguments**

- `numericIndexedVector` — A NumericIndexedVector object.

**Returned value**

Numeric value which type is Float64

**Examples**

****

```sql title=Query
SELECT numericIndexedVectorAllValueSum(numericIndexedVectorBuild(mapFromArrays([1, 2, 3], [10, 20, 30]))) AS res;
```

```response title=Response
┌─res─┐
│  60 │
└─────┘
```

## numericIndexedVectorBuild {#numericIndexedVectorBuild}

Introduced in: v25.7

Creates a NumericIndexedVector from a map. The map’s keys represent the vector's index and map's value represents the vector's value.

**Syntax**

```sql
SELECT numericIndexedVectorBuild(map)
```

**Arguments**

- `map` — A mapping from index to value.

**Returned value**

NumericIndexedVector object.

**Examples**

****

```sql title=Query
SELECT numericIndexedVectorBuild(mapFromArrays([1, 2, 3], [10, 20, 30])) AS res, toTypeName(res);
```

```response title=Response
┌─res─┬─toTypeName(res)────────────────────────────────────────────┐
│     │ AggregateFunction(groupNumericIndexedVector, UInt8, UInt8) │
└─────┴────────────────────────────────────────────────────────────┘
```

## numericIndexedVectorCardinality {#numericIndexedVectorCardinality}

Introduced in: v25.7

Returns the cardinality (number of unique indexes) of the NumericIndexedVector.

**Syntax**

```sql
numericIndexedVectorCardinality(numericIndexedVector)
```

**Arguments**

- `numericIndexedVector` — A NumericIndexedVector object.

**Returned value**

Numeric value which type is UInt

**Examples**

****

```sql title=Query
SELECT numericIndexedVectorCardinality(numericIndexedVectorBuild(mapFromArrays([1, 2, 3], [10, 20, 30]))) AS res;
```

```response title=Response
┌─res─┐
│  3  │
└─────┘
```

## numericIndexedVectorGetValue {#numericIndexedVectorGetValue}

Introduced in: v25.7

Retrieves the value corresponding to a specified index.

**Syntax**

```sql
numericIndexedVectorGetValue(numericIndexedVector, index)
```

**Arguments**

- `numericIndexedVector` — A NumericIndexedVector object. - `index` — The index for which the value is to be retrieved.

**Returned value**

A Numeric value with the same type as the value type of NumericIndexedVector.

**Examples**

****

```sql title=Query
SELECT numericIndexedVectorGetValue(numericIndexedVectorBuild(mapFromArrays([1, 2, 3], [10, 20, 30])), 3) AS res;
```

```response title=Response
┌─res─┐
│  30 │
└─────┘
```

## numericIndexedVectorPointwiseAdd {#numericIndexedVectorPointwiseAdd}

Introduced in: v25.7

Performs pointwise addition between a NumericIndexedVector and either another NumericIndexedVector or a numeric constant. The function returns a new NumericIndexedVector.

**Syntax**

```sql
numericIndexedVectorPointwiseAdd(numericIndexedVector, numericIndexedVector | numeric)
```

**Arguments**

- `numericIndexedVector` — A NumericIndexedVector object. - `numeric` — A numeric constant

**Returned value**

NumericIndexedVector object.

**Examples**

****

```sql title=Query
with
    numericIndexedVectorBuild(mapFromArrays([1, 2, 3], arrayMap(x -> toInt32(x), [10, 20, 30]))) as vec1,
    numericIndexedVectorBuild(mapFromArrays([2, 3, 4], arrayMap(x -> toInt32(x), [10, 20, 30]))) as vec2
SELECT
    numericIndexedVectorToMap(numericIndexedVectorPointwiseAdd(vec1, vec2)) AS res1,
    numericIndexedVectorToMap(numericIndexedVectorPointwiseAdd(vec1, 2)) AS res2;
```

```response title=Response
┌─res1──────────────────┬─res2─────────────┐
│ {1:10,2:30,3:50,4:30} │ {1:12,2:22,3:32} │
└───────────────────────┴──────────────────┘
```

## numericIndexedVectorPointwiseDivide {#numericIndexedVectorPointwiseDivide}

Introduced in: v25.7

Performs pointwise division between a NumericIndexedVector and either another NumericIndexedVector or a numeric constant. The function returns a new NumericIndexedVector.

**Syntax**

```sql
numericIndexedVectorPointwiseDivide(numericIndexedVector, numericIndexedVector | numeric)
```

**Arguments**

- `numericIndexedVector` — A NumericIndexedVector object. - `numeric` — A numeric constant

**Returned value**

NumericIndexedVector object.

**Examples**

****

```sql title=Query
with
    numericIndexedVectorBuild(mapFromArrays([1, 2, 3], arrayMap(x -> toFloat64(x), [10, 20, 30]))) as vec1,
    numericIndexedVectorBuild(mapFromArrays([2, 3, 4], arrayMap(x -> toFloat64(x), [10, 20, 30]))) as vec2
SELECT
    numericIndexedVectorToMap(numericIndexedVectorPointwiseDivide(vec1, vec2)) AS res1,
    numericIndexedVectorToMap(numericIndexedVectorPointwiseDivide(vec1, 2)) AS res2;
```

```response title=Response
┌─res1────────┬─res2────────────┐
│ {2:2,3:1.5} │ {1:5,2:10,3:15} │
└─────────────┴─────────────────┘
```

## numericIndexedVectorPointwiseEqual {#numericIndexedVectorPointwiseEqual}

Introduced in: v25.7

Performs pointwise comparison between a NumericIndexedVector and either another NumericIndexedVector or a numeric constant. The result is a NumericIndexedVector containing the indices where the values are equal, with all corresponding value set to 1.

**Syntax**

```sql
numericIndexedVectorPointwiseEqual(numericIndexedVector, numericIndexedVector | numeric)
```

**Arguments**

- `numericIndexedVector` — A NumericIndexedVector object. - `numeric` — A numeric constant

**Returned value**

NumericIndexedVector object.

**Examples**

****

```sql title=Query
with
    numericIndexedVectorBuild(mapFromArrays([1, 2, 3], arrayMap(x -> toFloat64(x), [10, 20, 30]))) as vec1,
    numericIndexedVectorBuild(mapFromArrays([2, 3, 4], arrayMap(x -> toFloat64(x), [20, 20, 30]))) as vec2
SELECT
    numericIndexedVectorToMap(numericIndexedVectorPointwiseEqual(vec1, vec2)) AS res1,
    numericIndexedVectorToMap(numericIndexedVectorPointwiseEqual(vec1, 20)) AS res2;
```

```response title=Response
┌─res1──┬─res2──┐
│ {2:1} │ {2:1} │
└───────┴───────┘
```

## numericIndexedVectorPointwiseGreater {#numericIndexedVectorPointwiseGreater}

Introduced in: v25.7

Performs pointwise comparison between a NumericIndexedVector and either another NumericIndexedVector or a numeric constant. The result is a NumericIndexedVector containing the indices where the first vector’s value is greater than the second vector’s value, with all corresponding value set to 1.

**Syntax**

```sql
numericIndexedVectorPointwiseGreater(numericIndexedVector, numericIndexedVector | numeric)
```

**Arguments**

- `numericIndexedVector` — A NumericIndexedVector object. - `numeric` — A numeric constant

**Returned value**

NumericIndexedVector object.

**Examples**

****

```sql title=Query
with
    numericIndexedVectorBuild(mapFromArrays([1, 2, 3], arrayMap(x -> toFloat64(x), [10, 20, 50]))) as vec1,
    numericIndexedVectorBuild(mapFromArrays([2, 3, 4], arrayMap(x -> toFloat64(x), [20, 40, 30]))) as vec2
SELECT
    numericIndexedVectorToMap(numericIndexedVectorPointwiseGreater(vec1, vec2)) AS res1,
    numericIndexedVectorToMap(numericIndexedVectorPointwiseGreater(vec1, 20)) AS res2;
```

```response title=Response
┌─res1──────┬─res2──┐
│ {1:1,3:1} │ {3:1} │
└───────────┴───────┘
```

## numericIndexedVectorPointwiseGreaterEqual {#numericIndexedVectorPointwiseGreaterEqual}

Introduced in: v25.7

Performs pointwise comparison between a NumericIndexedVector and either another NumericIndexedVector or a numeric constant. The result is a NumericIndexedVector containing the indices where the first vector’s value is greater than or equal to the second vector’s value, with all corresponding value set to 1.

**Syntax**

```sql
numericIndexedVectorPointwiseGreaterEqual(numericIndexedVector, numericIndexedVector | numeric)
```

**Arguments**

- `numericIndexedVector` — A NumericIndexedVector object. - `numeric` — A numeric constant

**Returned value**

NumericIndexedVector object.

**Examples**

****

```sql title=Query
with
    numericIndexedVectorBuild(mapFromArrays([1, 2, 3], arrayMap(x -> toFloat64(x), [10, 20, 50]))) as vec1,
    numericIndexedVectorBuild(mapFromArrays([2, 3, 4], arrayMap(x -> toFloat64(x), [20, 40, 30]))) as vec2
SELECT
    numericIndexedVectorToMap(numericIndexedVectorPointwiseGreaterEqual(vec1, vec2)) AS res1,
    numericIndexedVectorToMap(numericIndexedVectorPointwiseGreaterEqual(vec1, 20)) AS res2;
```

```response title=Response
┌─res1──────────┬─res2──────┐
│ {1:1,2:1,3:1} │ {2:1,3:1} │
└───────────────┴───────────┘
```

## numericIndexedVectorPointwiseLess {#numericIndexedVectorPointwiseLess}

Introduced in: v25.7

Performs pointwise comparison between a NumericIndexedVector and either another NumericIndexedVector or a numeric constant. The result is a NumericIndexedVector containing the indices where the first vector’s value is less than the second vector’s value, with all corresponding value set to 1.

**Syntax**

```sql
numericIndexedVectorPointwiseLess(numericIndexedVector, numericIndexedVector | numeric)
```

**Arguments**

- `numericIndexedVector` — A NumericIndexedVector object. - `numeric` — A numeric constant

**Returned value**

NumericIndexedVector object.

**Examples**

****

```sql title=Query
with
    numericIndexedVectorBuild(mapFromArrays([1, 2, 3], arrayMap(x -> toFloat64(x), [10, 20, 30]))) as vec1,
    numericIndexedVectorBuild(mapFromArrays([2, 3, 4], arrayMap(x -> toFloat64(x), [20, 40, 30]))) as vec2
SELECT
    numericIndexedVectorToMap(numericIndexedVectorPointwiseLess(vec1, vec2)) AS res1,
    numericIndexedVectorToMap(numericIndexedVectorPointwiseLess(vec1, 20)) AS res2;
```

```response title=Response
┌─res1──────┬─res2──┐
│ {3:1,4:1} │ {1:1} │
└───────────┴───────┘
```

## numericIndexedVectorPointwiseLessEqual {#numericIndexedVectorPointwiseLessEqual}

Introduced in: v25.7

Performs pointwise comparison between a NumericIndexedVector and either another NumericIndexedVector or a numeric constant. The result is a NumericIndexedVector containing the indices where the first vector’s value is less than or equal to the second vector’s value, with all corresponding value set to 1.

**Syntax**

```sql
numericIndexedVectorPointwiseLessEqual(numericIndexedVector, numericIndexedVector | numeric)
```

**Arguments**

- `numericIndexedVector` — A NumericIndexedVector object. - `numeric` — A numeric constant

**Returned value**

NumericIndexedVector object.

**Examples**

****

```sql title=Query
with
    numericIndexedVectorBuild(mapFromArrays([1, 2, 3], arrayMap(x -> toFloat64(x), [10, 20, 30]))) as vec1,
    numericIndexedVectorBuild(mapFromArrays([2, 3, 4], arrayMap(x -> toFloat64(x), [20, 40, 30]))) as vec2
SELECT
    numericIndexedVectorToMap(numericIndexedVectorPointwiseLessEqual(vec1, vec2)) AS res1,
    numericIndexedVectorToMap(numericIndexedVectorPointwiseLessEqual(vec1, 20)) AS res2;
```

```response title=Response
┌─res1──────────┬─res2──────┐
│ {2:1,3:1,4:1} │ {1:1,2:1} │
└───────────────┴───────────┘
```

## numericIndexedVectorPointwiseMultiply {#numericIndexedVectorPointwiseMultiply}

Introduced in: v25.7

Performs pointwise multiplication between a NumericIndexedVector and either another NumericIndexedVector or a numeric constant. The function returns a new NumericIndexedVector.

**Syntax**

```sql
numericIndexedVectorPointwiseMultiply(numericIndexedVector, numericIndexedVector | numeric)
```

**Arguments**

- `numericIndexedVector` — A NumericIndexedVector object. - `numeric` — A numeric constant

**Returned value**

NumericIndexedVector object.

**Examples**

****

```sql title=Query
with
    numericIndexedVectorBuild(mapFromArrays([1, 2, 3], arrayMap(x -> toInt32(x), [10, 20, 30]))) as vec1,
    numericIndexedVectorBuild(mapFromArrays([2, 3, 4], arrayMap(x -> toInt32(x), [10, 20, 30]))) as vec2
SELECT
    numericIndexedVectorToMap(numericIndexedVectorPointwiseMultiply(vec1, vec2)) AS res1,
    numericIndexedVectorToMap(numericIndexedVectorPointwiseMultiply(vec1, 2)) AS res2;
```

```response title=Response
┌─res1──────────┬─res2─────────────┐
│ {2:200,3:600} │ {1:20,2:40,3:60} │
└───────────────┴──────────────────┘
```

## numericIndexedVectorPointwiseNotEqual {#numericIndexedVectorPointwiseNotEqual}

Introduced in: v25.7

Performs pointwise comparison between a NumericIndexedVector and either another NumericIndexedVector or a numeric constant.  The result is a NumericIndexedVector containing the indices where the values are not equal, with all corresponding value set to 1.

**Syntax**

```sql
numericIndexedVectorPointwiseNotEqual(numericIndexedVector, numericIndexedVector | numeric)
```

**Arguments**

- `numericIndexedVector` — A NumericIndexedVector object. - `numeric` — A numeric constant

**Returned value**

NumericIndexedVector object.

**Examples**

****

```sql title=Query
with
    numericIndexedVectorBuild(mapFromArrays([1, 2, 3], arrayMap(x -> toFloat64(x), [10, 20, 30]))) as vec1,
    numericIndexedVectorBuild(mapFromArrays([2, 3, 4], arrayMap(x -> toFloat64(x), [20, 20, 30]))) as vec2
SELECT
    numericIndexedVectorToMap(numericIndexedVectorPointwiseNotEqual(vec1, vec2)) AS res1,
    numericIndexedVectorToMap(numericIndexedVectorPointwiseNotEqual(vec1, 20)) AS res2;
```

```response title=Response
┌─res1──────────┬─res2──────┐
│ {1:1,3:1,4:1} │ {1:1,3:1} │
└───────────────┴───────────┘
```

## numericIndexedVectorPointwiseSubtract {#numericIndexedVectorPointwiseSubtract}

Introduced in: v25.7

Performs pointwise subtraction between a NumericIndexedVector and either another NumericIndexedVector or a numeric constant. The function returns a new NumericIndexedVector.

**Syntax**

```sql
numericIndexedVectorPointwiseSubtract(numericIndexedVector, numericIndexedVector | numeric)
```

**Arguments**

- `numericIndexedVector` — A NumericIndexedVector object. - `numeric` — A numeric constant

**Returned value**

NumericIndexedVector object.

**Examples**

****

```sql title=Query
with
    numericIndexedVectorBuild(mapFromArrays([1, 2, 3], arrayMap(x -> toInt32(x), [10, 20, 30]))) as vec1,
    numericIndexedVectorBuild(mapFromArrays([2, 3, 4], arrayMap(x -> toInt32(x), [10, 20, 30]))) as vec2
SELECT
    numericIndexedVectorToMap(numericIndexedVectorPointwiseSubtract(vec1, vec2)) AS res1,
    numericIndexedVectorToMap(numericIndexedVectorPointwiseSubtract(vec1, 2)) AS res2;
```

```response title=Response
┌─res1───────────────────┬─res2────────────┐
│ {1:10,2:10,3:10,4:-30} │ {1:8,2:18,3:28} │
└────────────────────────┴─────────────────┘
```

## numericIndexedVectorShortDebugString {#numericIndexedVectorShortDebugString}

Introduced in: v25.7

Returns internal information of the NumericIndexedVector in a json format. This function is primarily used for debugging purposes.

**Syntax**

```sql
numericIndexedVectorShortDebugString(numericIndexedVector)
```

**Arguments**

- `numericIndexedVector` — A NumericIndexedVector object.

**Returned value**

String

**Examples**

****

```sql title=Query
SELECT numericIndexedVectorShortDebugString(numericIndexedVectorBuild(mapFromArrays([1, 2, 3], [10, 20, 30]))) AS res\G;
```

```response title=Response
Row 1:
──────
res: {"vector_type":"BSI","index_type":"char8_t","value_type":"char8_t","integer_bit_num":8,"fraction_bit_num":0,"zero_indexes_info":{"cardinality":"0"},"non_zero_indexes_info":{"total_cardinality":"3","all_value_sum":60,"number_of_bitmaps":"8","bitmap_info":{"cardinality":{"0":"0","1":"2","2":"2","3":"2","4":"2","5":"0","6":"0","7":"0"}}}}
```

## numericIndexedVectorToMap {#numericIndexedVectorToMap}

Introduced in: v25.7

Converts a NumericIndexedVector to a map.

**Syntax**

```sql
numericIndexedVectorToMap(numericIndexedVector)
```

**Arguments**

- `numericIndexedVector` — A NumericIndexedVector object.

**Returned value**

Map(IndexType, ValueType)

**Examples**

****

```sql title=Query
SELECT numericIndexedVectorToMap(numericIndexedVectorBuild(mapFromArrays([1, 2, 3], [10, 20, 30]))) AS res;
```

```response title=Response
┌─res──────────────┐
│ {1:10,2:20,3:30} │
└──────────────────┘
```

## plus {#plus}

Introduced in: v1.1

Calculates the sum of two values `x` and `y`. Alias: `x + y` (operator).
It is possible to add an integer and a date or date with time. The former
operation increments the number of days in the date, the latter operation
increments the number of seconds in the date with time.

**Syntax**

```sql
plus(x, y)
```

**Arguments**

- `x` — Left hand operand. - `y` — Right hand operand.

**Returned value**

Returns the sum of x and y

**Examples**

**Adding two numbers**

```sql title=Query
SELECT plus(5,5)
```

```response title=Response
10
```

**Adding an integer and a date**

```sql title=Query
SELECT plus(toDate('2025-01-01'),5)
```

```response title=Response
2025-01-06
```

## positiveModulo {#positiveModulo}

Introduced in: v22.11

Calculates the remainder when dividing `x` by `y`. Similar to function
`modulo` except that `positiveModulo` always return non-negative number.

**Syntax**

```sql
positiveModulo(x, y)
```

**Arguments**

- `x` — The dividend. [`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal)
- `y` — The divisor (modulus). [`(U)Int*`](/sql-reference/data-types/int-uint) or [`Float*`](/sql-reference/data-types/float) or [`Decimal`](/sql-reference/data-types/decimal)

**Returned value**

Returns the difference between `x` and the nearest integer not greater than
`x` divisible by `y`.

**Examples**

**Usage example**

```sql title=Query
SELECT positiveModulo(-1, 10)
```

```response title=Response
9
```

## positiveModuloOrNull {#positiveModuloOrNull}

Introduced in: v25.5

Calculates the remainder when dividing `a` by `b`. Similar to function `positiveModulo` except that `positiveModuloOrNull` will return NULL
if the right argument is 0.

**Syntax**

```sql
positiveModuloOrNull(x, y)
```

**Arguments**

- `x` — The dividend. [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float). - `x` — The divisor (modulus). [`(U)Int*`](/sql-reference/data-types/int-uint)/[`Float32/64`](/sql-reference/data-types/float).

**Returned value**

Returns the difference between `x` and the nearest integer not greater than
`x` divisible by `y`, `null` when the divisor is zero.

**Examples**

**positiveModuloOrNull**

```sql title=Query
SELECT positiveModuloOrNull(5, 0)
```

```response title=Response
\N
```

<!--AUTOGENERATED_END-->
