---
machine_translated: true
machine_translated_rev: 72537a2d527c63c07aa5d2361a8829f3895cf2bd
toc_priority: 36
toc_title: "\u0633\u0642\u0648\u0637 \u063A\u0630\u0627\u06CC \u0627\u0635\u0644\u06CC"
---

# سقوط غذای اصلی {#table_engine-collapsingmergetree}

موتور به ارث می برد از [ادغام](mergetree.md) و می افزاید: منطق ردیف سقوط به قطعات داده الگوریتم ادغام.

`CollapsingMergeTree` ناهمزمان حذف (فرو می ریزد) جفت ردیف اگر همه از زمینه ها در یک کلید مرتب سازی (`ORDER BY`) معادل به استثنای زمینه خاص است `Sign` که می تواند داشته باشد `1` و `-1` ارزشهای خبری عبارتند از: ردیف بدون یک جفت نگهداری می شوند. برای اطلاعات بیشتر نگاه کنید به [سقوط](#table_engine-collapsingmergetree-collapsing) بخش از سند.

موتور ممکن است به طور قابل توجهی حجم ذخیره سازی را کاهش دهد و بهره وری را افزایش دهد `SELECT` پرس و جو به عنوان یک نتیجه.

## ایجاد یک جدول {#creating-a-table}

``` sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    name1 [type1] [DEFAULT|MATERIALIZED|ALIAS expr1],
    name2 [type2] [DEFAULT|MATERIALIZED|ALIAS expr2],
    ...
) ENGINE = CollapsingMergeTree(sign)
[PARTITION BY expr]
[ORDER BY expr]
[SAMPLE BY expr]
[SETTINGS name=value, ...]
```

برای شرح پارامترهای پرس و جو, دیدن [توضیحات پرس و جو](../../../sql-reference/statements/create.md).

**پارامترهای پیش ساخته**

-   `sign` — Name of the column with the type of row: `1` یک “state” سطر, `-1` یک “cancel” پارو زدن.

    Column data type — `Int8`.

**بندهای پرسوجو**

هنگام ایجاد یک `CollapsingMergeTree` جدول, همان [بندهای پرسوجو](mergetree.md#table_engine-mergetree-creating-a-table) در هنگام ایجاد یک مورد نیاز است `MergeTree` جدول

<details markdown="1">

<summary>روش منسوخ برای ایجاد یک جدول</summary>

!!! attention "توجه"
    هنوز این روش در پروژه های جدید استفاده کنید و, در صورت امکان, تغییر پروژه های قدیمی به روش بالا توضیح.

``` sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    name1 [type1] [DEFAULT|MATERIALIZED|ALIAS expr1],
    name2 [type2] [DEFAULT|MATERIALIZED|ALIAS expr2],
    ...
) ENGINE [=] CollapsingMergeTree(date-column [, sampling_expression], (primary, key), index_granularity, sign)
```

همه پارامترها به استثنای `sign` همان معنی را در `MergeTree`.

-   `sign` — Name of the column with the type of row: `1` — “state” سطر, `-1` — “cancel” پارو زدن.

    Column Data Type — `Int8`.

</details>

## سقوط {#table_engine-collapsingmergetree-collapsing}

### داده {#data}

وضعیت جایی که شما نیاز به ذخیره به طور مداوم در حال تغییر داده ها برای برخی از شی را در نظر بگیرید. برای تلفن های موبایل منطقی به یک ردیف برای یک شی و به روز رسانی در هر تغییر, اما عملیات به روز رسانی گران و کند برای سندرم تونل کارپ است چرا که نیاز به بازنویسی از داده ها در ذخیره سازی. اگر شما نیاز به نوشتن داده ها به سرعت, به روز رسانی قابل قبول نیست, اما شما می توانید تغییرات یک شی پی در پی به شرح زیر ارسال.

استفاده از ستون خاص `Sign`. اگر `Sign = 1` این بدان معنی است که ردیف دولت از یک شی است, اجازه دهید اسمش را “state” پارو زدن. اگر `Sign = -1` به این معنی لغو دولت از یک شی با ویژگی های مشابه, اجازه دهید اسمش را “cancel” پارو زدن.

برای مثال ما می خواهیم برای محاسبه چقدر صفحات کاربران بررسی می شود در برخی از سایت و چه مدت وجود دارد. در برخی از لحظه ما ارسال ردیف زیر را با دولت از فعالیت های کاربر:

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         5 │      146 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

در چند لحظه بعد ما تغییر فعالیت کاربر را ثبت می کنیم و با دو ردیف زیر می نویسیم.

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         5 │      146 │   -1 │
│ 4324182021466249494 │         6 │      185 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

ردیف اول لغو حالت قبلی از جسم (کاربر). این باید زمینه های کلیدی مرتب سازی دولت لغو به استثنای کپی کنید `Sign`.

ردیف دوم شامل وضعیت فعلی.

همانطور که ما نیاز به تنها دولت گذشته از فعالیت های کاربر, ردیف

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         5 │      146 │    1 │
│ 4324182021466249494 │         5 │      146 │   -1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

می توان حذف سقوط نامعتبر (قدیمی) دولت از یک شی. `CollapsingMergeTree` این کار در حالی که ادغام قطعات داده.

چرا ما نیاز به 2 ردیف برای هر تغییر در خواندن [الگوریتم](#table_engine-collapsingmergetree-collapsing-algorithm) بند بند بند.

**خواص عجیب و غریب چنین رویکردی**

1.  برنامه ای که می نویسد داده ها باید به یاد داشته باشید دولت از یک شی قادر به لغو. “Cancel” رشته باید نسخه هایی از زمینه های کلیدی مرتب سازی شامل “state” رشته و مخالف `Sign`. این افزایش اندازه اولیه ذخیره سازی اما اجازه می دهد تا به نوشتن داده ها به سرعت.
2.  در حال رشد طولانی در ستون کاهش بهره وری از موتور با توجه به بار برای نوشتن. داده های ساده تر, بالاتر بهره وری.
3.  این `SELECT` نتایج به شدت بستگی به قوام شی تغییر تاریخ. هنگام تهیه داده ها برای قرار دادن دقیق باشید. شما می توانید نتایج غیر قابل پیش بینی در اطلاعات متناقض برای مثال مقادیر منفی برای معیارهای غیر منفی مانند جلسه عمق.

### الگوریتم {#table_engine-collapsingmergetree-collapsing-algorithm}

هنگامی که تاتر ادغام قطعات داده, هر گروه از ردیف متوالی با کلید مرتب سازی همان (`ORDER BY`) به بیش از دو ردیف کاهش می یابد, یکی با `Sign = 1` (“state” ردیف) و دیگری با `Sign = -1` (“cancel” ردیف). به عبارت دیگر, سقوط نوشته.

برای هر یک از داده ها در نتیجه بخشی تاتر موجب صرفه جویی در:

1.  اولین “cancel” و گذشته “state” ردیف, اگر تعداد “state” و “cancel” ردیف مسابقات و ردیف گذشته است “state” پارو زدن.
2.  گذشته “state” ردیف, اگر بیشتر وجود دارد “state” سطر از “cancel” ردیف
3.  اولین “cancel” ردیف, اگر بیشتر وجود دارد “cancel” سطر از “state” ردیف
4.  هیچ یک از ردیف, در تمام موارد دیگر.

همچنین زمانی که حداقل وجود دارد 2 بیشتر “state” سطر از “cancel” ردیف یا حداقل 2 بیشتر “cancel” سپس سطرها “state” ردیف, ادغام ادامه, اما تاتر این وضعیت رفتار به عنوان یک خطای منطقی و ثبت در ورود به سیستم سرور. این خطا می تواند رخ دهد اگر داده های مشابه بیش از یک بار قرار داده شد.

بدین ترتیب, سقوط باید نتایج حاصل از محاسبه ارقام تغییر نمی.
تغییرات به تدریج فرو ریخت به طوری که در پایان تنها دولت گذشته تقریبا در هر شی را ترک کرد.

این `Sign` لازم است زیرا الگوریتم ادغام تضمین نمی کند که تمام ردیف ها با کلید مرتب سازی مشابه در بخش داده های مشابه و حتی در همان سرور فیزیکی باشد. روند کلیک `SELECT` نمایش داده شد با موضوعات مختلف و می تواند منظور از ردیف در نتیجه پیش بینی نیست. تجمع مورد نیاز است اگر نیاز به طور کامل وجود دارد “collapsed” داده ها از `CollapsingMergeTree` جدول

برای نهایی سقوط, نوشتن یک پرس و جو با `GROUP BY` بند و مجموع توابع است که برای ثبت نام حساب. برای مثال برای محاسبه مقدار استفاده کنید `sum(Sign)` به جای `count()`. برای محاسبه مجموع چیزی استفاده کنید `sum(Sign * x)` به جای `sum(x)` و به همین ترتیب و همچنین اضافه کنید `HAVING sum(Sign) > 0`.

مصالح `count`, `sum` و `avg` می تواند محاسبه این راه. مجموع `uniq` می تواند محاسبه شود اگر یک شی حداقل یک دولت سقوط نیست. مصالح `min` و `max` محاسبه نشد زیرا `CollapsingMergeTree` می کند تاریخ ارزش از کشورهای سقوط را نجات دهد.

اگر شما نیاز به استخراج داده ها بدون تجمع (مثلا, برای بررسی اینکه ردیف در حال حاضر که جدیدترین ارزش مطابقت با شرایط خاص هستند), شما می توانید با استفاده از `FINAL` تغییردهنده برای `FROM` بند بند. این رویکرد به طور قابل توجهی کمتر موثر است.

## مثال استفاده {#example-of-use}

اطلاعات نمونه:

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         5 │      146 │    1 │
│ 4324182021466249494 │         5 │      146 │   -1 │
│ 4324182021466249494 │         6 │      185 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

ایجاد جدول:

``` sql
CREATE TABLE UAct
(
    UserID UInt64,
    PageViews UInt8,
    Duration UInt8,
    Sign Int8
)
ENGINE = CollapsingMergeTree(Sign)
ORDER BY UserID
```

درج داده ها:

``` sql
INSERT INTO UAct VALUES (4324182021466249494, 5, 146, 1)
```

``` sql
INSERT INTO UAct VALUES (4324182021466249494, 5, 146, -1),(4324182021466249494, 6, 185, 1)
```

ما با استفاده از دو `INSERT` نمایش داده شد برای ایجاد دو بخش داده های مختلف. اگر ما وارد کردن داده ها با یک پرس و جو تاتر ایجاد یک بخش داده ها و هر گونه ادغام تا کنون انجام نمی.

گرفتن داده ها:

``` sql
SELECT * FROM UAct
```

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         5 │      146 │   -1 │
│ 4324182021466249494 │         6 │      185 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         5 │      146 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

چه ما را ببینید و جایی که در حال سقوط است?

با دو `INSERT` نمایش داده شد, ما ایجاد 2 قطعات داده. این `SELECT` پرس و جو در انجام شد 2 موضوعات, و ما یک نظم تصادفی از ردیف کردم. سقوط رخ داده است چرا که هیچ ادغام از قطعات داده وجود دارد و در عین حال. تاتر ادغام بخش داده ها در یک لحظه ناشناخته که ما نمی توانیم پیش بینی.

بنابراین ما نیاز به تجمع:

``` sql
SELECT
    UserID,
    sum(PageViews * Sign) AS PageViews,
    sum(Duration * Sign) AS Duration
FROM UAct
GROUP BY UserID
HAVING sum(Sign) > 0
```

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┐
│ 4324182021466249494 │         6 │      185 │
└─────────────────────┴───────────┴──────────┘
```

اگر ما تجمع نیاز ندارد و می خواهید به زور سقوط, ما می توانیم با استفاده از `FINAL` تغییردهنده برای `FROM` بند بند.

``` sql
SELECT * FROM UAct FINAL
```

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         6 │      185 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

این روش انتخاب داده ها بسیار کم است. برای میزهای بزرگ ازش استفاده نکن

## نمونه ای از روش دیگری {#example-of-another-approach}

اطلاعات نمونه:

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         5 │      146 │    1 │
│ 4324182021466249494 │        -5 │     -146 │   -1 │
│ 4324182021466249494 │         6 │      185 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

ایده این است که ادغام را به حساب تنها زمینه های کلیدی. و در “Cancel” خط ما می توانیم مقادیر منفی که برابر نسخه های قبلی از ردیف در هنگام جمع بدون استفاده از ستون نشانه را مشخص کنید. برای این روش لازم است نوع داده را تغییر دهید `PageViews`,`Duration` برای ذخیره مقادیر منفی از UInt8 -\> Int16.

``` sql
CREATE TABLE UAct
(
    UserID UInt64,
    PageViews Int16,
    Duration Int16,
    Sign Int8
)
ENGINE = CollapsingMergeTree(Sign)
ORDER BY UserID
```

بیایید روش را تست کنیم:

``` sql
insert into UAct values(4324182021466249494,  5,  146,  1);
insert into UAct values(4324182021466249494, -5, -146, -1);
insert into UAct values(4324182021466249494,  6,  185,  1);

select * from UAct final; // avoid using final in production (just for a test or small tables)
```

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         6 │      185 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

``` sql
SELECT
    UserID,
    sum(PageViews) AS PageViews,
    sum(Duration) AS Duration
FROM UAct
GROUP BY UserID
```text
┌──────────────UserID─┬─PageViews─┬─Duration─┐
│ 4324182021466249494 │         6 │      185 │
└─────────────────────┴───────────┴──────────┘
```

``` sqk
select count() FROM UAct
```

``` text
┌─count()─┐
│       3 │
└─────────┘
```

``` sql
optimize table UAct final;

select * FROM UAct
```

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┐
│ 4324182021466249494 │         6 │      185 │    1 │
└─────────────────────┴───────────┴──────────┴──────┘
```

[مقاله اصلی](https://clickhouse.tech/docs/en/operations/table_engines/collapsingmergetree/) <!--hide-->
