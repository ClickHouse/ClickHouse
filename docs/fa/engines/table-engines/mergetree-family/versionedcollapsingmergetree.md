---
machine_translated: true
machine_translated_rev: 72537a2d527c63c07aa5d2361a8829f3895cf2bd
toc_priority: 37
toc_title: "\u062F\u0631 \u062D\u0627\u0644 \u0628\u0627\u0631\u06AF\u0630\u0627\u0631\
  \u06CC"
---

# در حال بارگذاری {#versionedcollapsingmergetree}

این موتور:

-   اجازه می دهد تا نوشتن سریع از کشورهای شی که به طور مستمر در حال تغییر.
-   حذف کشورهای شی قدیمی در پس زمینه. این به طور قابل توجهی حجم ذخیره سازی را کاهش می دهد.

بخش را ببینید [سقوط](#table_engines_versionedcollapsingmergetree) برای اطلاعات بیشتر.

موتور به ارث می برد از [ادغام](mergetree.md#table_engines-mergetree) و می افزاید: منطق برای سقوط ردیف به الگوریتم برای ادغام قطعات داده. `VersionedCollapsingMergeTree` در خدمت همان هدف به عنوان [سقوط غذای اصلی](collapsingmergetree.md) اما با استفاده از یک الگوریتم سقوط های مختلف است که اجازه می دهد تا قرار دادن داده ها در هر جهت با موضوعات متعدد. به خصوص `Version` ستون کمک می کند تا به سقوط ردیف درستی حتی در صورتی که در جهت اشتباه قرار داده شده. در مقابل, `CollapsingMergeTree` اجازه می دهد تا درج تنها به شدت متوالی.

## ایجاد یک جدول {#creating-a-table}

``` sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    name1 [type1] [DEFAULT|MATERIALIZED|ALIAS expr1],
    name2 [type2] [DEFAULT|MATERIALIZED|ALIAS expr2],
    ...
) ENGINE = VersionedCollapsingMergeTree(sign, version)
[PARTITION BY expr]
[ORDER BY expr]
[SAMPLE BY expr]
[SETTINGS name=value, ...]
```

برای شرح پارامترهای پرس و جو, دیدن [توضیحات پرس و جو](../../../sql-reference/statements/create.md).

**پارامترهای موتور**

``` sql
VersionedCollapsingMergeTree(sign, version)
```

-   `sign` — Name of the column with the type of row: `1` یک “state” سطر, `-1` یک “cancel” پارو زدن.

    نوع داده ستون باید باشد `Int8`.

-   `version` — Name of the column with the version of the object state.

    نوع داده ستون باید باشد `UInt*`.

**بندهای پرسوجو**

هنگام ایجاد یک `VersionedCollapsingMergeTree` جدول, همان [بند](mergetree.md) در هنگام ایجاد یک مورد نیاز است `MergeTree` جدول

<details markdown="1">

<summary>روش منسوخ برای ایجاد یک جدول</summary>

!!! attention "توجه"
    از این روش در پروژه های جدید استفاده نکنید. در صورت امکان, تغییر پروژه های قدیمی به روش بالا توضیح.

``` sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    name1 [type1] [DEFAULT|MATERIALIZED|ALIAS expr1],
    name2 [type2] [DEFAULT|MATERIALIZED|ALIAS expr2],
    ...
) ENGINE [=] VersionedCollapsingMergeTree(date-column [, samp#table_engines_versionedcollapsingmergetreeling_expression], (primary, key), index_granularity, sign, version)
```

همه پارامترها به جز `sign` و `version` همان معنی را در `MergeTree`.

-   `sign` — Name of the column with the type of row: `1` یک “state” سطر, `-1` یک “cancel” پارو زدن.

    Column Data Type — `Int8`.

-   `version` — Name of the column with the version of the object state.

    نوع داده ستون باید باشد `UInt*`.

</details>

## سقوط {#table_engines_versionedcollapsingmergetree}

### داده {#data}

در نظر بگیرید یک وضعیت که شما نیاز به ذخیره به طور مداوم در حال تغییر داده ها برای برخی از شی. این منطقی است که یک ردیف برای یک شی و به روز رسانی ردیف هر زمان که تغییرات وجود دارد. با این حال, عملیات به روز رسانی گران و کند برای یک سندرم تونل کارپ است چرا که نیاز به بازنویسی داده ها در ذخیره سازی. به روز رسانی قابل قبول نیست اگر شما نیاز به نوشتن داده ها به سرعت, اما شما می توانید تغییرات را به یک شی پی در پی به شرح زیر ارسال.

استفاده از `Sign` ستون هنگام نوشتن ردیف. اگر `Sign = 1` این بدان معنی است که ردیف دولت از یک شی است (اجازه دهید این تماس “state” ردیف). اگر `Sign = -1` این نشان می دهد لغو دولت از یک شی با ویژگی های مشابه (اجازه دهید این پاسخ “cancel” ردیف). همچنین از `Version` ستون, که باید هر ایالت از یک شی با یک عدد جداگانه شناسایی.

مثلا, ما می خواهیم برای محاسبه تعداد صفحات کاربران در برخی از سایت بازدید و چه مدت وجود دارد. در برخی از نقطه در زمان ما ارسال ردیف زیر را با دولت از فعالیت های کاربر:

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │    1 │       1 |
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

در برخی موارد بعد ما تغییر فعالیت کاربر را ثبت می کنیم و با دو ردیف زیر می نویسیم.

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │   -1 │       1 |
│ 4324182021466249494 │         6 │      185 │    1 │       2 |
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

ردیف اول لغو حالت قبلی از جسم (کاربر). باید تمام زمینه های دولت لغو شده به جز کپی کنید `Sign`.

ردیف دوم شامل وضعیت فعلی.

چرا که ما نیاز به تنها دولت گذشته از فعالیت های کاربر ردیف

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │    1 │       1 |
│ 4324182021466249494 │         5 │      146 │   -1 │       1 |
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

می توان حذف, سقوط نامعتبر (قدیمی) دولت از جسم. `VersionedCollapsingMergeTree` این کار در حالی که ادغام قطعات داده.

برای پیدا کردن که چرا ما نیاز به دو ردیف برای هر تغییر را ببینید [الگوریتم](#table_engines-versionedcollapsingmergetree-algorithm).

**نکاتی در مورد استفاده**

1.  برنامه ای که می نویسد داده ها باید به یاد داشته باشید دولت از یک شی به منظور لغو. این “cancel” رشته باید یک کپی از “state” رشته با مخالف `Sign`. این باعث افزایش اندازه اولیه ذخیره سازی اما اجازه می دهد تا به نوشتن داده ها به سرعت.
2.  در حال رشد طولانی در ستون کاهش بهره وری از موتور با توجه به بار برای نوشتن. ساده تر داده, بهتر بهره وری.
3.  `SELECT` نتایج به شدت بستگی به قوام تاریخ تغییر شی. هنگام تهیه داده ها برای قرار دادن دقیق باشید. شما می توانید نتایج غیر قابل پیش بینی با اطلاعات متناقض از جمله مقادیر منفی برای معیارهای غیر منفی مانند عمق جلسه.

### الگوریتم {#table_engines-versionedcollapsingmergetree-algorithm}

هنگامی که مالکیت خانه ادغام قطعات داده, حذف هر جفت ردیف که کلید اولیه و نسخه های مختلف و همان `Sign`. منظور از ردیف مهم نیست.

هنگامی که داده ها را درج خانه, دستور ردیف توسط کلید اصلی. اگر `Version` ستون در کلید اصلی نیست, خانه عروسکی اضافه می کند به کلید اصلی به طور ضمنی به عنوان زمینه گذشته و برای سفارش استفاده.

## انتخاب داده ها {#selecting-data}

تاتر تضمین نمی کند که همه از ردیف با کلید اصلی همان خواهد شد در همان بخش داده و در نتیجه و یا حتی بر روی سرور فیزیکی است. این درست است هر دو برای نوشتن داده ها و برای ادغام بعدی از قطعات داده است. علاوه بر این فرایندهای کلیک `SELECT` نمایش داده شد با موضوعات متعدد و منظور از ردیف در نتیجه نمی تواند پیش بینی کند. این به این معنی است که تجمع مورد نیاز است اگر نیاز به طور کامل وجود دارد “collapsed” داده ها از یک `VersionedCollapsingMergeTree` جدول

برای نهایی سقوط, ارسال یک پرس و جو با یک `GROUP BY` بند و مجموع توابع است که برای ثبت نام حساب. برای مثال برای محاسبه مقدار استفاده کنید `sum(Sign)` به جای `count()`. برای محاسبه مجموع چیزی استفاده کنید `sum(Sign * x)` به جای `sum(x)` و اضافه کردن `HAVING sum(Sign) > 0`.

مصالح `count`, `sum` و `avg` می توان محاسبه این راه. مجموع `uniq` می توان محاسبه اگر یک شی حداقل یک دولت غیر فروریخته. مصالح `min` و `max` نمی توان محاسبه کرد زیرا `VersionedCollapsingMergeTree` تاریخ ارزش های کشورهای فرو ریخت را نجات دهد.

اگر شما نیاز به استخراج داده ها با “collapsing” اما بدون تجمع (مثلا, برای بررسی اینکه ردیف در حال حاضر که جدیدترین ارزش مطابقت شرایط خاصی هستند), شما می توانید با استفاده از `FINAL` تغییردهنده برای `FROM` بند بند. این روش بی فایده است و باید با جداول بزرگ استفاده نمی شود.

## مثال استفاده {#example-of-use}

اطلاعات نمونه:

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │    1 │       1 |
│ 4324182021466249494 │         5 │      146 │   -1 │       1 |
│ 4324182021466249494 │         6 │      185 │    1 │       2 |
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

ایجاد جدول:

``` sql
CREATE TABLE UAct
(
    UserID UInt64,
    PageViews UInt8,
    Duration UInt8,
    Sign Int8,
    Version UInt8
)
ENGINE = VersionedCollapsingMergeTree(Sign, Version)
ORDER BY UserID
```

درج داده:

``` sql
INSERT INTO UAct VALUES (4324182021466249494, 5, 146, 1, 1)
```

``` sql
INSERT INTO UAct VALUES (4324182021466249494, 5, 146, -1, 1),(4324182021466249494, 6, 185, 1, 2)
```

ما با استفاده از دو `INSERT` نمایش داده شد برای ایجاد دو بخش داده های مختلف. اگر ما داده ها را وارد کنید با یک پرس و جو تنها, تاتر ایجاد یک بخش داده و هرگز هیچ ادغام انجام خواهد داد.

گرفتن داده ها:

``` sql
SELECT * FROM UAct
```

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │    1 │       1 │
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │   -1 │       1 │
│ 4324182021466249494 │         6 │      185 │    1 │       2 │
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

چه ما در اینجا مشاهده کنید و قطعات فروریخته کجا هستند?
ما دو بخش داده با استفاده از دو `INSERT` نمایش داده شد. این `SELECT` پرس و جو در دو موضوع انجام شد, و در نتیجه یک نظم تصادفی از ردیف است.
سقوط رخ نداد زیرا قطعات داده هنوز ادغام نشده اند. تاتر ادغام قطعات داده در یک نقطه ناشناخته در زمان است که ما نمی توانیم پیش بینی.

به همین دلیل است که ما نیاز به تجمع:

``` sql
SELECT
    UserID,
    sum(PageViews * Sign) AS PageViews,
    sum(Duration * Sign) AS Duration,
    Version
FROM UAct
GROUP BY UserID, Version
HAVING sum(Sign) > 0
```

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Version─┐
│ 4324182021466249494 │         6 │      185 │       2 │
└─────────────────────┴───────────┴──────────┴─────────┘
```

اگر ما تجمع نیاز ندارد و می خواهید به زور سقوط, ما می توانیم با استفاده از `FINAL` تغییردهنده برای `FROM` بند بند.

``` sql
SELECT * FROM UAct FINAL
```

``` text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         6 │      185 │    1 │       2 │
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

این یک راه بسیار کارامد برای انتخاب داده ها است. برای جداول بزرگ استفاده نکنید.

[مقاله اصلی](https://clickhouse.tech/docs/en/operations/table_engines/versionedcollapsingmergetree/) <!--hide-->
