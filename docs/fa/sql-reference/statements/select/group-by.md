---
machine_translated: true
machine_translated_rev: 72537a2d527c63c07aa5d2361a8829f3895cf2bd
---

# گروه بر اساس بند {#select-group-by-clause}

`GROUP BY` بند کلید `SELECT` پرس و جو به حالت تجمع, که به شرح زیر کار می کند:

-   `GROUP BY` بند شامل یک لیست از عبارات (و یا یک عبارت واحد, که در نظر گرفته می شود لیستی از طول یک). این لیست به عنوان یک عمل می کند “grouping key”, در حالی که هر بیان فردی خواهد شد به عنوان یک اشاره “key expressions”.
-   تمام عبارات در [SELECT](index.md), [HAVING](having.md) و [ORDER BY](order-by.md) بند **باید** بر اساس عبارات کلیدی محاسبه می شود **یا** روشن [توابع مجموع](../../../sql-reference/aggregate-functions/index.md) بیش از عبارات غیر کلیدی (از جمله ستون ساده). به عبارت دیگر, هر ستون انتخاب شده از جدول باید یا در یک عبارت کلیدی و یا در داخل یک تابع جمع استفاده می شود, اما نه هر دو.
-   نتیجه جمع `SELECT` پرس و جو شامل ردیف به عنوان بسیاری از ارزش های منحصر به فرد وجود دارد “grouping key” در جدول منبع. معمولا این نشانه را کاهش می دهد تعداد ردیف, اغلب توسط سفارشات از قدر, اما نه لزوما: تعداد ردیف همان باقی می ماند اگر همه “grouping key” ارزش متمایز بودند.

!!! note "یادداشت"
    یک راه اضافی برای اجرای تجمع بیش از یک جدول وجود دارد. اگر یک پرس و جو شامل ستون جدول تنها در داخل توابع کل, که `GROUP BY clause` می توان حذف, و تجمع توسط یک مجموعه خالی از کلید فرض بر این است. چنین نمایش داده شد همیشه دقیقا یک ردیف بازگشت.

## پردازش پوچ {#null-processing}

برای گروه بندی, تفسیر کلیک [NULL](../../syntax.md#null-literal) به عنوان یک ارزش, و `NULL==NULL`. این متفاوت است `NULL` پردازش در بسیاری از زمینه های دیگر.

در اینجا یک مثال برای نشان دادن این بدان معنی است.

فرض کنید شما باید این جدول:

``` text
┌─x─┬────y─┐
│ 1 │    2 │
│ 2 │ ᴺᵁᴸᴸ │
│ 3 │    2 │
│ 3 │    3 │
│ 3 │ ᴺᵁᴸᴸ │
└───┴──────┘
```

پرسوجو `SELECT sum(x), y FROM t_null_big GROUP BY y` نتایج در:

``` text
┌─sum(x)─┬────y─┐
│      4 │    2 │
│      3 │    3 │
│      5 │ ᴺᵁᴸᴸ │
└────────┴──────┘
```

شما می توانید ببینید که `GROUP BY` برای `y = NULL` خلاصه تا `x`, به عنوان اگر `NULL` این مقدار است.

اگر شما تصویب چند کلید به `GROUP BY`, نتیجه به شما تمام ترکیبی از انتخاب را, اگر `NULL` یک مقدار خاص بودند.

## با اصلاح کننده بالغ {#with-totals-modifier}

اگر `WITH TOTALS` اصلاح مشخص شده است, ردیف دیگر محاسبه خواهد شد. این ردیف ستون های کلیدی حاوی مقادیر پیش فرض (صفر یا خطوط خالی) و ستون های توابع جمع شده با مقادیر محاسبه شده در تمام ردیف ها ( “total” ارزش ها).

این ردیف اضافی تنها در تولید `JSON*`, `TabSeparated*` و `Pretty*` فرمت ها به طور جداگانه از ردیف های دیگر:

-   داخل `JSON*` فرمت, این ردیف خروجی به عنوان یک جداگانه است ‘totals’ رشته.
-   داخل `TabSeparated*` فرمت, ردیف پس از نتیجه اصلی, قبل از یک ردیف خالی (پس از داده های دیگر).
-   داخل `Pretty*` فرمت, ردیف خروجی به عنوان یک جدول جداگانه پس از نتیجه اصلی است.
-   در فرمت های دیگر در دسترس نیست.

`WITH TOTALS` می توان در راه های مختلف اجرا زمانی که داشتن حاضر است. رفتار بستگی به ‘totals_mode’ تنظیمات.

### پیکربندی پردازش بالغ {#configuring-totals-processing}

به طور پیش فرض, `totals_mode = 'before_having'`. در این مورد, ‘totals’ محاسبه شده است در تمام ردیف از جمله کسانی که عبور نمی کند از طریق داشتن و `max_rows_to_group_by`.

جایگزین های دیگر شامل تنها ردیف است که از طریق داشتن در عبور ‘totals’ و رفتار متفاوت با تنظیم `max_rows_to_group_by` و `group_by_overflow_mode = 'any'`.

`after_having_exclusive` – Don't include rows that didn't pass through `max_rows_to_group_by`. به عبارت دیگر, ‘totals’ کمتر از و یا به همان تعداد از ردیف به عنوان اگر داشته باشد `max_rows_to_group_by` حذف شد.

`after_having_inclusive` – Include all the rows that didn't pass through ‘max_rows_to_group_by’ داخل ‘totals’. به عبارت دیگر, ‘totals’ بیش از و یا به همان تعداد از ردیف به عنوان اگر داشته باشد `max_rows_to_group_by` حذف شد.

`after_having_auto` – Count the number of rows that passed through HAVING. If it is more than a certain amount (by default, 50%), include all the rows that didn't pass through ‘max_rows_to_group_by’ داخل ‘totals’. در غیر این صورت, را شامل نمی شود.

`totals_auto_threshold` – By default, 0.5. The coefficient for `after_having_auto`.

اگر `max_rows_to_group_by` و `group_by_overflow_mode = 'any'` استفاده نمی شود, تمام تغییرات از `after_having` یکسان هستند و شما می توانید از هر یک از این موارد استفاده کنید, `after_having_auto`).

شما می توانید با استفاده از مجموع در subqueries از جمله subqueries در پیوستن به بند (در این مورد مربوطه مجموع ارزش ترکیب می شوند).

## مثالها {#examples}

مثال:

``` sql
SELECT
    count(),
    median(FetchTiming > 60 ? 60 : FetchTiming),
    count() - sum(Refresh)
FROM hits
```

با این حال, در مقابل به استاندارد گذاشتن, اگر جدول هیچ ردیف ندارد (یا هیچ در همه وجود ندارد, و یا هر پس از استفاده از جایی که برای فیلتر کردن وجود ندارد), یک نتیجه خالی بازگشته است, و نه در نتیجه از یکی از ردیف های حاوی مقادیر اولیه از توابع کل.

همانطور که به خروجی زیر مخالف (و منطبق با استاندارد گذاشتن), شما می توانید برخی از ارزش برخی از ستون است که در یک کلید و یا کل تابع نیست (به جز عبارات ثابت). برای کار در اطراف این, شما می توانید با استفاده از ‘any’ تابع جمع (اولین مقدار مواجه می شوند) یا ‘min/max’.

مثال:

``` sql
SELECT
    domainWithoutWWW(URL) AS domain,
    count(),
    any(Title) AS title -- getting the first occurred page header for each domain.
FROM hits
GROUP BY domain
```

برای هر مقدار کلیدی مختلف مواجه می شوند, گروه با محاسبه مجموعه ای از مقادیر تابع کل.

گروه توسط ستون های مجموعه پشتیبانی نمی شود.

ثابت را نمی توان به عنوان استدلال برای توابع کل مشخص شده است. مثال: مجموع(1). به جای این, شما می توانید از ثابت خلاص. مثال: `count()`.

## پیاده سازی اطلاعات {#implementation-details}

تجمع یکی از مهم ترین ویژگی های یک سندرم تونل کارپ ستون گرا است, و به این ترتیب اجرای یکی از قطعات به شدت بهینه سازی شده از خانه رعیتی است. به طور پیش فرض, تجمع در حافظه با استفاده از یک هش جدول انجام. این 40 + تخصص است که به طور خودکار بسته به انتخاب “grouping key” انواع داده ها.

### گروه در حافظه خارجی {#select-group-by-in-external-memory}

شما می توانید اطلاعات موقت تخلیه به دیسک را قادر به محدود کردن استفاده از حافظه در طول `GROUP BY`.
این [ا_فزون_بر_گونهی_گونهی زیر_گروهها](../../../operations/settings/settings.md#settings-max_bytes_before_external_group_by) تنظیم تعیین کننده مصرف رم را برای تخلیه می کند `GROUP BY` اطلاعات موقت به سیستم فایل. اگر به 0 (به طور پیش فرض), غیر فعال است.

هنگام استفاده از `max_bytes_before_external_group_by`, توصیه می کنیم که به شما در تنظیم `max_memory_usage` در مورد دو برابر بالا. این لازم است زیرا دو مرحله برای تجمع وجود دارد: خواندن داده ها و تشکیل داده های متوسط (1) و ادغام داده های متوسط (2). واژگون اطلاعات به سیستم فایل تنها می تواند در طول مرحله رخ می دهد 1. اگر داده های موقت ریخته نمی شد, سپس مرحله 2 ممکن است نیاز به همان مقدار از حافظه در مرحله 1.

برای مثال اگر [_کاساژ بیشینه](../../../operations/settings/settings.md#settings_max_memory_usage) به 1000000000 تنظیم شد و شما می خواهید به استفاده از تجمع خارجی, این را حس می کند به مجموعه `max_bytes_before_external_group_by` به 10000000000 و `max_memory_usage` به 20000000000. هنگامی که تجمع خارجی باعث شده است (اگر حداقل یک روگرفت از داده های موقت وجود دارد), حداکثر مصرف رم تنها کمی بیشتر از `max_bytes_before_external_group_by`.

با پردازش پرس و جو توزیع, تجمع خارجی بر روی سرور از راه دور انجام. به منظور سرور درخواست به استفاده از تنها مقدار کمی از رم, تنظیم `distributed_aggregation_memory_efficient` به 1.

هنگامی که ادغام داده ها به دیسک سرخ, و همچنین زمانی که ادغام نتایج حاصل از سرور از راه دور زمانی که `distributed_aggregation_memory_efficient` تنظیم فعال است, مصرف تا `1/256 * the_number_of_threads` از مقدار کل رم.

هنگامی که تجمع خارجی فعال است, اگر کمتر از وجود دارد `max_bytes_before_external_group_by` of data (i.e. data was not flushed), the query runs just as fast as without external aggregation. If any temporary data was flushed, the run time will be several times longer (approximately three times).

اگر شما یک [ORDER BY](order-by.md) با یک [LIMIT](limit.md) پس از `GROUP BY`, سپس مقدار رم استفاده می شود بستگی به مقدار داده ها در `LIMIT` نه تو کل میز اما اگر `ORDER BY` ندارد `LIMIT` فراموش نکنید که مرتب سازی خارجی را فعال کنید (`max_bytes_before_external_sort`).
