---
machine_translated: true
machine_translated_rev: 72537a2d527c63c07aa5d2361a8829f3895cf2bd
toc_priority: 41
toc_title: "\u0630\u062E\u06CC\u0631\u0647 \u0648\u0627\u0698\u0647\u0646\u0627\u0645\
  \u0647\u0647\u0627 \u062F\u0631 \u062D\u0627\u0641\u0638\u0647"
---

# ذخیره واژهنامهها در حافظه {#dicts-external-dicts-dict-layout}

راه های مختلفی برای ذخیره لغت نامه ها در حافظه وجود دارد.

ما توصیه می کنیم [تخت](#flat), [درهم](#dicts-external_dicts_dict_layout-hashed) و [\_ساخت مجتمع](#complex-key-hashed). که سرعت پردازش بهینه را فراهم می کند.

ذخیره سازی به دلیل عملکرد بالقوه ضعیف و مشکلات در انتخاب پارامترهای مطلوب توصیه نمی شود. ادامه مطلب در بخش “[نهانگاه](#cache)”.

راه های مختلفی برای بهبود عملکرد فرهنگ لغت وجود دارد:

-   پاسخ تابع برای کار با فرهنگ لغت پس از `GROUP BY`.
-   علامت گذاری به عنوان ویژگی برای استخراج به عنوان تزریقی. یک ویژگی است که به نام عاطفی اگر مقادیر ویژگی های مختلف به کلید های مختلف مطابقت دارد. بنابراین زمانی که `GROUP BY` با استفاده از یک تابع است که بازخوانی ارزش ویژگی های کلیدی, این تابع به طور خودکار از گرفته `GROUP BY`.

تاتر تولید یک استثنا برای خطا با لغت نامه. نمونه هایی از اشتباهات:

-   فرهنگ لغت در حال دسترسی نمی تواند لود شود.
-   خطای پرسوجو یک `cached` فرهنگ لغت.

شما می توانید لیستی از لغت نامه های خارجی و وضعیت خود را در `system.dictionaries` جدول

پیکربندی به نظر می رسد مثل این:

``` xml
<yandex>
    <dictionary>
        ...
        <layout>
            <layout_type>
                <!-- layout settings -->
            </layout_type>
        </layout>
        ...
    </dictionary>
</yandex>
```

متناظر [توصیف](../../statements/create.md#create-dictionary-query):

``` sql
CREATE DICTIONARY (...)
...
LAYOUT(LAYOUT_TYPE(param value)) -- layout settings
...
```

## راه هایی برای ذخیره لغت نامه ها در حافظه {#ways-to-store-dictionaries-in-memory}

-   [تخت](#flat)
-   [درهم](#dicts-external_dicts_dict_layout-hashed)
-   [فشردهسازی](#dicts-external_dicts_dict_layout-sparse_hashed)
-   [نهانگاه](#cache)
-   [مستقیم](#direct)
-   [رنگها](#range-hashed)
-   [\_ساخت مجتمع](#complex-key-hashed)
-   [\_پیچید\_چهای پیچیده](#complex-key-cache)
-   [شمال اروپا](#ip-trie)

### تخت {#flat}

فرهنگ لغت به طور کامل در حافظه در قالب مجموعه تخت ذخیره می شود. چقدر حافظه استفاده از فرهنگ لغت? مقدار متناسب با اندازه بزرگترین کلید است (در فضا استفاده می شود).

کلید فرهنگ لغت است `UInt64` نوع و ارزش محدود به 500,000 است. اگر یک کلید بزرگتر کشف شده است در هنگام ایجاد فرهنگ لغت, تاتر می اندازد یک استثنا و فرهنگ لغت ایجاد کنید.

تمام انواع منابع پشتیبانی می شوند. هنگام به روز رسانی, داده ها (از یک فایل و یا از یک جدول) در تمامیت خود را به عنوان خوانده شده.

این روش بهترین عملکرد را در میان تمام روش های موجود ذخیره سازی فرهنگ لغت فراهم می کند.

مثال پیکربندی:

``` xml
<layout>
  <flat />
</layout>
```

یا

``` sql
LAYOUT(FLAT())
```

### درهم {#dicts-external_dicts_dict_layout-hashed}

فرهنگ لغت به طور کامل در حافظه در قالب یک جدول هش ذخیره می شود. فرهنگ لغت می تواند شامل هر تعداد از عناصر با هر شناسه در عمل تعداد کلید ده ها میلیون نفر از اقلام برسد.

تمام انواع منابع پشتیبانی می شوند. هنگام به روز رسانی, داده ها (از یک فایل و یا از یک جدول) در تمامیت خود را به عنوان خوانده شده.

مثال پیکربندی:

``` xml
<layout>
  <hashed />
</layout>
```

یا

``` sql
LAYOUT(HASHED())
```

### فشردهسازی {#dicts-external_dicts_dict_layout-sparse_hashed}

مشابه به `hashed`, اما با استفاده از حافظه کمتر به نفع استفاده از پردازنده بیشتر.

مثال پیکربندی:

``` xml
<layout>
  <sparse_hashed />
</layout>
```

``` sql
LAYOUT(SPARSE_HASHED())
```

### \_ساخت مجتمع {#complex-key-hashed}

این نوع ذخیره سازی برای استفاده با کامپوزیت است [کلید](external-dicts-dict-structure.md). مشابه به `hashed`.

مثال پیکربندی:

``` xml
<layout>
  <complex_key_hashed />
</layout>
```

``` sql
LAYOUT(COMPLEX_KEY_HASHED())
```

### رنگها {#range-hashed}

فرهنگ لغت در حافظه به شکل یک جدول هش با مجموعه ای مرتب از محدوده ها و مقادیر مربوطه ذخیره می شود.

این روش ذخیره سازی کار می کند به همان شیوه به عنوان درهم و اجازه می دهد تا با استفاده از تاریخ/زمان (نوع عددی دلخواه) محدوده علاوه بر کلید.

مثال: جدول شامل تخفیف برای هر تبلیغ در قالب:

``` text
+---------|-------------|-------------|------+
| advertiser id | discount start date | discount end date | amount |
+===============+=====================+===================+========+
| 123           | 2015-01-01          | 2015-01-15        | 0.15   |
+---------|-------------|-------------|------+
| 123           | 2015-01-16          | 2015-01-31        | 0.25   |
+---------|-------------|-------------|------+
| 456           | 2015-01-01          | 2015-01-15        | 0.05   |
+---------|-------------|-------------|------+
```

برای استفاده از یک نمونه برای محدوده تاریخ, تعریف `range_min` و `range_max` عناصر در [ساختار](external-dicts-dict-structure.md). این عناصر باید حاوی عناصر `name` و`type` (اگر `type` مشخص نشده است, نوع پیش فرض استفاده خواهد شد - تاریخ). `type` می تواند هر نوع عددی (تاریخ / DateTime / UInt64 / Int32 / دیگران).

مثال:

``` xml
<structure>
    <id>
        <name>Id</name>
    </id>
    <range_min>
        <name>first</name>
        <type>Date</type>
    </range_min>
    <range_max>
        <name>last</name>
        <type>Date</type>
    </range_max>
    ...
```

یا

``` sql
CREATE DICTIONARY somedict (
    id UInt64,
    first Date,
    last Date
)
PRIMARY KEY id
LAYOUT(RANGE_HASHED())
RANGE(MIN first MAX last)
```

برای کار با این لغت نامه, شما نیاز به تصویب یک استدلال اضافی به `dictGetT` تابع, که یک محدوده انتخاب شده است:

``` sql
dictGetT('dict_name', 'attr_name', id, date)
```

این تابع ارزش برای مشخص گرداند `id`بازدید کنندگان و محدوده تاریخ که شامل تاریخ گذشت.

اطلاعات از الگوریتم:

-   اگر `id` یافت نشد و یا یک محدوده برای یافت نشد `id` مقدار پیش فرض فرهنگ لغت را برمی گرداند.
-   اگر با هم تداخل دارند محدوده وجود دارد, شما می توانید هر استفاده.
-   اگر جداساز محدوده باشد `NULL` یا نامعتبر تاریخ (مانند 1900-01-01 یا 2039-01-01) طیف وسیعی است که در سمت چپ باز است. محدوده را می توان در هر دو طرف باز کرد.

مثال پیکربندی:

``` xml
<yandex>
        <dictionary>

                ...

                <layout>
                        <range_hashed />
                </layout>

                <structure>
                        <id>
                                <name>Abcdef</name>
                        </id>
                        <range_min>
                                <name>StartTimeStamp</name>
                                <type>UInt64</type>
                        </range_min>
                        <range_max>
                                <name>EndTimeStamp</name>
                                <type>UInt64</type>
                        </range_max>
                        <attribute>
                                <name>XXXType</name>
                                <type>String</type>
                                <null_value />
                        </attribute>
                </structure>

        </dictionary>
</yandex>
```

یا

``` sql
CREATE DICTIONARY somedict(
    Abcdef UInt64,
    StartTimeStamp UInt64,
    EndTimeStamp UInt64,
    XXXType String DEFAULT ''
)
PRIMARY KEY Abcdef
RANGE(MIN StartTimeStamp MAX EndTimeStamp)
```

### نهانگاه {#cache}

فرهنگ لغت در کش است که تعداد ثابتی از سلول های ذخیره می شود. این سلول ها حاوی عناصر اغلب استفاده می شود.

هنگام جستجو برای یک فرهنگ لغت کش اول جستجو می شود. برای هر بلوک از داده ها, تمام کلید هایی که در کش یافت نشد و یا منسوخ شده از منبع با استفاده از درخواست `SELECT attrs... FROM db.table WHERE id IN (k1, k2, ...)`. داده های دریافت شده است و سپس به کش نوشته شده است.

برای لغت نامه کش, انقضا [طول عمر](external-dicts-dict-lifetime.md) از داده ها در کش را می توان تنظیم کرد. اگر زمان بیشتری از `lifetime` از زمان بارگذاری داده ها در یک سلول گذشت, ارزش سلول استفاده نمی شود, و دوباره درخواست دفعه بعد که نیاز به استفاده می شود.
این حداقل موثر از تمام راه هایی برای ذخیره لغت نامه است. سرعت کش به شدت در تنظیمات صحیح و سناریوی استفاده بستگی دارد. فرهنگ لغت نوع کش به خوبی انجام تنها زمانی که نرخ ضربه به اندازه کافی بالا هستند (توصیه می شود 99% و بالاتر). شما می توانید میزان ضربه به طور متوسط در مشاهده `system.dictionaries` جدول

برای بهبود عملکرد کش, استفاده از یک خرده فروشی با `LIMIT`, و پاسخ تابع با فرهنگ لغت خارجی.

پشتیبانی [منابع](external-dicts-dict-sources.md) پردازشگر پشتیبانی شده:

مثال تنظیمات:

``` xml
<layout>
    <cache>
        <!-- The size of the cache, in number of cells. Rounded up to a power of two. -->
        <size_in_cells>1000000000</size_in_cells>
    </cache>
</layout>
```

یا

``` sql
LAYOUT(CACHE(SIZE_IN_CELLS 1000000000))
```

تنظیم اندازه کش به اندازه کافی بزرگ است. شما نیاز به تجربه برای انتخاب تعدادی از سلول های:

1.  تنظیم برخی از ارزش.
2.  نمایش داده شد اجرا تا کش کاملا کامل است.
3.  ارزیابی مصرف حافظه با استفاده از `system.dictionaries` جدول
4.  افزایش یا کاهش تعداد سلول ها تا زمانی که مصرف حافظه مورد نیاز رسیده است.

!!! warning "اخطار"
    هنوز تاتر به عنوان یک منبع استفاده نمی, چرا که کند است برای پردازش نمایش داده شد با تصادفی می خواند.

### \_پیچید\_چهای پیچیده {#complex-key-cache}

این نوع ذخیره سازی برای استفاده با کامپوزیت است [کلید](external-dicts-dict-structure.md). مشابه به `cache`.

### مستقیم {#direct}

فرهنگ لغت در حافظه ذخیره نمی شود و به طور مستقیم به منبع می رود در طول پردازش یک درخواست.

کلید فرهنگ لغت است `UInt64` نوع.

همه انواع [منابع](external-dicts-dict-sources.md), به جز فایل های محلی, پشتیبانی می شوند.

مثال پیکربندی:

``` xml
<layout>
  <direct />
</layout>
```

یا

``` sql
LAYOUT(DIRECT())
```

### شمال اروپا {#ip-trie}

این نوع ذخیره سازی برای پیشوندهای نقشه برداری شبکه (نشانی های اینترنتی) به فراداده مانند ان است.

مثال: جدول شامل پیشوندهای شبکه و مربوط به خود را به عنوان شماره و کد کشور:

``` text
  +-----------|-----|------+
  | prefix          | asn   | cca2   |
  +=================+=======+========+
  | 202.79.32.0/20  | 17501 | NP     |
  +-----------|-----|------+
  | 2620:0:870::/48 | 3856  | US     |
  +-----------|-----|------+
  | 2a02:6b8:1::/48 | 13238 | RU     |
  +-----------|-----|------+
  | 2001:db8::/32   | 65536 | ZZ     |
  +-----------|-----|------+
```

هنگام استفاده از این نوع طرح, ساختار باید یک کلید کامپوزیت دارند.

مثال:

``` xml
<structure>
    <key>
        <attribute>
            <name>prefix</name>
            <type>String</type>
        </attribute>
    </key>
    <attribute>
            <name>asn</name>
            <type>UInt32</type>
            <null_value />
    </attribute>
    <attribute>
            <name>cca2</name>
            <type>String</type>
            <null_value>??</null_value>
    </attribute>
    ...
```

یا

``` sql
CREATE DICTIONARY somedict (
    prefix String,
    asn UInt32,
    cca2 String DEFAULT '??'
)
PRIMARY KEY prefix
```

کلید باید تنها یک ویژگی نوع رشته ای داشته باشد که شامل یک پیشوند مجاز است. انواع دیگر هنوز پشتیبانی نمی شوند.

برای نمایش داده شد, شما باید توابع مشابه استفاده کنید (`dictGetT` با یک تاپل) به عنوان لغت نامه با کلید های کامپوزیت:

``` sql
dictGetT('dict_name', 'attr_name', tuple(ip))
```

تابع طول می کشد یا `UInt32` برای ایپو4 یا `FixedString(16)` برای IPv6:

``` sql
dictGetString('prefix', 'asn', tuple(IPv6StringToNum('2001:db8::1')))
```

انواع دیگر هنوز پشتیبانی نمی شوند. تابع ویژگی برای پیشوند که مربوط به این نشانی اینترنتی را برمی گرداند. اگر پیشوند با هم تداخل دارند وجود دارد, یکی از خاص ترین بازگشته است.

داده ها در یک ذخیره می شود `trie`. این به طور کامل باید به رم مناسب.

[مقاله اصلی](https://clickhouse.tech/docs/en/query_language/dicts/external_dicts_dict_layout/) <!--hide-->
