# Функции для работы со строками

## empty {#string_functions-empty}
Возвращает 1 для пустой строки, и 0 для непустой строки.
Тип результата - UInt8.
Строка считается непустой, если содержит хотя бы один байт, пусть даже это пробел или нулевой байт.
Функция также работает для массивов.

## notEmpty
Возвращает 0 для пустой строки, и 1 для непустой строки.
Тип результата - UInt8.
Функция также работает для массивов.

## length
Возвращает длину строки в байтах (не символах, не кодовых точках).
Тип результата - UInt64.
Функция также работает для массивов.

## lengthUTF8
Возвращает длину строки в кодовых точках Unicode (не символах), при допущении, что строка содержит набор байт, являющийся текстом в кодировке UTF-8. Если допущение не выполнено - то возвращает какой-нибудь результат (не кидает исключение).
Тип результата - UInt64.

## lower
Переводит ASCII-символы латиницы в строке в нижний регистр.

## upper
Переводит ASCII-символы латиницы в строке в верхний регистр.

## lowerUTF8
Переводит строку в нижний регистр, при допущении, что строка содержит набор байт, представляющий текст в кодировке UTF-8.
Не учитывает язык. То есть, для турецкого языка, результат может быть не совсем верным.
Если длина UTF-8 последовательности байт различна для верхнего и нижнего регистра кодовой точки, то для этой кодовой точки, результат работы может быть некорректным.
Если строка содержит набор байт, не являющийся UTF-8, то поведение не определено.

## upperUTF8
Переводит строку в верхний регистр, при допущении, что строка содержит набор байт, представляющий текст в кодировке UTF-8.
Не учитывает язык. То есть, для турецкого языка, результат может быть не совсем верным.
Если длина UTF-8 последовательности байт различна для верхнего и нижнего регистра кодовой точки, то для этой кодовой точки, результат работы может быть некорректным.
Если строка содержит набор байт, не являющийся UTF-8, то поведение не определено.

## isValidUTF8
Возвращает 1, если набор байт является корректным в кодировке UTF-8, 0 иначе.

## toValidUTF8

Заменяет некорректные символы UTF-8 на символ `�` (U+FFFD). Все идущие подряд некорректные символы схлопываются в один заменяющий символ.

```
toValidUTF8( input_string )
```

Параметры:

- input_string — произвольный набор байтов, представленный как объект типа [String](../../data_types/string.md).

Возвращаемое значение: Корректная строка UTF-8.

### Пример

```sql
SELECT toValidUTF8('\x61\xF0\x80\x80\x80b')
```
```text
┌─toValidUTF8('a����b')─┐
│ a�b                   │
└───────────────────────┘
```


## reverse
Разворачивает строку (как последовательность байт).

## reverseUTF8
Разворачивает последовательность кодовых точек Unicode, при допущении, что строка содержит набор байт, представляющий текст в кодировке UTF-8. Иначе - что-то делает (не кидает исключение).


## format(pattern, s0, s1, ...)

Форматирует константный шаблон со строками, перечисленными в аргументах. `pattern` -- упрощенная версия шаблона в языке Python. Шаблон содержит "заменяющие поля", которые окружены фигурными скобками `{}`. Всё, что не содержится в скобках, интерпретируется как обычный текст и просто копируется. Если нужно использовать символ фигурной скобки, можно экранивать двойной скобкой `{{` или `}}`. Имя полей могут быть числами (нумерация с нуля) или пустыми (тогда они интерпретируются как последовательные числа).

```sql
SELECT format('{1} {0} {1}', 'World', 'Hello')

┌─format('{1} {0} {1}', 'World', 'Hello')─┐
│ Hello World Hello                       │
└─────────────────────────────────────────┘

SELECT format('{} {}', 'Hello', 'World')

┌─format('{} {}', 'Hello', 'World')─┐
│ Hello World                       │
└───────────────────────────────────┘
```


## concat(s1, s2, ...)
Склеивает строки, перечисленные в аргументах, без разделителей.

## substring(s, offset, length)
Возвращает подстроку, начиная с байта по индексу offset, длины length байт. Индексация символов - начиная с единицы (как в стандартном SQL). Аргументы offset и length должны быть константами.

## substringUTF8(s, offset, length)
Так же, как substring, но для кодовых точек Unicode. Работает при допущении, что строка содержит набор байт, представляющий текст в кодировке UTF-8. Если допущение не выполнено - то возвращает какой-нибудь результат (не кидает исключение).

## appendTrailingCharIfAbsent(s, c)
Если строка s непустая и не содержит символ c на конце, то добавляет символ c в конец.

## convertCharset(s, from, to)
Возвращает сконвертированную из кодировки from в кодировку to строку s.

## base64Encode(s)
Производит кодирование строки s в base64-представление.

## base64Decode(s)
Декодирует base64-представление s в исходную строку. При невозможности декодирования выбрасывает исключение

## tryBase64Decode(s)
Функционал аналогичен base64Decode, но при невозможности декодирования возвращает пустую строку.

## endsWith(s, suffix) {#function-endswith}

Возвращает 1, если строка завершается указанным суффиксом, и 0 в противном случае.

## startsWith(s, prefix) {#function-startswith}

Возвращает 1, если строка начинается указанным префиксом, и 0 в противном случае.

## CRC32(s)
Возвращает чексумму CRC32 данной строки.
Тип результата - UInt32.

[Оригинальная статья](https://clickhouse.yandex/docs/ru/query_language/functions/string_functions/) <!--hide-->
