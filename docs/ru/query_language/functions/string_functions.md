# Функции для работы со строками

## empty {#string_functions-empty}
Возвращает 1 для пустой строки, и 0 для непустой строки.
Тип результата - UInt8.
Строка считается непустой, если содержит хотя бы один байт, пусть даже это пробел или нулевой байт.
Функция также работает для массивов.

## notEmpty
Возвращает 0 для пустой строки, и 1 для непустой строки.
Тип результата - UInt8.
Функция также работает для массивов.

## length
Возвращает длину строки в байтах (не символах, не кодовых точках).
Тип результата - UInt64.
Функция также работает для массивов.

## lengthUTF8
Возвращает длину строки в кодовых точках Unicode (не символах), при допущении, что строка содержит набор байт, являющийся текстом в кодировке UTF-8. Если допущение не выполнено - то возвращает какой-нибудь результат (не кидает исключение).
Тип результата - UInt64.

## lower
Переводит ASCII-символы латиницы в строке в нижний регистр.

## upper
Переводит ASCII-символы латиницы в строке в верхний регистр.

## lowerUTF8
Переводит строку в нижний регистр, при допущении, что строка содержит набор байт, представляющий текст в кодировке UTF-8.
Не учитывает язык. То есть, для турецкого языка, результат может быть не совсем верным.
Если длина UTF-8 последовательности байт различна для верхнего и нижнего регистра кодовой точки, то для этой кодовой точки, результат работы может быть некорректным.
Если строка содержит набор байт, не являющийся UTF-8, то поведение не определено.

## upperUTF8
Переводит строку в верхний регистр, при допущении, что строка содержит набор байт, представляющий текст в кодировке UTF-8.
Не учитывает язык. То есть, для турецкого языка, результат может быть не совсем верным.
Если длина UTF-8 последовательности байт различна для верхнего и нижнего регистра кодовой точки, то для этой кодовой точки, результат работы может быть некорректным.
Если строка содержит набор байт, не являющийся UTF-8, то поведение не определено.

## isValidUTF8
Возвращает 1, если набор байт является корректным в кодировке UTF-8, 0 иначе.

## toValidUTF8

Заменяет некорректные символы UTF-8 на символ `�` (U+FFFD). Все идущие подряд некорректные символы схлопываются в один заменяющий символ.

```sql
toValidUTF8( input_string )
```

Параметры:

- input_string — произвольный набор байтов, представленный как объект типа [String](../../data_types/string.md).

Возвращаемое значение: Корректная строка UTF-8.

### Пример

```sql
SELECT toValidUTF8('\x61\xF0\x80\x80\x80b')
```
```text
┌─toValidUTF8('a����b')─┐
│ a�b                   │
└───────────────────────┘
```

## repeat {#repeat}

Повторяет строку определенное количество раз и объединяет повторяемые значения в одну строку.

**Синтаксис**

```sql
repeat(s, n)
```

**Параметры**

- `s` — Строка для повторения. [String](../../data_types/string.md).
- `n` — Количество повторов. [UInt](../../data_types/int_uint.md).

**Возвращаемое значение**

Строка, состоящая из повторений `n` раз исходной строки `s`. Если `n` < 1, то функция вернет пустую строку.

Тип: `String`.

**Пример**

Запрос:

```sql
SELECT repeat('abc', 10)
```

Ответ:

```text
┌─repeat('abc', 10)──────────────┐
│ abcabcabcabcabcabcabcabcabcabc │
└────────────────────────────────┘
```

## reverse
Разворачивает строку (как последовательность байт).

## reverseUTF8
Разворачивает последовательность кодовых точек Unicode, при допущении, что строка содержит набор байт, представляющий текст в кодировке UTF-8. Иначе - что-то делает (не кидает исключение).


## format(pattern, s0, s1, ...)

Форматирует константный шаблон со строками, перечисленными в аргументах. `pattern` -- упрощенная версия шаблона в языке Python. Шаблон содержит "заменяющие поля", которые окружены фигурными скобками `{}`. Всё, что не содержится в скобках, интерпретируется как обычный текст и просто копируется. Если нужно использовать символ фигурной скобки, можно экранировать двойной скобкой `{{` или `}}`. Имя полей могут быть числами (нумерация с нуля) или пустыми (тогда они интерпретируются как последовательные числа).

```sql
SELECT format('{1} {0} {1}', 'World', 'Hello')
```
```text
┌─format('{1} {0} {1}', 'World', 'Hello')─┐
│ Hello World Hello                       │
└─────────────────────────────────────────┘
```
```sql
SELECT format('{} {}', 'Hello', 'World')
```
```text
┌─format('{} {}', 'Hello', 'World')─┐
│ Hello World                       │
└───────────────────────────────────┘
```


## concat(s1, s2, ...)
Склеивает строки, перечисленные в аргументах, без разделителей.

## substring(s, offset, length)
Возвращает подстроку, начиная с байта по индексу offset, длины length байт. Индексация символов - начиная с единицы (как в стандартном SQL). Аргументы offset и length должны быть константами.

## substringUTF8(s, offset, length)
Так же, как substring, но для кодовых точек Unicode. Работает при допущении, что строка содержит набор байт, представляющий текст в кодировке UTF-8. Если допущение не выполнено - то возвращает какой-нибудь результат (не кидает исключение).

## appendTrailingCharIfAbsent(s, c)
Если строка s непустая и не содержит символ c на конце, то добавляет символ c в конец.

## convertCharset(s, from, to)
Возвращает сконвертированную из кодировки from в кодировку to строку s.

## base64Encode(s)
Производит кодирование строки s в base64-представление.

## base64Decode(s)
Декодирует base64-представление s в исходную строку. При невозможности декодирования выбрасывает исключение

## tryBase64Decode(s)
Функционал аналогичен base64Decode, но при невозможности декодирования возвращает пустую строку.

## endsWith(s, suffix) {#function-endswith}

Возвращает 1, если строка завершается указанным суффиксом, и 0 в противном случае.

## startsWith(str, prefix) {#function-startswith}

Возвращает 1, если строка начинается указанным префиксом, в противном случае 0.

```sql
SELECT startsWith('Spider-Man', 'Spi');
```

**Возвращаемые значения**

- 1, если строка начинается указанным префиксом.
- 0, если строка не начинается указанным префиксом.

**Пример**

Запрос:

```sql
SELECT startsWith('Hello, world!', 'He');
```

Ответ:

```text
┌─startsWith('Hello, world!', 'He')─┐
│                                 1 │
└───────────────────────────────────┘
```

## trim {#trim}

Удаляет все указанные символы с начала или окончания строки.
По умолчанию удаляет все последовательные вхождения обычных пробелов (32 символ ASCII) с обоих концов строки.

**Синтаксис**

```sql
trim([[LEADING|TRAILING|BOTH] trim_character FROM] input_string)
```

**Параметры**

- `trim_character` — один или несколько символов, подлежащие удалению. [String](../../data_types/string.md).
- `input_string` — строка для обрезки. [String](../../data_types/string.md).

**Возвращаемое значение**

Исходную строку без общих пробельных символов слева.

Тип: `String`.

**Пример**

Запрос:

```sql
SELECT trim(BOTH ' ()' FROM '(   Hello, world!   )')
```

Ответ:

```text
┌─trim(BOTH ' ()' FROM '(   Hello, world!   )')─┐
│ Hello, world!                                 │
└───────────────────────────────────────────────┘
```

## trimLeft {#trimleft}

Удаляет все последовательные вхождения обычных пробелов (32 символ ASCII) с левого конца строки. Не удаляет другие виды пробелов (табуляция, пробел без разрыва и т. д.).

**Синтаксис** 

```sql
trimLeft(input_string)
```

Алиас: `ltrim(input_string)`.

**Параметры**

- `input_string` — строка для обрезки. [String](../../data_types/string.md).

**Возвращаемое значение**

Исходную строку без общих пробельных символов слева.

Тип: `String`.

**Пример**

Запрос:

```sql
SELECT trimLeft('     Hello, world!     ')
```

Ответ:

```text
┌─trimLeft('     Hello, world!     ')─┐
│ Hello, world!                       │
└─────────────────────────────────────┘
```

## trimRight  {#trimright}

Удаляет все последовательные вхождения обычных пробелов (32 символ ASCII) с правого конца строки. Не удаляет другие виды пробелов (табуляция, пробел без разрыва и т. д.).

**Синтаксис** 

```sql
trimRight(input_string)
```

Алиас: `rtrim(input_string)`.

**Параметры**

- `input_string` — строка для обрезки. [String](../../data_types/string.md).

**Возвращаемое значение**

Исходную строку без общих пробельных символов справа.

Тип: `String`.

**Пример**

Запрос:

```sql
SELECT trimRight('     Hello, world!     ')
```

Ответ:

```text
┌─trimRight('     Hello, world!     ')─┐
│      Hello, world!                   │
└──────────────────────────────────────┘
```

## trimBoth {#trimboth}

Удаляет все последовательные вхождения обычных пробелов (32 символ ASCII) с обоих концов строки. Не удаляет другие виды пробелов (табуляция, пробел без разрыва и т. д.).

**Синтаксис** 

```sql
trimBoth(input_string)
```

Алиас: `trim(input_string)`.

**Параметры**

- `input_string` — строка для обрезки. [String](../../data_types/string.md).

**Возвращаемое значение**

Исходную строку без общих пробельных символов с обоих концов строки.

Тип: `String`.

**Пример**

Запрос:

```sql
SELECT trimBoth('     Hello, world!     ')
```

Ответ:

```text
┌─trimBoth('     Hello, world!     ')─┐
│ Hello, world!                       │
└─────────────────────────────────────┘
```

## CRC32(s)

Возвращает чексумму CRC32 данной строки, используется CRC-32-IEEE 802.3 многочлен и начальным значением `0xffffffff` (т.к. используется реализация из zlib).

Тип результата - UInt32.

## CRC32IEEE(s)

Возвращает чексумму CRC32 данной строки, используется CRC-32-IEEE 802.3 многочлен.

Тип результата - UInt32.

## CRC64(s)

Возвращает чексумму CRC64 данной строки, используется CRC-64-ECMA многочлен.

Тип результата - UInt64.

[Оригинальная статья](https://clickhouse.yandex/docs/ru/query_language/functions/string_functions/) <!--hide-->
