# Справочник функций {#aggregate-functions-reference}

## count {#agg_function-count}

Вычисляет количество строк или не NULL значений .

ClickHouse поддерживает следующие виды синтаксиса для `count`:

-   `count(expr)` или `COUNT(DISTINCT expr)`.
-   `count()` или `COUNT(*)`. Синтаксис `count()` специфичен для ClickHouse.

**Параметры**

Функция может принимать:

-   Ноль параметров.
-   Одно [выражение](../syntax.md#syntax-expressions).

**Возвращаемое значение**

-   Если функция вызывается без параметров, она вычисляет количество строк.
-   Если передаётся [выражение](../syntax.md#syntax-expressions) , то функция вычисляет количество раз, когда выражение возвращает не NULL. Если выражение возвращает значение типа [Nullable](../../sql-reference/data-types/nullable.md), то результат `count` не становится `Nullable`. Функция возвращает 0, если выражение возвращает `NULL` для всех строк.

В обоих случаях тип возвращаемого значения [UInt64](../../sql-reference/data-types/int-uint.md).

**Подробности**

ClickHouse поддерживает синтаксис `COUNT(DISTINCT ...)`. Поведение этой конструкции зависит от настройки [count\_distinct\_implementation](../../operations/settings/settings.md#settings-count_distinct_implementation). Она определяет, какая из функций [uniq\*](#agg_function-uniq) используется для выполнения операции. По умолчанию — функция [uniqExact](#agg_function-uniqexact).

Запрос `SELECT count() FROM table` не оптимизирован, поскольку количество записей в таблице не хранится отдельно. Он выбирает небольшой столбец из таблицы и подсчитывает количество значений в нём.

**Примеры**

Пример 1:

``` sql
SELECT count() FROM t
```

``` text
┌─count()─┐
│       5 │
└─────────┘
```

Пример 2:

``` sql
SELECT name, value FROM system.settings WHERE name = 'count_distinct_implementation'
```

``` text
┌─name──────────────────────────┬─value─────┐
│ count_distinct_implementation │ uniqExact │
└───────────────────────────────┴───────────┘
```

``` sql
SELECT count(DISTINCT num) FROM t
```

``` text
┌─uniqExact(num)─┐
│              3 │
└────────────────┘
```

Этот пример показывает, что `count(DISTINCT num)` выполняется с помощью функции `uniqExact` в соответствии со значением настройки `count_distinct_implementation`.

## any(x) {#agg_function-any}

Выбирает первое попавшееся значение.
Порядок выполнения запроса может быть произвольным и даже каждый раз разным, поэтому результат данной функции недетерминирован.
Для получения детерминированного результата, можно использовать функции min или max вместо any.

В некоторых случаях, вы всё-таки можете рассчитывать на порядок выполнения запроса. Это - случаи, когда SELECT идёт из подзапроса, в котором используется ORDER BY.

При наличии в запросе `SELECT` секции `GROUP BY` или хотя бы одной агрегатной функции, ClickHouse (в отличие от, например, MySQL) требует, чтобы все выражения в секциях `SELECT`, `HAVING`, `ORDER BY` вычислялись из ключей или из агрегатных функций. То есть, каждый выбираемый из таблицы столбец, должен использоваться либо в ключах, либо внутри агрегатных функций. Чтобы получить поведение, как в MySQL, вы можете поместить остальные столбцы в агрегатную функцию `any`.

## anyHeavy(x) {#agg_function-anyheavy}

Выбирает часто встречающееся значение с помощью алгоритма «[heavy hitters](http://www.cs.umd.edu/~samir/498/karp.pdf)». Если существует значение, которое встречается чаще, чем в половине случаев, в каждом потоке выполнения запроса, то возвращается данное значение. В общем случае, результат недетерминирован.

``` sql
anyHeavy(column)
```

**Аргументы**

-   `column` — имя столбца.

**Пример**

Возьмём набор данных [OnTime](../../getting-started/example-datasets/ontime.md) и выберем произвольное часто встречающееся значение в столбце `AirlineID`.

``` sql
SELECT anyHeavy(AirlineID) AS res
FROM ontime
```

``` text
┌───res─┐
│ 19690 │
└───────┘
```

## anyLast(x) {#anylastx}

Выбирает последнее попавшееся значение.
Результат так же недетерминирован, как и для функции `any`.

## groupBitAnd {#groupbitand}

Применяет побитовое `И` для последовательности чисел.

``` sql
groupBitAnd(expr)
```

**Параметры**

`expr` – выражение, результат которого имеет тип данных `UInt*`.

**Возвращаемое значение**

Значение типа `UInt*`.

**Пример**

Тестовые данные:

``` text
binary     decimal
00101100 = 44
00011100 = 28
00001101 = 13
01010101 = 85
```

Запрос:

``` sql
SELECT groupBitAnd(num) FROM t
```

Где `num` — столбец с тестовыми данными.

Результат:

``` text
binary     decimal
00000100 = 4
```

## groupBitOr {#groupbitor}

Применяет побитовое `ИЛИ` для последовательности чисел.

``` sql
groupBitOr(expr)
```

**Параметры**

`expr` – выражение, результат которого имеет тип данных `UInt*`.

**Возвращаемое значение**

Значение типа `UInt*`.

**Пример**

Тестовые данные:

``` text
binary     decimal
00101100 = 44
00011100 = 28
00001101 = 13
01010101 = 85
```

Запрос:

``` sql
SELECT groupBitOr(num) FROM t
```

Где `num` — столбец с тестовыми данными.

Результат:

``` text
binary     decimal
01111101 = 125
```

## groupBitXor {#groupbitxor}

Применяет побитовое `ИСКЛЮЧАЮЩЕЕ ИЛИ` для последовательности чисел.

``` sql
groupBitXor(expr)
```

**Параметры**

`expr` – выражение, результат которого имеет тип данных `UInt*`.

**Возвращаемое значение**

Значение типа `UInt*`.

**Пример**

Тестовые данные:

``` text
binary     decimal
00101100 = 44
00011100 = 28
00001101 = 13
01010101 = 85
```

Запрос:

``` sql
SELECT groupBitXor(num) FROM t
```

Где `num` — столбец с тестовыми данными.

Результат:

``` text
binary     decimal
01101000 = 104
```

## groupBitmap {#groupbitmap}

Bitmap или агрегатные вычисления для столбца с типом данных `UInt*`, возвращают кардинальность в виде значения типа UInt64, если добавить суффикс -State, то возвращают [объект bitmap](../../sql-reference/aggregate-functions/reference.md).

``` sql
groupBitmap(expr)
```

**Параметры**

`expr` – выражение, результат которого имеет тип данных `UInt*`.

**Возвращаемое значение**

Значение типа `UInt64`.

**Пример**

Тестовые данные:

``` text
UserID
1
1
2
3
```

Запрос:

``` sql
SELECT groupBitmap(UserID) as num FROM t
```

Результат:

``` text
num
3
```

## min(x) {#agg_function-min}

Вычисляет минимум.

## max(x) {#agg_function-max}

Вычисляет максимум.

## argMin(arg, val) {#agg-function-argmin}

Вычисляет значение arg при минимальном значении val. Если есть несколько разных значений arg для минимальных значений val, то выдаётся первое попавшееся из таких значений.

**Пример:**

``` text
┌─user─────┬─salary─┐
│ director │   5000 │
│ manager  │   3000 │
│ worker   │   1000 │
└──────────┴────────┘
```

``` sql
SELECT argMin(user, salary) FROM salary
```

``` text
┌─argMin(user, salary)─┐
│ worker               │
└──────────────────────┘
```

## argMax(arg, val) {#agg-function-argmax}

Вычисляет значение arg при максимальном значении val. Если есть несколько разных значений arg для максимальных значений val, то выдаётся первое попавшееся из таких значений.

## sum(x) {#agg_function-sum}

Вычисляет сумму.
Работает только для чисел.

## sumWithOverflow(x) {#agg_function-sumwithoverflow}

Вычисляет сумму чисел, используя для результата тот же тип данных, что и для входных параметров. Если сумма выйдет за максимальное значение для заданного типа данных, то функция вернёт ошибку.

Работает только для чисел.

## sumMap(key, value) {#summapkey-value}

Производит суммирование массива ‘value’ по соответствующим ключам заданным в массиве ‘key’.
Количество элементов в ‘key’ и ‘value’ должно быть одинаковым для каждой строки, для которой происходит суммирование.
Возвращает кортеж из двух массивов - ключи в отсортированном порядке и значения, просуммированные по соответствующим ключам.

Пример:

``` sql
CREATE TABLE sum_map(
    date Date,
    timeslot DateTime,
    statusMap Nested(
        status UInt16,
        requests UInt64
    )
) ENGINE = Log;
INSERT INTO sum_map VALUES
    ('2000-01-01', '2000-01-01 00:00:00', [1, 2, 3], [10, 10, 10]),
    ('2000-01-01', '2000-01-01 00:00:00', [3, 4, 5], [10, 10, 10]),
    ('2000-01-01', '2000-01-01 00:01:00', [4, 5, 6], [10, 10, 10]),
    ('2000-01-01', '2000-01-01 00:01:00', [6, 7, 8], [10, 10, 10]);
SELECT
    timeslot,
    sumMap(statusMap.status, statusMap.requests)
FROM sum_map
GROUP BY timeslot
```

``` text
┌────────────timeslot─┬─sumMap(statusMap.status, statusMap.requests)─┐
│ 2000-01-01 00:00:00 │ ([1,2,3,4,5],[10,10,20,10,10])               │
│ 2000-01-01 00:01:00 │ ([4,5,6,7,8],[10,10,20,10,10])               │
└─────────────────────┴──────────────────────────────────────────────┘
```

## skewPop {#skewpop}

Вычисляет [коэффициент асимметрии](https://ru.wikipedia.org/wiki/Коэффициент_асимметрии) для последовательности.

``` sql
skewPop(expr)
```

**Параметры**

`expr` — [Выражение](../syntax.md#syntax-expressions), возвращающее число.

**Возвращаемое значение**

Коэффициент асимметрии заданного распределения. Тип — [Float64](../../sql-reference/aggregate-functions/reference.md)

**Пример**

``` sql
SELECT skewPop(value) FROM series_with_value_column
```

## skewSamp {#skewsamp}

Вычисляет [выборочный коэффициент асимметрии](https://ru.wikipedia.org/wiki/Статистика_(функция_выборки)) для последовательности.

Он представляет собой несмещенную оценку асимметрии случайной величины, если переданные значения образуют ее выборку.

``` sql
skewSamp(expr)
```

**Параметры**

`expr` — [Выражение](../syntax.md#syntax-expressions), возвращающее число.

**Возвращаемое значение**

Коэффициент асимметрии заданного распределения. Тип — [Float64](../../sql-reference/aggregate-functions/reference.md). Если `n <= 1` (`n` — размер выборки), тогда функция возвращает `nan`.

**Пример**

``` sql
SELECT skewSamp(value) FROM series_with_value_column
```

## kurtPop {#kurtpop}

Вычисляет [коэффициент эксцесса](https://ru.wikipedia.org/wiki/Коэффициент_эксцесса) последовательности.

``` sql
kurtPop(expr)
```

**Параметры**

`expr` — [Выражение](../syntax.md#syntax-expressions), возвращающее число.

**Возвращаемое значение**

Коэффициент эксцесса заданного распределения. Тип — [Float64](../../sql-reference/aggregate-functions/reference.md)

**Пример**

``` sql
SELECT kurtPop(value) FROM series_with_value_column
```

## kurtSamp {#kurtsamp}

Вычисляет [выборочный коэффициент эксцесса](https://ru.wikipedia.org/wiki/Статистика_(функция_выборки)) для последовательности.

Он представляет собой несмещенную оценку эксцесса случайной величины, если переданные значения образуют ее выборку.

``` sql
kurtSamp(expr)
```

**Параметры**

`expr` — [Выражение](../syntax.md#syntax-expressions), возвращающее число.

**Возвращаемое значение**

Коэффициент эксцесса заданного распределения. Тип — [Float64](../../sql-reference/aggregate-functions/reference.md). Если `n <= 1` (`n` — размер выборки), тогда функция возвращает `nan`.

**Пример**

``` sql
SELECT kurtSamp(value) FROM series_with_value_column
```

## timeSeriesGroupSum(uid, timestamp, value) {#agg-function-timeseriesgroupsum}

`timeSeriesGroupSum` агрегирует временные ряды в которых не совпадают моменты.
Функция использует линейную интерполяцию между двумя значениями времени, а затем суммирует значения для одного и того же момента (как измеренные так и интерполированные) по всем рядам.

-   `uid` уникальный идентификатор временного ряда, `UInt64`.
-   `timestamp` имеет тип `Int64` чтобы можно было учитывать милли и микросекунды.
-   `value` представляет собой значение метрики.

Функция возвращает массив кортежей с парами `(timestamp, aggregated_value)`.

Временные ряды должны быть отсортированы по возрастанию `timestamp`.

Пример:

``` text
┌─uid─┬─timestamp─┬─value─┐
│ 1   │     2     │   0.2 │
│ 1   │     7     │   0.7 │
│ 1   │    12     │   1.2 │
│ 1   │    17     │   1.7 │
│ 1   │    25     │   2.5 │
│ 2   │     3     │   0.6 │
│ 2   │     8     │   1.6 │
│ 2   │    12     │   2.4 │
│ 2   │    18     │   3.6 │
│ 2   │    24     │   4.8 │
└─────┴───────────┴───────┘
```

``` sql
CREATE TABLE time_series(
    uid       UInt64,
    timestamp Int64,
    value     Float64
) ENGINE = Memory;
INSERT INTO time_series VALUES
    (1,2,0.2),(1,7,0.7),(1,12,1.2),(1,17,1.7),(1,25,2.5),
    (2,3,0.6),(2,8,1.6),(2,12,2.4),(2,18,3.6),(2,24,4.8);

SELECT timeSeriesGroupSum(uid, timestamp, value)
FROM (
    SELECT * FROM time_series order by timestamp ASC
);
```

И результат будет:

``` text
[(2,0.2),(3,0.9),(7,2.1),(8,2.4),(12,3.6),(17,5.1),(18,5.4),(24,7.2),(25,2.5)]
```

## timeSeriesGroupRateSum(uid, ts, val) {#agg-function-timeseriesgroupratesum}

Аналогично timeSeriesGroupSum, timeSeriesGroupRateSum будет вычислять производные по timestamp для рядов, а затем суммировать полученные производные для всех рядов для одного значения timestamp.
Также ряды должны быть отсортированы по возрастанию timestamp.

Для пример из описания timeSeriesGroupSum результат будет следующим:

``` text
[(2,0),(3,0.1),(7,0.3),(8,0.3),(12,0.3),(17,0.3),(18,0.3),(24,0.3),(25,0.1)]
```

## avg(x) {#agg_function-avg}

Вычисляет среднее.
Работает только для чисел.
Результат всегда Float64.

## avgWeighted {#avgweighted}

Вычисляет [среднее арифметическое взвешенное](https://ru.wikipedia.org/wiki/Среднее_арифметическое_взвешенное).

**Синтаксис**

``` sql
avgWeighted(x, weight)
```

**Параметры**

-   `x` — Значения. [Целые числа](../../sql-reference/aggregate-functions/reference.md) или [числа с плавающей запятой](../../sql-reference/aggregate-functions/reference.md).
-   `weight` — Веса отдельных значений. [Целые числа](../../sql-reference/aggregate-functions/reference.md) или [числа с плавающей запятой](../../sql-reference/aggregate-functions/reference.md).

Типы параметров должны совпадать.

**Возвращаемое значение**

-   Среднее арифметическое взвешенное.
-   `NaN`, если все веса равны 0.

Тип: [Float64](../../sql-reference/aggregate-functions/reference.md)

**Пример**

Запрос:

``` sql
SELECT avgWeighted(x, w)
FROM values('x Int8, w Int8', (4, 1), (1, 0), (10, 2))
```

Результат:

``` text
┌─avgWeighted(x, weight)─┐
│                      8 │
└────────────────────────┘
```

## uniq {#agg_function-uniq}

Приближённо вычисляет количество различных значений аргумента.

``` sql
uniq(x[, ...])
```

**Параметры**

Функция принимает переменное число входных параметров. Параметры могут быть числовых типов, а также `Tuple`, `Array`, `Date`, `DateTime`, `String`.

**Возвращаемое значение**

-   Значение с типом данных [UInt64](../../sql-reference/aggregate-functions/reference.md).

**Детали реализации**

Функция:

-   Вычисляет хэш для всех параметров агрегации, а затем использует его в вычислениях.

-   Использует адаптивный алгоритм выборки. В качестве состояния вычисления функция использует выборку хэш-значений элементов размером до 65536.

        Этот алгоритм очень точен и очень эффективен по использованию CPU. Если запрос содержит небольшое количество этих функций, использование `uniq` почти так же эффективно,  как и использование других агрегатных функций.

-   Результат детерминирован (не зависит от порядка выполнения запроса).

Эту функцию рекомендуется использовать практически во всех сценариях.

**Смотрите также**

-   [uniqCombined](#agg_function-uniqcombined)
-   [uniqCombined64](#agg_function-uniqcombined64)
-   [uniqHLL12](#agg_function-uniqhll12)
-   [uniqExact](#agg_function-uniqexact)

## uniqCombined {#agg_function-uniqcombined}

Приближённо вычисляет количество различных значений аргумента.

``` sql
uniqCombined(HLL_precision)(x[, ...])
```

Функция `uniqCombined` — это хороший выбор для вычисления количества различных значений.

**Параметры**

Функция принимает переменное число входных параметров. Параметры могут быть числовых типов, а также `Tuple`, `Array`, `Date`, `DateTime`, `String`.

`HLL_precision` — это логарифм по основанию 2 от числа ячеек в [HyperLogLog](https://en.wikipedia.org/wiki/HyperLogLog). Необязательный, можно использовать функцию как `uniqCombined (x [,...])`. Для `HLL_precision` значение по умолчанию — 17, что фактически составляет 96 КБ пространства (2^17 ячеек, 6 бит каждая).

**Возвращаемое значение**

-   Число типа [UInt64](../../sql-reference/aggregate-functions/reference.md).

**Детали реализации**

Функция:

-   Вычисляет хэш (64-битный для `String` и 32-битный для всех остальных типов) для всех параметров агрегации, а затем использует его в вычислениях.

-   Используется комбинация трёх алгоритмов: массив, хэш-таблица и HyperLogLog с таблицей коррекции погрешности.

        Для небольшого количества различных значений используется массив. Если размер набора больше, используется хэш-таблица. При дальнейшем увеличении количества значений, используется структура HyperLogLog, имеющая фиксированный размер в памяти.

-   Результат детерминирован (не зависит от порядка выполнения запроса).

!!! note "Note"
    Так как используется 32-битный хэш для не-`String` типов, результат будет иметь очень очень большую ошибку для количества разичных элементов существенно больше `UINT_MAX` (ошибка быстро растёт начиная с нескольких десятков миллиардов различных значений), таким образом в этом случае нужно использовать [uniqCombined64](#agg_function-uniqcombined64)

По сравнению с функцией [uniq](#agg_function-uniq), `uniqCombined`:

-   Потребляет в несколько раз меньше памяти.
-   Вычисляет с в несколько раз более высокой точностью.
-   Обычно имеет немного более низкую производительность. В некоторых сценариях `uniqCombined` может показывать более высокую производительность, чем `uniq`, например, в случае распределенных запросов, при которых по сети передаётся большое количество состояний агрегации.

**Смотрите также**

-   [uniq](#agg_function-uniq)
-   [uniqCombined64](#agg_function-uniqcombined64)
-   [uniqHLL12](#agg_function-uniqhll12)
-   [uniqExact](#agg_function-uniqexact)

## uniqCombined64 {#agg_function-uniqcombined64}

Использует 64-битный хэш для всех типов, в отличие от [uniqCombined](#agg_function-uniqcombined).

## uniqHLL12 {#agg_function-uniqhll12}

Вычисляет приблизительное число различных значений аргументов, используя алгоритм [HyperLogLog](https://en.wikipedia.org/wiki/HyperLogLog).

``` sql
uniqHLL12(x[, ...])
```

**Параметры**

Функция принимает переменное число входных параметров. Параметры могут быть числовых типов, а также `Tuple`, `Array`, `Date`, `DateTime`, `String`.

**Возвращаемое значение**

-   Значение хэша с типом данных [UInt64](../../sql-reference/aggregate-functions/reference.md).

**Детали реализации**

Функция:

-   Вычисляет хэш для всех параметров агрегации, а затем использует его в вычислениях.

-   Использует алгоритм HyperLogLog для аппроксимации числа различных значений аргументов.

        Используется 212 5-битовых ячеек. Размер состояния чуть больше 2.5 КБ. Результат не точный (ошибка до ~10%) для небольших множеств (<10K элементов). Однако для множеств большой кардинальности (10K - 100M) результат довольно точен (ошибка до ~1.6%). Начиная с 100M ошибка оценки будет только расти и для множеств огромной кардинальности (1B+ элементов) функция возвращает результат с очень большой неточностью.

-   Результат детерминирован (не зависит от порядка выполнения запроса).

Мы не рекомендуем использовать эту функцию. В большинстве случаев используйте функцию [uniq](#agg_function-uniq) или [uniqCombined](#agg_function-uniqcombined).

**Смотрите также**

-   [uniq](#agg_function-uniq)
-   [uniqCombined](#agg_function-uniqcombined)
-   [uniqExact](#agg_function-uniqexact)

## uniqExact {#agg_function-uniqexact}

Вычисляет точное количество различных значений аргументов.

``` sql
uniqExact(x[, ...])
```

Функцию `uniqExact` следует использовать, если вам обязательно нужен точный результат. В противном случае используйте функцию [uniq](#agg_function-uniq).

Функция `uniqExact` расходует больше оперативной памяти, чем функция `uniq`, так как размер состояния неограниченно растёт по мере роста количества различных значений.

**Параметры**

Функция принимает переменное число входных параметров. Параметры могут быть числовых типов, а также `Tuple`, `Array`, `Date`, `DateTime`, `String`.

**Смотрите также**

-   [uniq](#agg_function-uniq)
-   [uniqCombined](#agg_function-uniqcombined)
-   [uniqHLL12](#agg_function-uniqhll12)

## groupArray(x), groupArray(max\_size)(x) {#agg_function-grouparray}

Составляет массив из значений аргумента.
Значения в массив могут быть добавлены в любом (недетерминированном) порядке.

Вторая версия (с параметром `max_size`) ограничивает размер результирующего массива `max_size` элементами.
Например, `groupArray(1)(x)` эквивалентно `[any(x)]`.

В некоторых случаях, вы всё же можете рассчитывать на порядок выполнения запроса. Это — случаи, когда `SELECT` идёт из подзапроса, в котором используется `ORDER BY`.

## groupArrayInsertAt {#grouparrayinsertat}

Вставляет значение в заданную позицию массива.

**Синтаксис**

```sql
groupArrayInsertAt(default_x, size)(x, pos);
```

Если запрос вставляет вставляется несколько значений в одну и ту же позицию, то функция ведет себя следующим образом:

- Если запрос выполняется в одном потоке, то используется первое из вставляемых значений.
- Если запрос выполняется в нескольких потоках, то в результирующем массиве может оказаться любое из вставляемых значений.

**Параметры**

- `x` — Значение, которое будет вставлено. [Выражение](../syntax.md#syntax-expressions), возвращающее значение одного из [поддерживаемых типов данных](../../sql-reference/data-types/index.md#data_types).
- `pos` — Позиция, в которую вставляется заданный элемент `x`. Нумерация индексов в массиве начинается с нуля. [UInt32](../../sql-reference/data-types/int-uint.md#uint8-uint16-uint32-uint64-int8-int16-int32-int64).
- `default_x` — Значение по умолчанию для подстановки на пустые позиции. Опциональный параметр. [Выражение](../syntax.md#syntax-expressions), возвращающее значение с типом параметра `x`. Если `default_x` не определен, используются [значения по умолчанию](../../sql-reference/statements/create.md#create-default-values).
- `size`— Длина результирующего массива. Опциональный параметр. При использовании этого параметра должно быть указано значение по умолчанию `default_x`. [UInt32](../../sql-reference/data-types/int-uint.md#uint-ranges).

**Возвращаемое значение**

- Массив со вставленными значениями.

Тип: [Array](../../sql-reference/data-types/array.md#data-type-array).

**Примеры**

Запрос:

```sql
SELECT groupArrayInsertAt(toString(number), number * 2) FROM numbers(5);
```

Результат:

```text
┌─groupArrayInsertAt(toString(number), multiply(number, 2))─┐
│ ['0','','1','','2','','3','','4']                         │
└───────────────────────────────────────────────────────────┘
```

Запрос:

```sql
SELECT groupArrayInsertAt('-')(toString(number), number * 2) FROM numbers(5);
```

Результат:

```text
┌─groupArrayInsertAt('-')(toString(number), multiply(number, 2))─┐
│ ['0','-','1','-','2','-','3','-','4']                          │
└────────────────────────────────────────────────────────────────┘
```

Запрос:

```sql
SELECT groupArrayInsertAt('-', 5)(toString(number), number * 2) FROM numbers(5);
```

Результат:

```text
┌─groupArrayInsertAt('-', 5)(toString(number), multiply(number, 2))─┐
│ ['0','-','1','-','2']                                             │
└───────────────────────────────────────────────────────────────────┘
```

Многопоточная вставка элементов в одну позицию.

Запрос:

```sql
SELECT groupArrayInsertAt(number, 0) FROM numbers_mt(10) SETTINGS max_block_size = 1;
```

В результат этого запроса мы получите случайное целое число в диапазоне `[0,9]`. Например:

```text
┌─groupArrayInsertAt(number, 0)─┐
│ [7]                           │
└───────────────────────────────┘
```


## groupArrayMovingSum {#agg_function-grouparraymovingsum}

Вычисляет скользящую сумму входных значений.

``` sql
groupArrayMovingSum(numbers_for_summing)
groupArrayMovingSum(window_size)(numbers_for_summing)
```

Функция может принимать размер окна в качестве параметра. Если окно не указано, то функция использует размер окна, равный количеству строк в столбце.

**Параметры**

-   `numbers_for_summing` — [выражение](../syntax.md#syntax-expressions), возвращающее значение числового типа.
-   `window_size` — размер окна.

**Возвращаемые значения**

-   Массив того же размера и типа, что и входные данные.

**Пример**

Таблица с исходными данными:

``` sql
CREATE TABLE t
(
    `int` UInt8,
    `float` Float32,
    `dec` Decimal32(2)
)
ENGINE = TinyLog
```

``` text
┌─int─┬─float─┬──dec─┐
│   1 │   1.1 │ 1.10 │
│   2 │   2.2 │ 2.20 │
│   4 │   4.4 │ 4.40 │
│   7 │  7.77 │ 7.77 │
└─────┴───────┴──────┘
```

Запросы:

``` sql
SELECT
    groupArrayMovingSum(int) AS I,
    groupArrayMovingSum(float) AS F,
    groupArrayMovingSum(dec) AS D
FROM t
```

``` text
┌─I──────────┬─F───────────────────────────────┬─D──────────────────────┐
│ [1,3,7,14] │ [1.1,3.3000002,7.7000003,15.47] │ [1.10,3.30,7.70,15.47] │
└────────────┴─────────────────────────────────┴────────────────────────┘
```

``` sql
SELECT
    groupArrayMovingSum(2)(int) AS I,
    groupArrayMovingSum(2)(float) AS F,
    groupArrayMovingSum(2)(dec) AS D
FROM t
```

``` text
┌─I──────────┬─F───────────────────────────────┬─D──────────────────────┐
│ [1,3,6,11] │ [1.1,3.3000002,6.6000004,12.17] │ [1.10,3.30,6.60,12.17] │
└────────────┴─────────────────────────────────┴────────────────────────┘
```

## groupArrayMovingAvg {#agg_function-grouparraymovingavg}

Вычисляет скользящее среднее для входных значений.

    groupArrayMovingAvg(numbers_for_summing)
    groupArrayMovingAvg(window_size)(numbers_for_summing)

Функция может принимать размер окна в качестве параметра. Если окно не указано, то функция использует размер окна, равный количеству строк в столбце.

**Параметры**

-   `numbers_for_summing` — [выражение](../syntax.md#syntax-expressions), возвращающее значение числового типа.
-   `window_size` — размер окна.

**Возвращаемые значения**

-   Массив того же размера и типа, что и входные данные.

Функция использует [округление к меньшему по модулю](https://ru.wikipedia.org/wiki/Округление#Методы). Оно усекает десятичные разряды, незначимые для результирующего типа данных.

**Пример**

Таблица с исходными данными:

``` sql
CREATE TABLE t
(
    `int` UInt8,
    `float` Float32,
    `dec` Decimal32(2)
)
ENGINE = TinyLog
```

``` text
┌─int─┬─float─┬──dec─┐
│   1 │   1.1 │ 1.10 │
│   2 │   2.2 │ 2.20 │
│   4 │   4.4 │ 4.40 │
│   7 │  7.77 │ 7.77 │
└─────┴───────┴──────┘
```

Запросы:

``` sql
SELECT
    groupArrayMovingAvg(int) AS I,
    groupArrayMovingAvg(float) AS F,
    groupArrayMovingAvg(dec) AS D
FROM t
```

``` text
┌─I─────────┬─F───────────────────────────────────┬─D─────────────────────┐
│ [0,0,1,3] │ [0.275,0.82500005,1.9250001,3.8675] │ [0.27,0.82,1.92,3.86] │
└───────────┴─────────────────────────────────────┴───────────────────────┘
```

``` sql
SELECT
    groupArrayMovingAvg(2)(int) AS I,
    groupArrayMovingAvg(2)(float) AS F,
    groupArrayMovingAvg(2)(dec) AS D
FROM t
```

``` text
┌─I─────────┬─F────────────────────────────────┬─D─────────────────────┐
│ [0,1,3,5] │ [0.55,1.6500001,3.3000002,6.085] │ [0.55,1.65,3.30,6.08] │
└───────────┴──────────────────────────────────┴───────────────────────┘
```

## groupUniqArray(x), groupUniqArray(max\_size)(x) {#groupuniqarrayx-groupuniqarraymax-sizex}

Составляет массив из различных значений аргумента. Расход оперативной памяти такой же, как у функции `uniqExact`.

Функция `groupUniqArray(max_size)(x)` ограничивает размер результирующего массива до `max_size` элементов. Например, `groupUniqArray(1)(x)` равнозначно `[any(x)]`.

## quantile {#quantile}

Приблизительно вычисляет [квантиль](https://ru.wikipedia.org/wiki/Квантиль) числовой последовательности.

Функция использует алгоритм [reservoir sampling](https://en.wikipedia.org/wiki/Reservoir_sampling) с размером резервуара до 8192 и случайным генератором чисел для для сэмплирования. Результат не детерминирован. Чтобы получить точную квантиль используйте функцию [quantileExact](#quantileexact).

Внутренние состояния функций `quantile*` не объединяются, если они используются в одном запросе. Если вам необходимо вычислить квантили нескольких уровней, используйте функцию [quantiles](#quantiles), это повысит эффективность запроса.

**Синтаксис**

``` sql
quantile(level)(expr)
```

Алиас: `median`.

**Параметры**

-   `level` — Уровень квантили. Опционально. Константное значение с плавающей запятой от 0 до 1. Мы рекомендуем использовать значение `level` из диапазона `[0.01, 0.99]`. Значение по умолчанию: 0.5. При `level=0.5` функция вычисляет [медиану](https://ru.wikipedia.org/wiki/Медиана_(статистика)).
-   `expr` — Выражение над значениями столбца, которое возвращает данные [числовых типов](../../sql-reference/aggregate-functions/reference.md#data_types) или типов [Date](../../sql-reference/aggregate-functions/reference.md), [DateTime](../../sql-reference/aggregate-functions/reference.md).

**Возвращаемое значение**

-   Приблизительный квантиль заданного уровня.

Тип:

-   [Float64](../../sql-reference/aggregate-functions/reference.md) для входных данных числового типа.
-   [Date](../../sql-reference/aggregate-functions/reference.md), если входные значения имеют тип `Date`.
-   [DateTime](../../sql-reference/aggregate-functions/reference.md), если входные значения имеют тип `DateTime`.

**Пример**

Входная таблица:

``` text
┌─val─┐
│   1 │
│   1 │
│   2 │
│   3 │
└─────┘
```

Запрос:

``` sql
SELECT quantile(val) FROM t
```

Результат:

``` text
┌─quantile(val)─┐
│           1.5 │
└───────────────┘
```

**Смотрите также**

-   [median](#median)
-   [quantiles](#quantiles)

## quantileDeterministic {#quantiledeterministic}

Приблизительно вычисляет [квантиль](https://ru.wikipedia.org/wiki/Квантиль) числовой последовательности.

Функция использует алгоритм [reservoir sampling](https://en.wikipedia.org/wiki/Reservoir_sampling) с размером резервуара до 8192 и детерминированным алгоритмом сэмплирования. Результат детерминирован. Чтобы получить точную квантиль используйте функцию [quantileExact](#quantileexact).

Внутренние состояния функций `quantile*` не объединяются, если они используются в одном запросе. Если вам необходимо вычислить квантили нескольких уровней, используйте функцию [quantiles](#quantiles), это повысит эффективность запроса.

**Синтаксис**

``` sql
quantileDeterministic(level)(expr, determinator)
```

Алиас: `medianDeterministic`.

**Параметры**

-   `level` — Уровень квантили. Опционально. Константное значение с плавающей запятой от 0 до 1. Мы рекомендуем использовать значение `level` из диапазона `[0.01, 0.99]`. Значение по умолчанию: 0.5. При `level=0.5` функция вычисляет [медиану](https://ru.wikipedia.org/wiki/Медиана_(статистика)).
-   `expr` — Выражение над значениями столбца, которое возвращает данные [числовых типов](../../sql-reference/aggregate-functions/reference.md#data_types) или типов [Date](../../sql-reference/aggregate-functions/reference.md), [DateTime](../../sql-reference/aggregate-functions/reference.md).
-   `determinator` — Число, хэш которого используется при сэмплировании в алгоритме reservoir sampling, чтобы сделать результат детерминированным. В качестве детерминатора можно использовать любое определённое положительное число, например, идентификатор пользователя или события. Если одно и то же значение детерминатора попадается в выборке слишком часто, то функция выдаёт некорректный результат.

**Возвращаемое значение**

-   Приблизительный квантиль заданного уровня.

Тип:

-   [Float64](../../sql-reference/aggregate-functions/reference.md) для входных данных числового типа.
-   [Date](../../sql-reference/aggregate-functions/reference.md) если входные значения имеют тип `Date`.
-   [DateTime](../../sql-reference/aggregate-functions/reference.md) если входные значения имеют тип `DateTime`.

**Пример**

Входная таблица:

``` text
┌─val─┐
│   1 │
│   1 │
│   2 │
│   3 │
└─────┘
```

Запрос:

``` sql
SELECT quantileDeterministic(val, 1) FROM t
```

Результат:

``` text
┌─quantileDeterministic(val, 1)─┐
│                           1.5 │
└───────────────────────────────┘
```

**Смотрите также**

-   [median](#median)
-   [quantiles](#quantiles)

## quantileExact {#quantileexact}

Точно вычисляет [квантиль](https://ru.wikipedia.org/wiki/Квантиль) числовой последовательности.

Чтобы получить точный результат, все переданные значения собираются в массив, который затем частично сортируется. Таким образом, функция потребляет объем памяти `O(n)`, где `n` — количество переданных значений. Для небольшого числа значений эта функция эффективна.

Внутренние состояния функций `quantile*` не объединяются, если они используются в одном запросе. Если вам необходимо вычислить квантили нескольких уровней, используйте функцию [quantiles](#quantiles), это повысит эффективность запроса.

**Синтаксис**

``` sql
quantileExact(level)(expr)
```

Алиас: `medianExact`.

**Параметры**

-   `level` — Уровень квантили. Опционально. Константное значение с плавающей запятой от 0 до 1. Мы рекомендуем использовать значение `level` из диапазона `[0.01, 0.99]`. Значение по умолчанию: 0.5. При `level=0.5` функция вычисляет [медиану](https://ru.wikipedia.org/wiki/Медиана_(статистика)).
-   `expr` — Выражение над значениями столбца, которое возвращает данные [числовых типов](../../sql-reference/aggregate-functions/reference.md#data_types) или типов [Date](../../sql-reference/aggregate-functions/reference.md), [DateTime](../../sql-reference/aggregate-functions/reference.md).

**Возвращаемое значение**

-   Квантиль заданного уровня.

Тип:

-   [Float64](../../sql-reference/aggregate-functions/reference.md) для входных данных числового типа.
-   [Date](../../sql-reference/aggregate-functions/reference.md) если входные значения имеют тип `Date`.
-   [DateTime](../../sql-reference/aggregate-functions/reference.md) если входные значения имеют тип `DateTime`.

**Пример**

Запрос:

``` sql
SELECT quantileExact(number) FROM numbers(10)
```

Результат:

``` text
┌─quantileExact(number)─┐
│                     5 │
└───────────────────────┘
```

**Смотрите также**

-   [median](#median)
-   [quantiles](#quantiles)

## quantileExactWeighted {#quantileexactweighted}

Точно вычисляет [квантиль](https://ru.wikipedia.org/wiki/Квантиль) числовой последовательности, учитывая вес каждого её элемента.

Чтобы получить точный результат, все переданные значения собираются в массив, который затем частично сортируется. Для каждого значения учитывается его вес (количество значений в выборке). В алгоритме используется хэш-таблица. Таким образом, если переданные значения часто повторяются, функция потребляет меньше оперативной памяти, чем [quantileExact](#quantileexact). Эту функцию можно использовать вместо `quantileExact` если указать вес 1.

Внутренние состояния функций `quantile*` не объединяются, если они используются в одном запросе. Если вам необходимо вычислить квантили нескольких уровней, используйте функцию [quantiles](#quantiles), это повысит эффективность запроса.

**Синтаксис**

``` sql
quantileExactWeighted(level)(expr, weight)
```

Алиас: `medianExactWeighted`.

**Параметры**

-   `level` — Уровень квантили. Опционально. Константное значение с плавающей запятой от 0 до 1. Мы рекомендуем использовать значение `level` из диапазона `[0.01, 0.99]`. Значение по умолчанию: 0.5. При `level=0.5` функция вычисляет [медиану](https://ru.wikipedia.org/wiki/Медиана_(статистика)).
-   `expr` — Выражение над значениями столбца, которое возвращает данные [числовых типов](../../sql-reference/aggregate-functions/reference.md#data_types) или типов [Date](../../sql-reference/aggregate-functions/reference.md), [DateTime](../../sql-reference/aggregate-functions/reference.md).
-   `weight` — Столбец с весам элементов последовательности. Вес — это количество повторений элемента в последовательности.

**Возвращаемое значение**

-   Quantile of the specified level.

Тип:

-   [Float64](../../sql-reference/aggregate-functions/reference.md) для входных данных числового типа.
-   [Date](../../sql-reference/aggregate-functions/reference.md) если входные значения имеют тип `Date`.
-   [DateTime](../../sql-reference/aggregate-functions/reference.md) если входные значения имеют тип `DateTime`.

**Пример**

Входная таблица:

``` text
┌─n─┬─val─┐
│ 0 │   3 │
│ 1 │   2 │
│ 2 │   1 │
│ 5 │   4 │
└───┴─────┘
```

Запрос:

``` sql
SELECT quantileExactWeighted(n, val) FROM t
```

Результат:

``` text
┌─quantileExactWeighted(n, val)─┐
│                             1 │
└───────────────────────────────┘
```

**Смотрите также**

-   [median](#median)
-   [quantiles](#quantiles)

## quantileTiming {#quantiletiming}

Вычисляет [квантиль](https://ru.wikipedia.org/wiki/Квантиль) числовой последовательности с детерминированной точностью.

Результат детерминирован (не зависит от порядка обработки запроса). Функция оптимизирована для работы с последовательностями, описывающими такие распределения, как время загрузки веб-страниц или время отклика бэкенда.

Внутренние состояния функций `quantile*` не объединяются, если они используются в одном запросе. Если вам необходимо вычислить квантили нескольких уровней, используйте функцию [quantiles](#quantiles), это повысит эффективность запроса.

**Синтаксис**

``` sql
quantileTiming(level)(expr)
```

Алиас: `medianTiming`.

**Параметры**

-   `level` — Уровень квантили. Опционально. Константное значение с плавающей запятой от 0 до 1. Мы рекомендуем использовать значение `level` из диапазона `[0.01, 0.99]`. Значение по умолчанию: 0.5. При `level=0.5` функция вычисляет [медиану](https://ru.wikipedia.org/wiki/Медиана_(статистика)).

-   `expr` — [Выражение](../syntax.md#syntax-expressions) над значения столбца, которые возвращают данные типа [Float\*](../../sql-reference/aggregate-functions/reference.md).

        - Если в функцию передать отрицательные значения, то её поведение не определено.
        - Если значение больше, чем 30 000 (например, время загрузки страницы превышает 30 секунд), то оно приравнивается к 30 000.

**Точность**

Вычисления точны при соблюдении следующих условий:

-   Размер выборки не превышает 5670 элементов.
-   Размер выборки превышает 5670 элементов, но значение каждого элемента не больше 1024.

В противном случае, результат вычисления округляется до ближайшего множителя числа 16.

!!! note "Примечание"
    Для указанного типа последовательностей функция производительнее и точнее, чем [quantile](#quantile).

**Возвращаемое значение**

-   Квантиль заданного уровня.

Тип: `Float32`.

!!! note "Примечания"
    Если в функцию `quantileTimingIf` не передать значений, то вернётся [NaN](../../sql-reference/aggregate-functions/reference.md#data_type-float-nan-inf). Это необходимо для отделения подобных случаев от случаев, когда результат 0. Подробности про сортировку `NaN` cмотрите в разделе [Секция ORDER BY](../../sql-reference/statements/select/order-by.md#select-order-by).

**Пример**

Входная таблица:

``` text
┌─response_time─┐
│            72 │
│           112 │
│           126 │
│           145 │
│           104 │
│           242 │
│           313 │
│           168 │
│           108 │
└───────────────┘
```

Запрос:

``` sql
SELECT quantileTiming(response_time) FROM t
```

Результат:

``` text
┌─quantileTiming(response_time)─┐
│                           126 │
└───────────────────────────────┘
```

**Смотрите также**

-   [median](#median)
-   [quantiles](#quantiles)

## quantileTimingWeighted {#quantiletimingweighted}

С детерминированной точностью вычисляет [квантиль](https://ru.wikipedia.org/wiki/Квантиль) числовой последовательности, учитывая вес каждого элемента.

Результат детерминирован (не зависит от порядка обработки запроса). Функция оптимизирована для работы с последовательностями, описывающими такие распределения, как время загрузки веб-страниц или время отклика бэкенда.

Внутренние состояния функций `quantile*` не объединяются, если они используются в одном запросе. Если вам необходимо вычислить квантили нескольких уровней, используйте функцию [quantiles](#quantiles), это повысит эффективность запроса.

**Синтаксис**

``` sql
quantileTimingWeighted(level)(expr, weight)
```

Алиас: `medianTimingWeighted`.

**Параметры**

-   `level` — Уровень квантили. Опционально. Константное значение с плавающей запятой от 0 до 1. Мы рекомендуем использовать значение `level` из диапазона `[0.01, 0.99]`. Значение по умолчанию: 0.5. При `level=0.5` функция вычисляет [медиану](https://ru.wikipedia.org/wiki/Медиана_(статистика)).

-   `expr` — [Выражение](../syntax.md#syntax-expressions) над значения столбца, которые возвращают данные типа [Float\*](../../sql-reference/aggregate-functions/reference.md).

        - Если в функцию передать отрицательные значения, то её поведение не определено.
        - Если значение больше, чем 30 000 (например, время загрузки страницы превышает 30 секунд), то оно приравнивается к 30 000.

-   `weight` — Столбец с весам элементов последовательности. Вес — это количество повторений элемента в последовательности.

**Точность**

Вычисления точны при соблюдении следующих условий:

-   Размер выборки не превышает 5670 элементов.
-   Размер выборки превышает 5670 элементов, но значение каждого элемента не больше 1024.

В противном случае, результат вычисления округляется до ближайшего множителя числа 16.

!!! note "Примечание"
    Для указанного типа последовательностей функция производительнее и точнее, чем [quantile](#quantile).

**Возвращаемое значение**

-   Квантиль заданного уровня.

Тип: `Float32`.

!!! note "Примечания"
    Если в функцию `quantileTimingIf` не передать значений, то вернётся [NaN](../../sql-reference/aggregate-functions/reference.md#data_type-float-nan-inf). Это необходимо для отделения подобных случаев от случаев, когда результат 0. Подробности про сортировку `NaN` cмотрите в разделе [Секция ORDER BY](../../sql-reference/statements/select/order-by.md#select-order-by).

**Пример**

Входная таблица:

``` text
┌─response_time─┬─weight─┐
│            68 │      1 │
│           104 │      2 │
│           112 │      3 │
│           126 │      2 │
│           138 │      1 │
│           162 │      1 │
└───────────────┴────────┘
```

Запрос:

``` sql
SELECT quantileTimingWeighted(response_time, weight) FROM t
```

Результат:

``` text
┌─quantileTimingWeighted(response_time, weight)─┐
│                                           112 │
└───────────────────────────────────────────────┘
```

**Смотрите также**

-   [median](#median)
-   [quantiles](#quantiles)

## quantileTDigest {#quantiletdigest}

Приблизительно вычисляет [квантиль](https://ru.wikipedia.org/wiki/Квантиль) числовой последовательности, используя алгоритм [t-digest](https://github.com/tdunning/t-digest/blob/master/docs/t-digest-paper/histo.pdf).

Максимальная ошибка 1%. Потребление памяти — `log(n)`, где `n` — число значений. Результат не детерминирован и зависит от порядка выполнения запроса.

Производительность функции ниже, чем производительность функции [quantile](#quantile) или [quantileTiming](#quantiletiming). По соотношению размера состояния к точности вычисления, эта функция значительно превосходит `quantile`.

Внутренние состояния функций `quantile*` не объединяются, если они используются в одном запросе. Если вам необходимо вычислить квантили нескольких уровней, используйте функцию [quantiles](#quantiles), это повысит эффективность запроса.

**Синтаксис**

``` sql
quantileTDigest(level)(expr)
```

Алиас: `medianTDigest`.

**Параметры**

-   `level` — Уровень квантили. Опционально. Константное значение с плавающей запятой от 0 до 1. Мы рекомендуем использовать значение `level` из диапазона `[0.01, 0.99]`. Значение по умолчанию: 0.5. При `level=0.5` функция вычисляет [медиану](https://ru.wikipedia.org/wiki/Медиана_(статистика)).
-   `expr` — Выражение над значениями столбца, которое возвращает данные [числовых типов](../../sql-reference/aggregate-functions/reference.md#data_types) или типов [Date](../../sql-reference/aggregate-functions/reference.md), [DateTime](../../sql-reference/aggregate-functions/reference.md).

**Возвращаемое значение**

-   Приблизительную квантиль заданного уровня.

Тип:

-   [Float64](../../sql-reference/aggregate-functions/reference.md) для входных данных числового типа.
-   [Date](../../sql-reference/aggregate-functions/reference.md) если входные значения имеют тип `Date`.
-   [DateTime](../../sql-reference/aggregate-functions/reference.md) если входные значения имеют тип `DateTime`.

**Пример**

Запрос:

``` sql
SELECT quantileTDigest(number) FROM numbers(10)
```

Результат:

``` text
┌─quantileTDigest(number)─┐
│                     4.5 │
└─────────────────────────┘
```

**Смотрите также**

-   [median](#median)
-   [quantiles](#quantiles)

## quantileTDigestWeighted {#quantiletdigestweighted}

Приблизительно вычисляет [квантиль](https://ru.wikipedia.org/wiki/Квантиль) числовой последовательности, используя алгоритм [t-digest](https://github.com/tdunning/t-digest/blob/master/docs/t-digest-paper/histo.pdf). Функция учитывает вес каждого элемента последовательности.

Максимальная ошибка 1%. Потребление памяти — `log(n)`, где `n` — число значений. Результат не детерминирован и зависит от порядка выполнения запроса.

Производительность функции ниже, чем производительность функции [quantile](#quantile) или [quantileTiming](#quantiletiming). По соотношению размера состояния к точности вычисления, эта функция значительно превосходит `quantile`.

Внутренние состояния функций `quantile*` не объединяются, если они используются в одном запросе. Если вам необходимо вычислить квантили нескольких уровней, используйте функцию [quantiles](#quantiles), это повысит эффективность запроса.

**Синтаксис**

``` sql
quantileTDigestWeighted(level)(expr, weight)
```

Алиас: `medianTDigest`.

**Параметры**

-   `level` — Уровень квантили. Опционально. Константное значение с плавающей запятой от 0 до 1. Мы рекомендуем использовать значение `level` из диапазона `[0.01, 0.99]`. Значение по умолчанию: 0.5. При `level=0.5` функция вычисляет [медиану](https://ru.wikipedia.org/wiki/Медиана_(статистика)).
-   `expr` — Выражение над значениями столбца, которое возвращает данные [числовых типов](../../sql-reference/aggregate-functions/reference.md#data_types) или типов [Date](../../sql-reference/aggregate-functions/reference.md), [DateTime](../../sql-reference/aggregate-functions/reference.md).
-   `weight` — Столбец с весам элементов последовательности. Вес — это количество повторений элемента в последовательности.

**Возвращаемое значение**

-   Приблизительный квантиль заданного уровня.

Тип:

-   [Float64](../../sql-reference/aggregate-functions/reference.md) для входных данных числового типа.
-   [Date](../../sql-reference/aggregate-functions/reference.md) если входные значения имеют тип `Date`.
-   [DateTime](../../sql-reference/aggregate-functions/reference.md) если входные значения имеют тип `DateTime`.

**Пример**

Запрос:

``` sql
SELECT quantileTDigestWeighted(number, 1) FROM numbers(10)
```

Результат:

``` text
┌─quantileTDigestWeighted(number, 1)─┐
│                                4.5 │
└────────────────────────────────────┘
```

**Смотрите также**

-   [median](#median)
-   [quantiles](#quantiles)

## median {#median}

Функции `median*` — алиасы для соответствущих функций `quantile*`. Они вычисляют медиану числовой последовательности.

Functions:

-   `median` — алиас [quantile](#quantile).
-   `medianDeterministic` — алиас [quantileDeterministic](#quantiledeterministic).
-   `medianExact` — алиас [quantileExact](#quantileexact).
-   `medianExactWeighted` — алиас [quantileExactWeighted](#quantileexactweighted).
-   `medianTiming` — алиас [quantileTiming](#quantiletiming).
-   `medianTimingWeighted` — алиас [quantileTimingWeighted](#quantiletimingweighted).
-   `medianTDigest` — алиас [quantileTDigest](#quantiletdigest).
-   `medianTDigestWeighted` — алиас [quantileTDigestWeighted](#quantiletdigestweighted).

**Пример**

Входная таблица:

``` text
┌─val─┐
│   1 │
│   1 │
│   2 │
│   3 │
└─────┘
```

Запрос:

``` sql
SELECT medianDeterministic(val, 1) FROM t
```

Результат:

``` text
┌─medianDeterministic(val, 1)─┐
│                         1.5 │
└─────────────────────────────┘
```

## quantiles(level1, level2, …)(x) {#quantiles}

Для всех quantile-функций, также присутствуют соответствующие quantiles-функции: `quantiles`, `quantilesDeterministic`, `quantilesTiming`, `quantilesTimingWeighted`, `quantilesExact`, `quantilesExactWeighted`, `quantilesTDigest`. Эти функции за один проход вычисляют все квантили перечисленных уровней и возвращают массив вычисленных значений.

## varSamp(x) {#varsampx}

Вычисляет величину `Σ((x - x̅)^2) / (n - 1)`, где `n` - размер выборки, `x̅`- среднее значение `x`.

Она представляет собой несмещённую оценку дисперсии случайной величины, если переданные в функцию значения являются выборкой этой случайной величины.

Возвращает `Float64`. В случае, когда `n <= 1`, возвращается `+∞`.

!!! note "Примечание"
    Функция использует вычислительно неустойчивый алгоритм. Если для ваших расчётов необходима [вычислительная устойчивость](https://ru.wikipedia.org/wiki/Вычислительная_устойчивость), используйте функцию `varSampStable`. Она работает медленнее, но обеспечиват меньшую вычислительную ошибку.

## varPop(x) {#varpopx}

Вычисляет величину `Σ((x - x̅)^2) / n`, где `n` - размер выборки, `x̅`- среднее значение `x`.

То есть, дисперсию для множества значений. Возвращает `Float64`.

!!! note "Примечание"
    Функция использует вычислительно неустойчивый алгоритм. Если для ваших расчётов необходима [вычислительная устойчивость](https://ru.wikipedia.org/wiki/Вычислительная_устойчивость), используйте функцию `varPopStable`. Она работает медленнее, но обеспечивает меньшую вычислительную ошибку.

## stddevSamp(x) {#stddevsampx}

Результат равен квадратному корню от `varSamp(x)`.

!!! note "Примечание"
    Функция использует вычислительно неустойчивый алгоритм. Если для ваших расчётов необходима [вычислительная устойчивость](https://ru.wikipedia.org/wiki/Вычислительная_устойчивость), используйте функцию `stddevSampStable`. Она работает медленнее, но обеспечивает меньшую вычислительную ошибку.

## stddevPop(x) {#stddevpopx}

Результат равен квадратному корню от `varPop(x)`.

!!! note "Примечание"
    Функция использует вычислительно неустойчивый алгоритм. Если для ваших расчётов необходима [вычислительная устойчивость](https://ru.wikipedia.org/wiki/Вычислительная_устойчивость), используйте функцию `stddevPopStable`. Она работает медленнее, но обеспечивает меньшую вычислительную ошибку.


## topK(N)(column) {#topkncolumn}

Возвращает массив наиболее часто встречающихся значений в указанном столбце. Результирующий массив упорядочен по убыванию частоты значения (не по самим значениям).

Реализует [Filtered Space-Saving](http://www.l2f.inesc-id.pt/~fmmb/wiki/uploads/Work/misnis.ref0a.pdf) алгоритм для анализа TopK, на основе reduce-and-combine алгоритма из методики [Parallel Space Saving](https://arxiv.org/pdf/1401.0702.pdf).

``` sql
topK(N)(column)
```

Функция не дает гарантированного результата. В некоторых ситуациях могут возникать ошибки, и функция возвращает частые, но не наиболее частые значения.

Рекомендуем использовать значения `N < 10`, при больших `N` снижается производительность. Максимально возможное значение `N = 65536`.

**Аргументы**

-   ‘N’ - Количество значений.
-   ‘x’ – Столбец.

**Пример**

Возьмём набор данных [OnTime](../../getting-started/example-datasets/ontime.md) и выберем 3 наиболее часто встречающихся значения в столбце `AirlineID`.

``` sql
SELECT topK(3)(AirlineID) AS res
FROM ontime
```

``` text
┌─res─────────────────┐
│ [19393,19790,19805] │
└─────────────────────┘
```

## topKWeighted {#topkweighted}

Аналогична `topK`, но дополнительно принимает положительный целочисленный параметр `weight`. Каждое значение учитывается `weight` раз при расчёте частоты.

**Синтаксис**

``` sql
topKWeighted(N)(x, weight)
```

**Параметры**

-   `N` — Количество элементов для выдачи.

**Аргументы**

-   `x` – значение.
-   `weight` — вес. [UInt8](../../sql-reference/aggregate-functions/reference.md).

**Возвращаемое значение**

Возвращает массив значений с максимально приближенной суммой весов.

**Пример**

Запрос:

``` sql
SELECT topKWeighted(10)(number, number) FROM numbers(1000)
```

Результат:

``` text
┌─topKWeighted(10)(number, number)──────────┐
│ [999,998,997,996,995,994,993,992,991,990] │
└───────────────────────────────────────────┘
```

## covarSamp(x, y) {#covarsampx-y}

Вычисляет величину `Σ((x - x̅)(y - y̅)) / (n - 1)`.

Возвращает Float64. В случае, когда `n <= 1`, возвращается +∞.

!!! note "Примечание"
    Функция использует вычислительно неустойчивый алгоритм. Если для ваших расчётов необходима [вычислительная устойчивость](https://ru.wikipedia.org/wiki/Вычислительная_устойчивость), используйте функцию `covarSampStable`. Она работает медленнее, но обеспечивает меньшую вычислительную ошибку.

## covarPop(x, y) {#covarpopx-y}

Вычисляет величину `Σ((x - x̅)(y - y̅)) / n`.

!!! note "Примечание"
    Функция использует вычислительно неустойчивый алгоритм. Если для ваших расчётов необходима [вычислительная устойчивость](https://ru.wikipedia.org/wiki/Вычислительная_устойчивость), используйте функцию `covarPopStable`. Она работает медленнее, но обеспечивает меньшую вычислительную ошибку.


## corr(x, y) {#corrx-y}

Вычисляет коэффициент корреляции Пирсона: `Σ((x - x̅)(y - y̅)) / sqrt(Σ((x - x̅)^2) * Σ((y - y̅)^2))`.

!!! note "Примечание"
    Функция использует вычислительно неустойчивый алгоритм. Если для ваших расчётов необходима [вычислительная устойчивость](https://ru.wikipedia.org/wiki/Вычислительная_устойчивость), используйте функцию `corrStable`. Она работает медленнее, но обеспечивает меньшую вычислительную ошибку.

## simpleLinearRegression {#simplelinearregression}

Выполняет простую (одномерную) линейную регрессию.

``` sql
simpleLinearRegression(x, y)
```

Параметры:

-   `x` — столбец со значениями зависимой переменной.
-   `y` — столбец со значениями наблюдаемой переменной.

Возвращаемые значения:

Константы `(a, b)` результирующей прямой `y = a*x + b`.

**Примеры**

``` sql
SELECT arrayReduce('simpleLinearRegression', [0, 1, 2, 3], [0, 1, 2, 3])
```

``` text
┌─arrayReduce('simpleLinearRegression', [0, 1, 2, 3], [0, 1, 2, 3])─┐
│ (1,0)                                                             │
└───────────────────────────────────────────────────────────────────┘
```

``` sql
SELECT arrayReduce('simpleLinearRegression', [0, 1, 2, 3], [3, 4, 5, 6])
```

``` text
┌─arrayReduce('simpleLinearRegression', [0, 1, 2, 3], [3, 4, 5, 6])─┐
│ (1,3)                                                             │
└───────────────────────────────────────────────────────────────────┘
```

## stochasticLinearRegression {#agg_functions-stochasticlinearregression}

Функция реализует стохастическую линейную регрессию. Поддерживает пользовательские параметры для скорости обучения, коэффициента регуляризации L2, размера mini-batch и имеет несколько методов обновления весов ([Adam](https://en.wikipedia.org/wiki/Stochastic_gradient_descent#Adam) (по умолчанию), [simple SGD](https://en.wikipedia.org/wiki/Stochastic_gradient_descent), [Momentum](https://en.wikipedia.org/wiki/Stochastic_gradient_descent#Momentum), [Nesterov](https://mipt.ru/upload/medialibrary/d7e/41-91.pdf)).

### Параметры {#agg_functions-stochasticlinearregression-parameters}

Есть 4 настраиваемых параметра. Они передаются в функцию последовательно, однако не обязательно указывать все, используются значения по умолчанию, однако хорошая модель требует некоторой настройки параметров.

``` text
stochasticLinearRegression(1.0, 1.0, 10, 'SGD')
```

1.  Скорость обучения — коэффициент длины шага, при выполнении градиентного спуска. Слишком большая скорость обучения может привести к бесконечным весам модели. По умолчанию `0.00001`.
2.  Коэффициент регуляризации l2. Помогает предотвратить подгонку. По умолчанию `0.1`.
3.  Размер mini-batch задаёт количество элементов, чьи градиенты будут вычислены и просуммированы при выполнении одного шага градиентного спуска. Чистый стохастический спуск использует один элемент, однако использование mini-batch (около 10 элементов) делает градиентные шаги более стабильными. По умолчанию `15`.
4.  Метод обновления весов, можно выбрать один из следующих: `Adam` (по умолчанию), `SGD`, `Momentum`, `Nesterov`. `Momentum` и `Nesterov` более требовательные к вычислительным ресурсам и памяти, однако они имеют высокую скорость схождения и устойчивости методов стохастического градиента.

### Использование {#agg_functions-stochasticlinearregression-usage}

`stochasticLinearRegression` используется на двух этапах: построение модели и предсказание новых данных. Чтобы построить модель и сохранить её состояние для дальнейшего использования, мы используем комбинатор `-State`.
Для прогнозирования мы используем функцию [evalMLMethod](../functions/machine-learning-functions.md#machine_learning_methods-evalmlmethod), которая принимает в качестве аргументов состояние и свойства для прогнозирования.

<a name="stochasticlinearregression-usage-fitting"></a>

**1.** Построение модели

Пример запроса:

``` sql
CREATE TABLE IF NOT EXISTS train_data
(
    param1 Float64,
    param2 Float64,
    target Float64
) ENGINE = Memory;

CREATE TABLE your_model ENGINE = Memory AS SELECT
stochasticLinearRegressionState(0.1, 0.0, 5, 'SGD')(target, param1, param2)
AS state FROM train_data;
```

Здесь нам также нужно вставить данные в таблицу `train_data`. Количество параметров не фиксировано, оно зависит только от количества аргументов, перешедших в `linearRegressionState`. Все они должны быть числовыми значениями.
Обратите внимание, что столбец с целевым значением (которое мы хотели бы научиться предсказывать) вставляется в качестве первого аргумента.

**2.** Прогнозирование

После сохранения состояния в таблице мы можем использовать его несколько раз для прогнозирования или смёржить с другими состояниями и создать новые, улучшенные модели.

``` sql
WITH (SELECT state FROM your_model) AS model SELECT
evalMLMethod(model, param1, param2) FROM test_data
```

Запрос возвращает столбец прогнозируемых значений. Обратите внимание, что первый аргумент `evalMLMethod` это объект `AggregateFunctionState`, далее идут столбцы свойств.

`test_data` — это таблица, подобная `train_data`, но при этом может не содержать целевое значение.

### Примечания {#agg_functions-stochasticlinearregression-notes}

1.  Объединить две модели можно следующим запросом:

<!-- -->

    ``` sql
    SELECT state1 + state2 FROM your_models
    ```

где таблица `your_models` содержит обе модели. Запрос вернёт новый объект `AggregateFunctionState`.

1.  Пользователь может получать веса созданной модели для своих целей без сохранения модели, если не использовать комбинатор `-State`.

<!-- -->

    ``` sql
    SELECT stochasticLinearRegression(0.01)(target, param1, param2) FROM train_data
    ```

Подобный запрос строит модель и возвращает её веса, отвечающие параметрам моделей и смещение. Таким образом, в приведенном выше примере запрос вернет столбец с тремя значениями.

**Смотрите также**

-   [stochasticLogisticRegression](#agg_functions-stochasticlogisticregression)
-   [Отличие линейной от логистической регрессии.](https://stackoverflow.com/questions/12146914/what-is-the-difference-between-linear-regression-and-logistic-regression)

## stochasticLogisticRegression {#agg_functions-stochasticlogisticregression}

Функция реализует стохастическую логистическую регрессию. Её можно использовать для задачи бинарной классификации, функция поддерживает те же пользовательские параметры, что и stochasticLinearRegression и работает таким же образом.

### Параметры {#agg_functions-stochasticlogisticregression-parameters}

Параметры те же, что и в stochasticLinearRegression:
`learning rate`, `l2 regularization coefficient`, `mini-batch size`, `method for updating weights`.
Смотрите раздел [parameters](#agg_functions-stochasticlinearregression-parameters).

``` text
stochasticLogisticRegression(1.0, 1.0, 10, 'SGD')
```

1.  Построение модели

<!-- -->

Смотрите раздел `Построение модели` в описании [stochasticLinearRegression](#stochasticlinearregression-usage-fitting) .

    Прогнозируемые метки должны быть в диапазоне \[-1, 1\].

1.  Прогнозирование

<!-- -->

Используя сохраненное состояние, можно предсказать вероятность наличия у объекта метки `1`.

    ``` sql
    WITH (SELECT state FROM your_model) AS model SELECT
    evalMLMethod(model, param1, param2) FROM test_data
    ```

Запрос возвращает столбец вероятностей. Обратите внимание, что первый аргумент `evalMLMethod` это объект `AggregateFunctionState`, далее идут столбцы свойств.

Мы также можем установить границу вероятности, которая присваивает элементам различные метки.

    ``` sql
    SELECT ans < 1.1 AND ans > 0.5 FROM
    (WITH (SELECT state FROM your_model) AS model SELECT
    evalMLMethod(model, param1, param2) AS ans FROM test_data)
    ```

Тогда результатом будут метки.

`test_data` — это таблица, подобная `train_data`, но при этом может не содержать целевое значение.

**Смотрите также**

-   [stochasticLinearRegression](#agg_functions-stochasticlinearregression)
-   [Отличие линейной от логистической регрессии](https://moredez.ru/q/51225972/)

[Оригинальная статья](https://clickhouse.tech/docs/ru/query_language/agg_functions/reference/) <!--hide-->
