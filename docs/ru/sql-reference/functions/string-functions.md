# Функции для работы со строками {#funktsii-dlia-raboty-so-strokami}

## empty {#empty}

Возвращает 1 для пустой строки, и 0 для непустой строки.
Тип результата — UInt8.
Строка считается непустой, если содержит хотя бы один байт, пусть даже это пробел или нулевой байт.
Функция также работает для массивов.

## notEmpty {#notempty}

Возвращает 0 для пустой строки, и 1 для непустой строки.
Тип результата — UInt8.
Функция также работает для массивов.

## length {#length}

Возвращает длину строки в байтах (не символах, не кодовых точках).
Тип результата — UInt64.
Функция также работает для массивов.

## lengthUTF8 {#lengthutf8}

Возвращает длину строки в кодовых точках Unicode (не символах), при допущении, что строка содержит набор байтов, являющийся текстом в кодировке UTF-8. Если допущение не выполнено, то возвращает какой-нибудь результат (не кидает исключение).
Тип результата — UInt64.

## char\_length, CHAR\_LENGTH {#char-length}

Возвращает длину строки в кодовых точках Unicode (не символах), при допущении, что строка содержит набор байтов, являющийся текстом в кодировке UTF-8. Если допущение не выполнено, возвращает какой-нибудь результат (не кидает исключение).
Тип результата — UInt64.

## character\_length, CHARACTER\_LENGTH {#character-length}

Возвращает длину строки в кодовых точках Unicode (не символах), при допущении, что строка содержит набор байтов, являющийся текстом в кодировке UTF-8. Если допущение не выполнено, возвращает какой-нибудь результат (не кидает исключение).
Тип результата — UInt64.

## lower, lcase {#lower}

Переводит ASCII-символы латиницы в строке в нижний регистр.

## upper, ucase {#upper}

Переводит ASCII-символы латиницы в строке в верхний регистр.

## lowerUTF8 {#lowerutf8}

Переводит строку в нижний регистр, при допущении, что строка содержит набор байтов, представляющий текст в кодировке UTF-8.
Не учитывает язык. То есть, для турецкого языка, результат может быть не совсем верным.
Если длина UTF-8 последовательности байтов различна для верхнего и нижнего регистра кодовой точки, то для этой кодовой точки результат работы может быть некорректным.
Если строка содержит набор байтов, не являющийся UTF-8, то поведение не определено.

## upperUTF8 {#upperutf8}

Переводит строку в верхний регистр, при допущении, что строка содержит набор байтов, представляющий текст в кодировке UTF-8.
Не учитывает язык. То есть, для турецкого языка, результат может быть не совсем верным.
Если длина UTF-8 последовательности байтов различна для верхнего и нижнего регистра кодовой точки, то для этой кодовой точки, результат работы может быть некорректным.
Если строка содержит набор байтов, не являющийся UTF-8, то поведение не определено.

## isValidUTF8 {#isvalidutf8}

Возвращает 1, если набор байтов является корректным в кодировке UTF-8, 0 иначе.

## toValidUTF8 {#tovalidutf8}

Заменяет некорректные символы UTF-8 на символ `�` (U+FFFD). Все идущие подряд некорректные символы схлопываются в один заменяющий символ.

``` sql
toValidUTF8( input_string )
```

Параметры:

-   input\_string — произвольный набор байтов, представленный как объект типа [String](../../sql-reference/functions/string-functions.md).

Возвращаемое значение: Корректная строка UTF-8.

**Пример**

``` sql
SELECT toValidUTF8('\x61\xF0\x80\x80\x80b')
```

``` text
┌─toValidUTF8('a����b')─┐
│ a�b                   │
└───────────────────────┘
```

## repeat {#repeat}

Повторяет строку определенное количество раз и объединяет повторяемые значения в одну строку.

**Синтаксис**

``` sql
repeat(s, n)
```

**Параметры**

-   `s` — Строка для повторения. [String](../../sql-reference/functions/string-functions.md).
-   `n` — Количество повторов. [UInt](../../sql-reference/functions/string-functions.md).

**Возвращаемое значение**

Строка, состоящая из повторений `n` раз исходной строки `s`. Если `n` \< 1, то функция вернет пустую строку.

Тип: `String`.

**Пример**

Запрос:

``` sql
SELECT repeat('abc', 10)
```

Ответ:

``` text
┌─repeat('abc', 10)──────────────┐
│ abcabcabcabcabcabcabcabcabcabc │
└────────────────────────────────┘
```

## reverse {#reverse}

Разворачивает строку (как последовательность байтов).

## reverseUTF8 {#reverseutf8}

Разворачивает последовательность кодовых точек Unicode, при допущении, что строка содержит набор байтов, представляющий текст в кодировке UTF-8. Иначе — что-то делает (не кидает исключение).

## format(pattern, s0, s1, …) {#format}

Форматирует константный шаблон со строками, перечисленными в аргументах. `pattern` — упрощенная версия шаблона в языке Python. Шаблон содержит «заменяющие поля», которые окружены фигурными скобками `{}`. Всё, что не содержится в скобках, интерпретируется как обычный текст и просто копируется. Если нужно использовать символ фигурной скобки, можно экранировать двойной скобкой `{{ '{{' }}` или `{{ '}}' }}`. Имя полей могут быть числами (нумерация с нуля) или пустыми (тогда они интерпретируются как последовательные числа).

``` sql
SELECT format('{1} {0} {1}', 'World', 'Hello')
```

``` text
┌─format('{1} {0} {1}', 'World', 'Hello')─┐
│ Hello World Hello                       │
└─────────────────────────────────────────┘
```

``` sql
SELECT format('{} {}', 'Hello', 'World')
```

``` text
┌─format('{} {}', 'Hello', 'World')─┐
│ Hello World                       │
└───────────────────────────────────┘
```

## concat {#concat}

Склеивает строки, переданные в аргументы, в одну строку без разделителей.

**Cинтаксис**

``` sql
concat(s1, s2, ...)
```

**Параметры**

Значения типа String или FixedString.

**Возвращаемое значение**

Возвращает строку, полученную в результате склейки аргументов.

Если любой из аргументов имеет значение `NULL`, `concat` возвращает значение `NULL`.

**Пример**

Запрос:

``` sql
SELECT concat('Hello, ', 'World!')
```

Ответ:

``` text
┌─concat('Hello, ', 'World!')─┐
│ Hello, World!               │
└─────────────────────────────┘
```

## concatAssumeInjective {#concatassumeinjective}

Аналогична [concat](#concat). Разница заключается в том, что вам нужно убедиться, что `concat(s1, s2, ...) → sn` является инъективным, так как это предположение будет использоваться для оптимизации GROUP BY.

Функция называется «инъективной», если она возвращает разные значения для разных аргументов. Или, иными словами, функция никогда не выдаёт одно и то же значение, если аргументы разные.

**Синтаксис**

``` sql
concatAssumeInjective(s1, s2, ...)
```

**Параметры**

Значения типа String или FixedString.

**Возвращаемые значения**

Возвращает строку, полученную в результате объединения аргументов.

Если любой из аргументов имеет значение `NULL`, `concatAssumeInjective` возвращает значение `NULL`.

**Пример**

Вводная таблица:

``` sql
CREATE TABLE key_val(`key1` String, `key2` String, `value` UInt32) ENGINE = TinyLog
INSERT INTO key_val VALUES ('Hello, ','World',1)('Hello, ','World',2)('Hello, ','World!',3)('Hello',', World!',2)
SELECT * from key_val
```

``` text
┌─key1────┬─key2─────┬─value─┐
│ Hello,  │ World    │     1 │
│ Hello,  │ World    │     2 │
│ Hello,  │ World!   │     3 │
│ Hello   │ , World! │     2 │
└─────────┴──────────┴───────┘
```

Запрос:

``` sql
SELECT concat(key1, key2), sum(value) FROM key_val GROUP BY (key1, key2)
```

Ответ:

``` text
┌─concat(key1, key2)─┬─sum(value)─┐
│ Hello, World!      │          3 │
│ Hello, World!      │          2 │
│ Hello, World       │          3 │
└────────────────────┴────────────┘
```

## substring(s, offset, length), mid(s, offset, length), substr(s, offset, length) {#substring}

Возвращает подстроку, начиная с байта по индексу offset, длины length байт. Индексация символов — начиная с единицы (как в стандартном SQL). Аргументы offset и length должны быть константами.

## substringUTF8(s, offset, length) {#substringutf8}

Так же, как substring, но для кодовых точек Unicode. Работает при допущении, что строка содержит набор байтов, представляющий текст в кодировке UTF-8. Если допущение не выполнено, то возвращает какой-нибудь результат (не кидает исключение).

## appendTrailingCharIfAbsent(s, c) {#appendtrailingcharifabsent}

Если строка s непустая и не содержит символ c на конце, то добавляет символ c в конец.

## convertCharset(s, from, to) {#convertcharset}

Возвращает сконвертированную из кодировки from в кодировку to строку s.

## base64Encode(s) {#base64encode}

Производит кодирование строки s в base64-представление.

## base64Decode(s) {#base64decode}

Декодирует base64-представление s в исходную строку. При невозможности декодирования выбрасывает исключение

## tryBase64Decode(s) {#trybase64decode}

Функционал аналогичен base64Decode, но при невозможности декодирования возвращает пустую строку.

## endsWith(s, suffix) {#endswith}

Возвращает 1, если строка завершается указанным суффиксом, и 0 в противном случае.

## startsWith(str, prefix) {#startswith}

Возвращает 1, если строка начинается указанным префиксом, в противном случае 0.

``` sql
SELECT startsWith('Spider-Man', 'Spi');
```

**Возвращаемые значения**

-   1, если строка начинается указанным префиксом.
-   0, если строка не начинается указанным префиксом.

**Пример**

Запрос:

``` sql
SELECT startsWith('Hello, world!', 'He');
```

Ответ:

``` text
┌─startsWith('Hello, world!', 'He')─┐
│                                 1 │
└───────────────────────────────────┘
```

## trim {#trim}

Удаляет все указанные символы с начала или окончания строки.
По умолчанию удаляет все последовательные вхождения обычных пробелов (32 символ ASCII) с обоих концов строки.

**Синтаксис**

``` sql
trim([[LEADING|TRAILING|BOTH] trim_character FROM] input_string)
```

**Параметры**

-   `trim_character` — один или несколько символов, подлежащие удалению. [String](../../sql-reference/functions/string-functions.md).
-   `input_string` — строка для обрезки. [String](../../sql-reference/functions/string-functions.md).

**Возвращаемое значение**

Исходную строку после обрезки с левого и (или) правого концов строки.

Тип: `String`.

**Пример**

Запрос:

``` sql
SELECT trim(BOTH ' ()' FROM '(   Hello, world!   )')
```

Ответ:

``` text
┌─trim(BOTH ' ()' FROM '(   Hello, world!   )')─┐
│ Hello, world!                                 │
└───────────────────────────────────────────────┘
```

## trimLeft {#trimleft}

Удаляет все последовательные вхождения обычных пробелов (32 символ ASCII) с левого конца строки. Не удаляет другие виды пробелов (табуляция, пробел без разрыва и т. д.).

**Синтаксис**

``` sql
trimLeft(input_string)
```

Алиас: `ltrim(input_string)`.

**Параметры**

-   `input_string` — строка для обрезки. [String](../../sql-reference/functions/string-functions.md).

**Возвращаемое значение**

Исходную строку без общих пробельных символов слева.

Тип: `String`.

**Пример**

Запрос:

``` sql
SELECT trimLeft('     Hello, world!     ')
```

Ответ:

``` text
┌─trimLeft('     Hello, world!     ')─┐
│ Hello, world!                       │
└─────────────────────────────────────┘
```

## trimRight {#trimright}

Удаляет все последовательные вхождения обычных пробелов (32 символ ASCII) с правого конца строки. Не удаляет другие виды пробелов (табуляция, пробел без разрыва и т. д.).

**Синтаксис**

``` sql
trimRight(input_string)
```

Алиас: `rtrim(input_string)`.

**Параметры**

-   `input_string` — строка для обрезки. [String](../../sql-reference/functions/string-functions.md).

**Возвращаемое значение**

Исходную строку без общих пробельных символов справа.

Тип: `String`.

**Пример**

Запрос:

``` sql
SELECT trimRight('     Hello, world!     ')
```

Ответ:

``` text
┌─trimRight('     Hello, world!     ')─┐
│      Hello, world!                   │
└──────────────────────────────────────┘
```

## trimBoth {#trimboth}

Удаляет все последовательные вхождения обычных пробелов (32 символ ASCII) с обоих концов строки. Не удаляет другие виды пробелов (табуляция, пробел без разрыва и т. д.).

**Синтаксис**

``` sql
trimBoth(input_string)
```

Алиас: `trim(input_string)`.

**Параметры**

-   `input_string` — строка для обрезки. [String](../../sql-reference/functions/string-functions.md).

**Возвращаемое значение**

Исходную строку без общих пробельных символов с обоих концов строки.

Тип: `String`.

**Пример**

Запрос:

``` sql
SELECT trimBoth('     Hello, world!     ')
```

Ответ:

``` text
┌─trimBoth('     Hello, world!     ')─┐
│ Hello, world!                       │
└─────────────────────────────────────┘
```

## CRC32(s) {#crc32}

Возвращает чексумму CRC32 данной строки, используется CRC-32-IEEE 802.3 многочлен и начальным значением `0xffffffff` (т.к. используется реализация из zlib).

Тип результата — UInt32.

## CRC32IEEE(s) {#crc32ieee}

Возвращает чексумму CRC32 данной строки, используется CRC-32-IEEE 802.3 многочлен.

Тип результата — UInt32.

## CRC64(s) {#crc64}

Возвращает чексумму CRC64 данной строки, используется CRC-64-ECMA многочлен.

Тип результата — UInt64.

[Оригинальная статья](https://clickhouse.tech/docs/ru/query_language/functions/string_functions/) <!--hide-->
