---
toc_priority: 40
toc_title: "Функции для работы со строками"
---

# Функции для работы со строками {#funktsii-dlia-raboty-so-strokami}

## empty {#empty}

Возвращает 1 для пустой строки, и 0 для непустой строки.
Тип результата — UInt8.
Строка считается непустой, если содержит хотя бы один байт, пусть даже это пробел или нулевой байт.
Функция также работает для массивов.

## notEmpty {#notempty}

Возвращает 0 для пустой строки, и 1 для непустой строки.
Тип результата — UInt8.
Функция также работает для массивов.

## length {#length}

Возвращает длину строки в байтах (не символах, не кодовых точках).
Тип результата — UInt64.
Функция также работает для массивов.

## lengthUTF8 {#lengthutf8}

Возвращает длину строки в кодовых точках Unicode (не символах), при допущении, что строка содержит набор байтов, являющийся текстом в кодировке UTF-8. Если допущение не выполнено, то возвращает какой-нибудь результат (не кидает исключение).
Тип результата — UInt64.

## char_length, CHAR_LENGTH {#char-length}

Возвращает длину строки в кодовых точках Unicode (не символах), при допущении, что строка содержит набор байтов, являющийся текстом в кодировке UTF-8. Если допущение не выполнено, возвращает какой-нибудь результат (не кидает исключение).
Тип результата — UInt64.

## character_length, CHARACTER_LENGTH {#character-length}

Возвращает длину строки в кодовых точках Unicode (не символах), при допущении, что строка содержит набор байтов, являющийся текстом в кодировке UTF-8. Если допущение не выполнено, возвращает какой-нибудь результат (не кидает исключение).
Тип результата — UInt64.

## lower, lcase {#lower}

Переводит ASCII-символы латиницы в строке в нижний регистр.

## upper, ucase {#upper}

Переводит ASCII-символы латиницы в строке в верхний регистр.

## lowerUTF8 {#lowerutf8}

Переводит строку в нижний регистр, при допущении, что строка содержит набор байтов, представляющий текст в кодировке UTF-8.
Не учитывает язык. То есть, для турецкого языка, результат может быть не совсем верным.
Если длина UTF-8 последовательности байтов различна для верхнего и нижнего регистра кодовой точки, то для этой кодовой точки результат работы может быть некорректным.
Если строка содержит набор байтов, не являющийся UTF-8, то поведение не определено.

## upperUTF8 {#upperutf8}

Переводит строку в верхний регистр, при допущении, что строка содержит набор байтов, представляющий текст в кодировке UTF-8.
Не учитывает язык. То есть, для турецкого языка, результат может быть не совсем верным.
Если длина UTF-8 последовательности байтов различна для верхнего и нижнего регистра кодовой точки, то для этой кодовой точки, результат работы может быть некорректным.
Если строка содержит набор байтов, не являющийся UTF-8, то поведение не определено.

## isValidUTF8 {#isvalidutf8}

Возвращает 1, если набор байтов является корректным в кодировке UTF-8, 0 иначе.

## toValidUTF8 {#tovalidutf8}

Заменяет некорректные символы UTF-8 на символ `�` (U+FFFD). Все идущие подряд некорректные символы схлопываются в один заменяющий символ.

``` sql
toValidUTF8(input_string)
```

**Аргументы**

-   `input_string` — произвольный набор байтов, представленный как объект типа [String](../../sql-reference/functions/string-functions.md).

Возвращаемое значение: Корректная строка UTF-8.

**Пример**

``` sql
SELECT toValidUTF8('\x61\xF0\x80\x80\x80b');
```

``` text
┌─toValidUTF8('a����b')─┐
│ a�b                   │
└───────────────────────┘
```

## repeat {#repeat}

Повторяет строку определенное количество раз и объединяет повторяемые значения в одну строку.

Синоним: `REPEAT`.

**Синтаксис**

``` sql
repeat(s, n)
```

**Аргументы**

-   `s` — строка для повторения. [String](../../sql-reference/functions/string-functions.md).
-   `n` — количество повторов. [UInt](../../sql-reference/functions/string-functions.md).

**Возвращаемое значение**

Строка, состоящая из повторений `n` раз исходной строки `s`. Если `n` \< 1, то функция вернет пустую строку.

Тип: `String`.

**Пример**

Запрос:

``` sql
SELECT repeat('abc', 10);
```

Результат:

``` text
┌─repeat('abc', 10)──────────────┐
│ abcabcabcabcabcabcabcabcabcabc │
└────────────────────────────────┘
```

## reverse {#reverse}

Разворачивает строку (как последовательность байтов).

## reverseUTF8 {#reverseutf8}

Разворачивает последовательность кодовых точек Unicode, при допущении, что строка содержит набор байтов, представляющий текст в кодировке UTF-8. Иначе — что-то делает (не кидает исключение).

## format(pattern, s0, s1, …) {#format}

Форматирует константный шаблон со строками, перечисленными в аргументах. `pattern` — упрощенная версия шаблона в языке Python. Шаблон содержит «заменяющие поля», которые окружены фигурными скобками `{}`. Всё, что не содержится в скобках, интерпретируется как обычный текст и просто копируется. Если нужно использовать символ фигурной скобки, можно экранировать двойной скобкой `{{ '{{' }}` или `{{ '}}' }}`. Имя полей могут быть числами (нумерация с нуля) или пустыми (тогда они интерпретируются как последовательные числа).

``` sql
SELECT format('{1} {0} {1}', 'World', 'Hello')
```

``` text
┌─format('{1} {0} {1}', 'World', 'Hello')─┐
│ Hello World Hello                       │
└─────────────────────────────────────────┘
```

``` sql
SELECT format('{} {}', 'Hello', 'World')
```

``` text
┌─format('{} {}', 'Hello', 'World')─┐
│ Hello World                       │
└───────────────────────────────────┘
```

## concat {#concat}

Склеивает строки, переданные в аргументы, в одну строку без разделителей.

**Cинтаксис**

``` sql
concat(s1, s2, ...)
```

**Аргументы**

Значения типа String или FixedString.

**Возвращаемое значение**

Возвращает строку, полученную в результате склейки аргументов.

Если любой из аргументов имеет значение `NULL`, `concat` возвращает значение `NULL`.

**Пример**

Запрос:

``` sql
SELECT concat('Hello, ', 'World!');
```

Результат:

``` text
┌─concat('Hello, ', 'World!')─┐
│ Hello, World!               │
└─────────────────────────────┘
```

## concatAssumeInjective {#concatassumeinjective}

Аналогична [concat](#concat). Разница заключается в том, что вам нужно убедиться, что `concat(s1, s2, ...) → sn` является инъективным, так как это предположение будет использоваться для оптимизации GROUP BY.

Функция называется «инъективной», если она возвращает разные значения для разных аргументов. Или, иными словами, функция никогда не выдаёт одно и то же значение, если аргументы разные.

**Синтаксис**

``` sql
concatAssumeInjective(s1, s2, ...)
```

**Аргументы**

Значения типа String или FixedString.

**Возвращаемые значения**

Возвращает строку, полученную в результате объединения аргументов.

Если любой из аргументов имеет значение `NULL`, `concatAssumeInjective` возвращает значение `NULL`.

**Пример**

Вводная таблица:

``` sql
CREATE TABLE key_val(`key1` String, `key2` String, `value` UInt32) ENGINE = TinyLog
INSERT INTO key_val VALUES ('Hello, ','World',1)('Hello, ','World',2)('Hello, ','World!',3)('Hello',', World!',2)
SELECT * from key_val
```

``` text
┌─key1────┬─key2─────┬─value─┐
│ Hello,  │ World    │     1 │
│ Hello,  │ World    │     2 │
│ Hello,  │ World!   │     3 │
│ Hello   │ , World! │     2 │
└─────────┴──────────┴───────┘
```

Запрос:

``` sql
SELECT concat(key1, key2), sum(value) FROM key_val GROUP BY (key1, key2);
```

Результат:

``` text
┌─concat(key1, key2)─┬─sum(value)─┐
│ Hello, World!      │          3 │
│ Hello, World!      │          2 │
│ Hello, World       │          3 │
└────────────────────┴────────────┘
```

## substring(s, offset, length), mid(s, offset, length), substr(s, offset, length) {#substring}

Возвращает подстроку, начиная с байта по индексу offset, длины length байт. Индексация символов — начиная с единицы (как в стандартном SQL). Аргументы offset и length должны быть константами.

## substringUTF8(s, offset, length) {#substringutf8}

Так же, как substring, но для кодовых точек Unicode. Работает при допущении, что строка содержит набор байтов, представляющий текст в кодировке UTF-8. Если допущение не выполнено, то возвращает какой-нибудь результат (не кидает исключение).

## appendTrailingCharIfAbsent(s, c) {#appendtrailingcharifabsent}

Если строка s непустая и не содержит символ c на конце, то добавляет символ c в конец.

## convertCharset(s, from, to) {#convertcharset}

Возвращает сконвертированную из кодировки from в кодировку to строку s.

## base64Encode(s) {#base64encode}

Производит кодирование строки s в base64-представление.

Синоним: `TO_BASE64`.

## base64Decode(s) {#base64decode}

Декодирует base64-представление s в исходную строку. При невозможности декодирования выбрасывает исключение

Синоним: `FROM_BASE64`.

## tryBase64Decode(s) {#trybase64decode}

Функционал аналогичен base64Decode, но при невозможности декодирования возвращает пустую строку.

## endsWith(s, suffix) {#endswith}

Возвращает 1, если строка завершается указанным суффиксом, и 0 в противном случае.

## startsWith(str, prefix) {#startswith}

Возвращает 1, если строка начинается указанным префиксом, в противном случае 0.

``` sql
SELECT startsWith('Spider-Man', 'Spi');
```

**Возвращаемые значения**

-   1, если строка начинается указанным префиксом.
-   0, если строка не начинается указанным префиксом.

**Пример**

Запрос:

``` sql
SELECT startsWith('Hello, world!', 'He');
```

Результат:

``` text
┌─startsWith('Hello, world!', 'He')─┐
│                                 1 │
└───────────────────────────────────┘
```

## trim {#trim}

Удаляет все указанные символы с начала или окончания строки.
По умолчанию удаляет все последовательные вхождения обычных пробелов (32 символ ASCII) с обоих концов строки.

**Синтаксис**

``` sql
trim([[LEADING|TRAILING|BOTH] trim_character FROM] input_string)
```

**Аргументы**

-   `trim_character` — один или несколько символов, подлежащие удалению. [String](../../sql-reference/functions/string-functions.md).
-   `input_string` — строка для обрезки. [String](../../sql-reference/functions/string-functions.md).

**Возвращаемое значение**

Исходную строку после обрезки с левого и (или) правого концов строки.

Тип: `String`.

**Пример**

Запрос:

``` sql
SELECT trim(BOTH ' ()' FROM '(   Hello, world!   )');
```

Результат:

``` text
┌─trim(BOTH ' ()' FROM '(   Hello, world!   )')─┐
│ Hello, world!                                 │
└───────────────────────────────────────────────┘
```

## trimLeft {#trimleft}

Удаляет все последовательные вхождения обычных пробелов (32 символ ASCII) с левого конца строки. Не удаляет другие виды пробелов (табуляция, пробел без разрыва и т. д.).

**Синтаксис**

``` sql
trimLeft(input_string)
```

Алиас: `ltrim(input_string)`.

**Аргументы**

-   `input_string` — строка для обрезки. [String](../../sql-reference/functions/string-functions.md).

**Возвращаемое значение**

Исходную строку без общих пробельных символов слева.

Тип: `String`.

**Пример**

Запрос:

``` sql
SELECT trimLeft('     Hello, world!     ');
```

Результат:

``` text
┌─trimLeft('     Hello, world!     ')─┐
│ Hello, world!                       │
└─────────────────────────────────────┘
```

## trimRight {#trimright}

Удаляет все последовательные вхождения обычных пробелов (32 символ ASCII) с правого конца строки. Не удаляет другие виды пробелов (табуляция, пробел без разрыва и т. д.).

**Синтаксис**

``` sql
trimRight(input_string)
```

Алиас: `rtrim(input_string)`.

**Аргументы**

-   `input_string` — строка для обрезки. [String](../../sql-reference/functions/string-functions.md).

**Возвращаемое значение**

Исходную строку без общих пробельных символов справа.

Тип: `String`.

**Пример**

Запрос:

``` sql
SELECT trimRight('     Hello, world!     ');
```

Результат:

``` text
┌─trimRight('     Hello, world!     ')─┐
│      Hello, world!                   │
└──────────────────────────────────────┘
```

## trimBoth {#trimboth}

Удаляет все последовательные вхождения обычных пробелов (32 символ ASCII) с обоих концов строки. Не удаляет другие виды пробелов (табуляция, пробел без разрыва и т. д.).

**Синтаксис**

``` sql
trimBoth(input_string)
```

Алиас: `trim(input_string)`.

**Аргументы**

-   `input_string` — строка для обрезки. [String](../../sql-reference/functions/string-functions.md).

**Возвращаемое значение**

Исходную строку без общих пробельных символов с обоих концов строки.

Тип: `String`.

**Пример**

Запрос:

``` sql
SELECT trimBoth('     Hello, world!     ');
```

Результат:

``` text
┌─trimBoth('     Hello, world!     ')─┐
│ Hello, world!                       │
└─────────────────────────────────────┘
```

## CRC32(s) {#crc32}

Возвращает чексумму CRC32 данной строки, используется CRC-32-IEEE 802.3 многочлен и начальным значением `0xffffffff` (т.к. используется реализация из zlib).

Тип результата — UInt32.

## CRC32IEEE(s) {#crc32ieee}

Возвращает чексумму CRC32 данной строки, используется CRC-32-IEEE 802.3 многочлен.

Тип результата — UInt32.

## CRC64(s) {#crc64}

Возвращает чексумму CRC64 данной строки, используется CRC-64-ECMA многочлен.

Тип результата — UInt64.

## normalizeQuery {#normalized-query}

Заменяет литералы, последовательности литералов и сложные псевдонимы заполнителями.

**Синтаксис**

``` sql
normalizeQuery(x)
```

**Аргументы** 

-   `x` — последовательность символов. [String](../../sql-reference/data-types/string.md).

**Возвращаемое значение**

-   Последовательность символов с заполнителями.

Тип: [String](../../sql-reference/data-types/string.md).

**Пример**

Запрос:

``` sql
SELECT normalizeQuery('[1, 2, 3, x]') AS query;
```

Результат:

``` text
┌─query────┐
│ [?.., x] │
└──────────┘
```

## normalizedQueryHash {#normalized-query-hash}

Возвращает идентичные 64-битные хэш - суммы без значений литералов для аналогичных запросов. Это помогает анализировать журнал запросов.

**Синтаксис** 

``` sql
normalizedQueryHash(x)
```

**Аргументы** 

-   `x` — последовательность символов. [String](../../sql-reference/data-types/string.md).

**Возвращаемое значение**

-   Хэш-сумма.

Тип: [UInt64](../../sql-reference/data-types/int-uint.md#uint-ranges).

**Пример**

Запрос:

``` sql
SELECT normalizedQueryHash('SELECT 1 AS `xyz`') != normalizedQueryHash('SELECT 1 AS `abc`') AS res;
```

Результат:

``` text
┌─res─┐
│   1 │
└─────┘
```

## encodeXMLComponent {#encode-xml-component}

Экранирует символы для размещения строки в текстовом узле или атрибуте XML.

Экранируются символы, которые в формате XML являются зарезервированными (служебными): `<`, `&`, `>`, `"`, `'`.

**Синтаксис** 

``` sql
encodeXMLComponent(x)
```

**Аргументы** 

-   `x` — последовательность символов. [String](../../sql-reference/data-types/string.md).

**Возвращаемое значение**

-   Строка, в которой зарезервированные символы экранированы.

Тип: [String](../../sql-reference/data-types/string.md).

**Пример**

Запрос:

``` sql
SELECT encodeXMLComponent('Hello, "world"!');
SELECT encodeXMLComponent('<123>');
SELECT encodeXMLComponent('&clickhouse');
SELECT encodeXMLComponent('\'foo\'');
```

Результат:

``` text
Hello, &quot;world&quot;!
&lt;123&gt;
&amp;clickhouse
&apos;foo&apos;
```

## decodeXMLComponent {#decode-xml-component}

Заменяет символами предопределенные мнемоники XML: `&quot;` `&amp;` `&apos;` `&gt;` `&lt;`
Также эта функция заменяет числовые ссылки соответствующими символами юникод. Поддерживаются десятичная (например, `&#10003;`) и шестнадцатеричная (`&#x2713;`) формы.

**Синтаксис**

``` sql
decodeXMLComponent(x)
```

**Аргументы**

-   `x` — последовательность символов. [String](../../sql-reference/data-types/string.md).

**Возвращаемое значение**

-   Строка с произведенными заменами.

Тип: [String](../../sql-reference/data-types/string.md).

**Пример**

Запрос:

``` sql
SELECT decodeXMLComponent('&apos;foo&apos;');
SELECT decodeXMLComponent('&lt; &#x3A3; &gt;');
```

Результат:

``` text
'foo' 
< Σ >
```

**Смотрите также**

-   [Мнемоники в HTML](https://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%B5%D0%BC%D0%BE%D0%BD%D0%B8%D0%BA%D0%B8_%D0%B2_HTML)

