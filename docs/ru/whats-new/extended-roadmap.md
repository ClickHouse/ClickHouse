# Планы разработки ClickHouse 2020 {#plany-razrabotki-clickhouse-2020}

Здесь собраны важные задачи на 2020 год. Многие из них присутствуют в GitHub Issues. Данный текст следует рассматривать как рабочий черновик со сводкой и кратким описанием задач, ссылками и материалами для быстрого доступа на одной странице. Классификация задач условная.

Так как ClickHouse - open-source продукт, мы хотим, чтобы рабочий процесс был также максимально открытым. В связи с этим, вам следует ожидать наличия на данной странице несколько большего количества деталей описания рабочего процесса, чем вы могли бы предположить - настолько близко, насколько рабочий процесс видят разработчики. Так как неотъемлимой частью процесса разработки является исправление недостатков продукта и улучшение качества кода, на данной странице вы найдёте весьма подробные описания таких деталей. Для других open-source продуктов такой подход к разработке обычно нехарактерен. Благодаря тому, что для каждой задачи указаны её зависимости, вы сможете понять, какие подготовительные работы требуются, что позволяет более точно понимать сроки реализации.

## 1. Хранение данных, индексация {#khranenie-dannykh-indeksatsiia}

### 1.1. Индексы по z-Order curve, normalized z-Order curve {#indeksy-po-z-order-curve-normalized-z-order-curve}

[#6286](https://github.com/ClickHouse/ClickHouse/pull/6286)

Задача также относится к категории «17. Работа с географическими данными», так как geoHash - это частный случай z-Order curve.
Также связана с задачей 24.27 для нечёткого поиска полудубликатов строк, так как позволит индексировать min-hash.
Задача «normalized z-Order curve» в перспективе может быть полезна для БК и Метрики, так как позволяет смешивать OrderID и PageID и избежать дублирования данных.
В задаче также вводится способ индексации путём обращения функции нескольких аргументов на интервале, что имеет смысл для дальнейшего развития.

### 1.2. + Wait-free каталог баз данных {#wait-free-katalog-baz-dannykh}

Q2. Делает [Александр Токмаков](https://github.com/tavplubix), первый рабочий вариант в декабре 2019. Нужно для DataLens и Яндекс.Метрики.

Манипуляции с каталогом баз данных: запросы CREATE TABLE, DROP TABLE, RENAME TABLE и DATABASE, требуют синхронизации с помощью блокировок. Эта синхронизация становится весьма сложной, так как на неё полагается много внутренних структур данных.

Предлагается реализовать альтернативный подход, в котором таблицы и базы данных являются всего лишь ссылками на persistent объекты. Подробное описание задачи: [#6787](https://github.com/ClickHouse/ClickHouse/issues/6787)

Upd. Сделана крупная часть задачи, но ориентироваться стоит уже на Q2.
Upd. Pull request готов для мержа.
Upd. Попало 20.4. Доступно под флагом allow_experimental_database_atomic.

### 1.3. + Неблокирующие ALTER {#neblokiruiushchie-alter}

Q1. И полностью immutable куски. Делает [Александр Сапин](https://github.com/alesapin). Готов приступить к задаче в конце ноября 2019. Нужно для Яндекс.Метрики.

Upd. Большая часть задачи реализована и добавлена в master. Есть незначительные технические долги. Остаётся реализация неблокирующего изменения метаданных таблицы.
Upd. Всё доделано, ожидается в релизе 20.6.

### 1.4. + Нетранзитивные ALTER столбцов {#netranzitivnye-alter-stolbtsov}

Требует 1.3. Будет делать [Александр Сапин](https://github.com/alesapin). Ура, сделано.

### 1.5. + ALTER RENAME COLUMN {#alter-rename-column}

[#6861](https://github.com/ClickHouse/ClickHouse/issues/6861)

Требует 1.3. Будет делать [Александр Сапин](https://github.com/alesapin).

### 1.6. + Полиморфные куски данных {#polimorfnye-kuski-dannykh}

Компактные куски - Q1, куски в оперативке Q1/Q2 - пункт 1.7.

Компактные куски реализованы, ещё не включены по-умолчанию. Первым шагом включаем по-умолчанию для системных таблиц.

Upd. Включено для системных таблиц.

Делает [Антон Попов](https://github.com/CurtizJ), первый рабочий вариант в декабре. Пререквизит чтобы снизить сложность мелких INSERT, что в свою очередь нужно для 1.12, иначе задача 1.12 не сможет нормально работать. Особенно нужно для Яндекс.Облака.

Данные в таблицах типа MergeTree в ClickHouse хранятся в виде набора независимых «кусков». Внутри куска, каждый столбец, а также индекс, хранится в отдельных файлах. Это сделано для возможности быстрых манипуляций со столбцами (пример - запрос ALTER DROP COLUMN). При вставке данных (INSERT), создаётся новый кусок. Для таблиц с большим количеством столбцов, запросы INSERT с маленьким количеством строк являются неэффективными, так как требуют создания большого количества файлов в файловой системе. Это является врождённой особенностью ClickHouse - одной из первой проблем, с которыми сталкиваются пользователи. Пользователям приходится буферизовывать данные и собирать их в более крупные пачки перед вставкой в ClickHouse.

Для смягчения эффекта от этой проблемы, в ClickHouse существуют таблицы типа Buffer. Они накапливают данные в оперативке перед записью в другую таблицу. Впрочем, таблицы Buffer не являются полноценным решением проблемы из-за: - наличия блокировок при вставке; - переупорядочивание вставляемых данных; - неатомарность перекладывания данных из Buffer в результирующую таблицу.

Вместо этого предлагается разрешить кускам таблиц типа MergeTree располагать данные в разных форматах. А именно: - в оперативной памяти; - на диске со всеми столбцами в одном файле; - на диске со столбцами в отдельных файлах: в зависимости от размера куска и прошедшего времени. Для размещения кусков в оперативной памяти, придётся также реализовать опциональную поддержку write-ahead log с настраиваемыми правилами по сбросу на диск. Это позволит избавиться от проблем с мелкими вставками для MergeTree таблиц. Для ReplicatedMergeTree таблиц, это решит проблему лишь частично.

### 1.7. + Буферизация и WAL в MergeTree {#buferizatsiia-i-wal-v-mergetree}

Требует 1.6. Антон Попов. Задача взята в работу. Q2.
Есть pull request.
Upd. В стадии код-ревью.
Upd. Готово для использования начиная с версии 20.6 в экспериментальном режиме.

### 1.8. + Перенос между разделами по TTL {#perenos-mezhdu-razdelami-po-ttl}

Делает [Владимир Чеботарёв](https://github.com/excitoon), Altinity. Декабрь 2019.

Q1. Закоммичено, но есть технический долг, который исправляется сейчас.
Готово. Нет, не готово - там всё ещё технический долг.

### 1.9. + Использование TTL для прореживания данных {#ispolzovanie-ttl-dlia-prorezhivaniia-dannykh}

Будет делать Сорокин Николай, ВШЭ и Яндекс.
Upd. Есть pull request. Upd. Сделано.

Сейчас пользователь может задать в таблице выражение, которое определяет, сколько времени хранятся данные. Обычно это выражение задаётся относительно значения столбца с датой - например: удалять данные через три месяца. https://clickhouse.tech/docs/ru/operations/table_engines/mergetree/#table_engine-mergetree-ttl

Это может быть задано для всей таблицы (тогда строки целиком удаляются после указанного времени) или для отдельных столбцов (тогда данные столбца физически удаляются с диска, а строки в таблице остаются; при чтении значений столбца, они читаются как значения по-умолчанию).

Но пользователи также хотят более продвинутый вариант этой функциональности: не удалять строки или столбцы целиком, а прореживать их - оставлять меньшее количество строк.

И тут есть несколько вариантов:
1. По прошествии времени, оставлять каждую N-ую строку.
2. По прошествии времени, выполнять агрегацию данных, заменяя значения некоторых столбцов на значения агрегатных функций от множества значений в нескольких строках.

Пункт 1 не представляет интереса, так как уже реализован с помощью TTL выражений для удаления данных. В качестве этого выражения можно прописать, например, `cityHash64(*) % 10 = 0 ? now() : event_time + INTERVAL 3 MONTH`. Правда как-то неудобно получается.

А вот пункт 2 требуется продумать. Не очевидно даже, какой лучше использовать синтаксис для этого при создании таблицы. Но мы придумаем - сразу видно несколько вариантов.

Частный случай такой задачи уже есть в https://clickhouse.tech/docs/ru/operations/table_engines/graphitemergetree/ Но это было сделано для конкретной задачи. А надо обобщить.

### 1.10. + Пережатие старых данных в фоне {#perezhatie-starykh-dannykh-v-fone}

В master, сделал Александр Сапин, https://github.com/ClickHouse/ClickHouse/pull/14494

Будет делать Кирилл Барухов, ВШЭ, экспериментальная реализация к весне 2020. Нужно для Яндекс.Метрики.

Алгоритмы сжатия типа LZ77 позволяют потратить больше времени на сжатие данных, чтобы сжать данные сильнее, но при этом без проигрыша по скорости разжатия данных. В частности, этим свойством обладает LZ4 и ZSTD, которые используются в ClickHouse. Это позволяет использовать свободные ресурсы CPU, когда сервер не нагружен, для пережатия данных, чтобы данные занимали меньше места на дисках, и при этом сохранить или даже улучшить скорость обработки запросов.

В то же время, ClickHouse обычно используется для «импульсного» сценария нагрузки. Запрос от пользователя обрабатывается максимально быстро, используя все ресурсы CPU, но в среднем по времени, сервер недостаточно нагружен.

Предлагается добавить в ClickHouse настройки по пережатию данных и фоновые потоки, выполняющие эту задачу.

Upd. Представлен прототип неизвестной степени готовности.

### 1.11. + Виртуальная файловая система {#virtualnaia-failovaia-sistema}

На VFS переведены Log, TinyLog, StripeLog, а также MergeTree, что доказывает состоятельность реализации.

Нужно для Яндекс.Облака. Делает Александр, Яндекс.Облако.

ClickHouse использует для хранения данных локальную файловую систему. Существует сценарий работы, в котором размещение старых (архивных) данных было бы выгодно на удалённой файловой системе. Если файловая система POSIX совместимая, то это не составляет проблем: ClickHouse успешно работает с Ceph, GlusterFS, MooseFS. Также востребованным является сценарий использования S3 (из-за доступности в облаке) или HDFS (для интеграции с Hadoop). Но эти файловые системы не являются POSIX совместимыми. Хотя для них существуют FUSE драйверы, но скорость работы сильно страдает и поддержка неполная.

ClickHouse использует небольшое подмножество функций ФС, но в то же время, и некоторые специфические части: симлинки и хардлинки, O_DIRECT. Предлагается выделить всё взаимодействие с файловой системой в отдельный интерфейс.

### 1.12. Экспериментальная реализация VFS поверх S3 и HDFS {#eksperimentalnaia-realizatsiia-vfs-poverkh-s3-i-hdfs}

Q4.

Нужно для Яндекс.Облака. Требует 1.11. Желательно 1.6 и 1.18.
Делает Александр, Яндекс.Облако (сначала часть для S3), а также Олег Ершов, ВШЭ и Яндекс.

Upd. Олег будет делать только часть про HDFS.
Upd. Реализация поверх S3 является рабочей на уровне PoC.
Upd. Реализация поверх S3 ужасно тормозит и сейчас доделывается.
Upd. Реализацию поверх HDFS взял AmosBird для Kuaishou.

### 1.13. + Ускорение запросов с FINAL {#uskorenie-zaprosov-s-final}

Требует 2.1. Делает [Николай Кочетов](https://github.com/KochetovNicolai). Нужно для Яндекс.Метрики. Q2.
Upd: PR [#10463](https://github.com/ClickHouse/ClickHouse/pull/10463)

### 1.14. Не писать столбцы, полностью состоящие из нулей {#ne-pisat-stolbtsy-polnostiu-sostoiashchie-iz-nulei}

Антон Попов. Q4.
В очереди. Простая задача, является небольшим пререквизитом для потенциальной поддержки полуструктурированных данных.
Upd. В очереди после чтения срезов столбцов.

### 1.15. Возможность иметь разный первичный ключ в разных кусках {#vozmozhnost-imet-raznyi-pervichnyi-kliuch-v-raznykh-kuskakh}

Сложная задача, только после 1.3.
Upd. В обсуждении.
Upd. Взял в работу Amos Bird. Описана концепция. Совпадает с 1.16.

### 1.16. Несколько физических представлений для одного куска данных {#neskolko-fizicheskikh-predstavlenii-dlia-odnogo-kuska-dannykh}

Сложная задача, только после 1.3 и 1.6. Позволяет компенсировать 21.20.
Upd. В обсуждении.
Upd. Взял в работу Amos Bird. Описана концепция, работа на начальной стадии.

### 1.17. Несколько сортировок для одной таблицы {#neskolko-sortirovok-dlia-odnoi-tablitsy}

Сложная задача, только после 1.3 и 1.6.
Upd. В обсуждении.
Upd. Взял в работу Amos Bird. Описана концепция. Совпадает с 1.16.

### 1.18. - Отдельное хранение файлов кусков {#otdelnoe-khranenie-failov-kuskov}

Требует 1.3 и 1.6. Полная замена hard links на sym links, что будет лучше для 1.12.
Отменено.


## 2. Крупные рефакторинги {#krupnye-refaktoringi}

Для обоснования необходимости смотрите ссылки в описании других задач.

### 2.1. + Переделка конвейера выполнения запросов на Processors {#peredelka-konveiera-vypolneniia-zaprosov-na-processors}

Делает [Николай Кочетов](https://github.com/KochetovNicolai). Финальная стадия разработки. Включение по-умолчанию в конце декабря 2019. Удаление старого кода в начале 2020.

Upd. На данный момент исправляются проблемы с регрессиями производительности в отдельных случаях. Кажется, что все проблемы исправлены.
Включение по-умолчанию в Q1, но остаётся вторая часть задачи по корректному выделению async части.

Upd. Включили по-умолчанию. Удаление старого кода не раньше, чем после первого релиза, в котором это включено по-умолчанию и всё ещё можно выключить обратно.

Upd. Уже есть первый релиз, в котором это включено по-умолчанию.

Upd. Всё ещё ждём удаление старого кода, которое должно случиться после релиза 20.4.

Upd. Старый код по большей части удалён.

### 2.2. Инфраструктура событий/метрик/ограничений/квот/трассировки {#infrastruktura-sobytiimetrikogranicheniikvottrassirovki}

В очереди. https://gist.github.com/alexey-milovidov/d62d73222d83b9319dc519cbb13aeff6

### 2.3. Перенос столбцового ser/de из DataType в Column {#perenos-stolbtsovogo-serde-iz-datatype-v-column}

В очереди. Антон Попов.

### 2.4. Перевод LowCardinality из DataType в Column. Добавление ColumnSparse {#perevod-lowcardinality-iz-datatype-v-column-dobavlenie-columnsparse}

Требует 2.3.

### 2.5. Версионирование состояний агрегатных функций {#versionirovanie-sostoianii-agregatnykh-funktsii}

В очереди. Описана схема реализации. Алексей Миловидов.

### 2.6. Правая часть IN как тип данных. Выполнение IN в виде скалярного подзапроса {#pravaia-chast-in-kak-tip-dannykh-vypolnenie-in-v-vide-skaliarnogo-podzaprosa}

Требует 2.1.
Отменено.

### 2.7. + Нормализация Context {#normalizatsiia-context}

В очереди. Нужно для YQL.

Александр Токмаков исправил множество проблем с использованием Context и сейчас переносит каталог БД наружу.

Upd. Каталог БД вынесен из Context.
Upd. SharedContext вынесен из Context.
Upd. Проблема нейтрализована и перестала быть актуальной.
Upd. Вообще всё стало Ок.

### 2.8. Декларативный парсер запросов {#deklarativnyi-parser-zaprosov}

Средний приоритет. Нужно для YQL.

Upd. В очереди. Иван Лежанкин.
Upd. Задача в финальной стадии. Пока рассматривается только как альтернативный парсер, описание которого подойдёт для сторонних приложений.

### 2.9. + Логгировние в format-стиле {#loggirovnie-v-format-stile}

[#6049](https://github.com/ClickHouse/ClickHouse/issues/6049#issuecomment-570836998)

Сделано.

### 2.10. Запрашивать у таблиц не столбцы, а срезы {#zaprashivat-u-tablits-ne-stolbtsy-a-srezy}

В очереди.
В работе, Антон Попов, Q4.

### 2.11. - Разбирательство и нормализация функциональности для bitmap {#razbiratelstvo-i-normalizatsiia-funktsionalnosti-dlia-bitmap}

В очереди.
Не актуально.

### 2.12. Декларативные сигнатуры функций {#deklarativnye-signatury-funktsii}

[#3775](https://github.com/ClickHouse/ClickHouse/pull/3775)

Задачу делает Алексей Миловидов. Прогресс 50% и разработка временно приостановлена.

Upd. Разработка всё ещё приостановлена.

### 2.13. Каждая функция в отдельном файле {#kazhdaia-funktsiia-v-otdelnom-faile}

Задачу делает Алексей Миловидов. Прогресс 80%. Потребуется помощь других разработчиков.

Upd. Поползновения наблюдаются.

### 2.14. Все функции с состоянием переделать на FunctionBuilder {#vse-funktsii-s-sostoianiem-peredelat-na-functionbuilder}

Долг [Николай Кочетов](https://github.com/KochetovNicolai). Сейчас код находится в переходном состоянии, что неприемлемо.

### 2.15. Функция subscribe для IStorage {#funktsiia-subscribe-dlia-istorage}

Для нормализации работы materialized views поверх Merge, Distributed, Kafka.


## 3. Документация {#dokumentatsiia}

Здесь задачи только по инфраструктуре документации.

### 3.1. Перенос документации по функциям в код {#perenos-dokumentatsii-po-funktsiiam-v-kod}

Требует 2.12 и 2.13. Хотим в Q2, средний приоритет.

### 3.2. Перенос однородных частей документации в код {#perenos-odnorodnykh-chastei-dokumentatsii-v-kod}

Требует 3.1.

### 3.3. + Исправить катастрофически отвратительно неприемлемый поиск по документации {#ispravit-katastroficheski-otvratitelno-nepriemlemyi-poisk-po-dokumentatsii}

[Иван Блинков](https://github.com/blinkov/) - очень хороший человек. Сам сайт документации основан на технологиях, не удовлетворяющих требованиям задачи, и эти технологии трудно исправить. Задачу будет делать первый встретившийся нам frontend разработчик, которого мы сможем заставить это сделать.

Upd. Иван Блинков сделал эту задачу путём замены треш-технологий на нормальные.

### 3.4. + Добавить японский язык в документацию {#dobavit-iaponskii-iazyk-v-dokumentatsiiu}

Эту задачу сделает [Иван Блинков](https://github.com/blinkov/), до конца декабря 2019. Сделано.


## 4. Сетевое взаимодействие {#setevoe-vzaimodeistvie}

### 4.1. Уменьшение числа потоков при распределённых запросах {#umenshenie-chisla-potokov-pri-raspredelionnykh-zaprosakh}

Upd. Есть прототип. Upd. Он не работает. Upd. Человек отказался от задачи, теперь сроки не определены.
Upd. Павел Круглов, весна 2021.

### 4.2. Спекулятивное выполнение запросов на нескольких репликах {#spekuliativnoe-vypolnenie-zaprosov-na-neskolkikh-replikakh}

Нужно для Яндекс.Метрики. Требует 4.1.

Если распределённый запрос затрагивает большое количество серверов, то время выполнения запросов часто становится большим из-за tail latencies - случайных редких замедлений отдельных серверов. Эту проблему можно избежать, отправляя один и тот же запрос сразу на несколько реплик, и используя данные с наиболее быстрой.

Задача скрывает в себе много тонкостей, связанных с обработкой стадий выполнения запроса (соединение, обмен handshake, отправка запроса, получение заголовка результата, получение пакетов прогресса, получение данных), правильной возможностью настройки таймаутов, правильной отменой запросов.

Сейчас для распределённых запросов используется по потоку на соединение. Это позволяет хорошо распараллелить вычисления над полученными данными и утилизировать сеть, но становится сильно избыточным для больших кластеров. Для примера, создание 1000 потоков для чтения данных из 1000 серверов кластера - лишь расходует ресурсы и увеличивает время выполнения запроса. Вместо этого необходимо использовать количество потоков не большее количества процессорных ядер, и мультиплексировать в одном потоке общение с серверами. Реализация нетривиальна, так как мультиплексировать необходимо каждую стадию общения по сети, включая установку соединения и обмен handshake.

Upd. Сейчас обсуждается, как сделать другую задачу вместо этой.

Павел Круглов, весна 2021.

### 4.3. Ограничение числа одновременных скачиваний с реплик {#ogranichenie-chisla-odnovremennykh-skachivanii-s-replik}

Изначально делал Олег Алексеенков, но пока решение не готово, хотя там не так уж много доделывать.

### 4.4. Ограничение сетевой полосы при репликации {#ogranichenie-setevoi-polosy-pri-replikatsii}

Нужно для Метрики.

### 4.5. Возможность продолжить передачу куска данных при репликации после сбоя {#vozmozhnost-prodolzhit-peredachu-kuska-dannykh-pri-replikatsii-posle-sboia}

### 4.6. p2p передача для GLOBAL подзапросов {#p2p-peredacha-dlia-global-podzaprosov}

### 4.7. Ленивая загрузка множеств для IN и JOIN с помощью k/v запросов {#lenivaia-zagruzka-mnozhestv-dlia-in-i-join-s-pomoshchiu-kv-zaprosov}

### 4.8. + Разделить background pool для fetch и merge {#razdelit-background-pool-dlia-fetch-i-merge}

Исправить проблему, что восстанавливающаяся реплика перестаёт мержить. Частично компенсируется 4.3.
Ура, готово! Сделал Александр Сапин.


## 5. Операции {#operatsii}

### 5.1. + Разделение задач на более мелкие куски в clickhouse-copier {#razdelenie-zadach-na-bolee-melkie-kuski-v-clickhouse-copier}

[#9075](https://github.com/ClickHouse/ClickHouse/pull/9075)
Q1. Нужно для Метрики, в очереди. Никита Михайлов.

Upd. Задача на финальной стадии разработки.
Upd. Сделано. Эффективность работы под вопросом. Есть варианты, как сделать лучше.

### 5.2. + Автонастройка лимита на оперативку и размера кэшей {#avtonastroika-limita-na-operativku-i-razmera-keshei}

### 5.3. + Встроенная ручка для Prometheus {#vstroennaia-ruchka-dlia-prometheus}

Сделано. https://github.com/Vdimir

### 5.4. Opt-in сообщать в клиенте, если вышла новая версия {#opt-in-soobshchat-v-kliente-esli-vyshla-novaia-versiia}

Есть поползновения.

### 5.5. + LTS релизы {#lts-relizy}

Требует 7.5. Задачу хочет Метрика, Облако, БК, Маркет и Altinity. Первой LTS версией уже стала версия 19.14.
Метрика, БК, Маркет, Altinity уже используют более свежие версии чем LTS.
Upd. Появилась вторая версия LTS - 20.3.


## 6. Инструментирование {#instrumentirovanie}

### 6.1. + Исправления сэмплирующего профайлера запросов {#ispravleniia-sempliruiushchego-profailera-zaprosov}

Михаил Филимонов, Altinity. Ноябрь 2019. Сделано.
Осталось ещё проверить работоспособность профайлера в первом потоке (что важно для INSERT). Иван Лежанкин. Q1. Сделано.

### 6.2. + Добавление memory profiler {#dobavlenie-memory-profiler}

[#6387](https://github.com/ClickHouse/ClickHouse/issues/6387)

Сравнительно простая задача, но только для опытных разработчиков. Нужна всем. Иван Лежанкин. Q1. Сделано.

### 6.3. + Учёт оперативки total расширить не только на запросы {#uchiot-operativki-total-rasshirit-ne-tolko-na-zaprosy}

Исправление долгоживущей проблемы с дрифтом учёта оперативки. Нужна для Метрики и БК.

### 6.4. + Поддержка perf events как метрик запроса {#podderzhka-perf-events-kak-metrik-zaprosa}

Делает Андрей Скобцов, ВШЭ.

В Linux существует возможность получать в программе информацию о счётчиках производительности и событиях, относящихся к CPU и ядру ОС. Подробнее смотрите `man perf_event_open`. Предлагается добавить эти метрики в ClickHouse для инструментирования запросов.

Есть прототип. 
Сделано.

### 6.5. Эксперименты с LLVM X-Ray {#eksperimenty-s-llvm-x-ray}

Требует 2.2.
Перенос на 2021 или отмена.

### 6.6. + Стек трейс для любых исключений {#stek-treis-dlia-liubykh-iskliuchenii}

Сейчас есть стек трейс для почти всех, но не всех исключений. Требует 7.4.

### 6.7. + Таблица system.stack_trace {#tablitsa-system-stack-trace}

Сравнительно простая задача, но только для опытных разработчиков.

### 6.8. + Таблица system.crashes {#tablitsa-system-crashes}

Сравнительно простая задача, но только для опытных разработчиков.
Upd. В разработке.

### 6.9. + Отправлять информацию клиенту, если сервер падает по сигналу {#otpravliat-informatsiiu-klientu-esli-server-padaet-po-signalu}

Сделано.

### 6.10. Сбор общих системных метрик {#sbor-obshchikh-sistemnykh-metrik}

Перенос на весну 2021.


## 7. Сопровождение разработки {#soprovozhdenie-razrabotki}

### 7.1. + ICU в submodules {#icu-v-submodules}

Добавление в submodules также нужно для Аркадии (7.26).

### 7.2. + LLVM в submodules {#llvm-v-submodules}

Сделал Алексей Миловидов.

### 7.3. + Обновление Poco {#obnovlenie-poco}

Алексанр Кузьменков.

### 7.4. + Включить libc++, libc++-abi при сборке с gcc {#vkliuchit-libc-libc-abi-pri-sborke-s-gcc}

Сейчас включено только при сборке с clang, но продакшен сборка использует gcc.
Требует 7.2 и, возможно, 7.1 (только в случае новой версии ICU).

### 7.5. + Начать публиковать LTS релизы {#nachat-publikovat-lts-relizy}

[Александр Сапин](https://github.com/alesapin).

### 7.6. + Правильный статистический тест для comparison mode в clickhouse-performance-test {#pravilnyi-statisticheskii-test-dlia-comparison-mode-v-clickhouse-performance-test}

Задачу начал делать Дмитрий Рубашкин (ВШЭ). Сейчас продолжает [Александр Кузьменков](https://github.com/akuzm). Сделано, работает в CI. Долгое время не были определены надёжные критерии для результата теста. Сейчас проблема решена, но остались не решёнными некоторые вопросы.

### 7.7. + Доделать тесты под MSan {#dodelat-testy-pod-msan}

Уже есть ASan, TSan, UBSan. Не хватает тестов под MSan. Они уже добавлены в CI, но не проходят.
[Александр Кузьменков](https://github.com/akuzm) и [Александр Токмаков](https://github.com/tavplubix).

Upd. Задача всё ещё медленно тащится.
Upd. Доделал Алексей Миловидов.

### 7.8. + Добавить clang-tidy {#dobavit-clang-tidy}

Уже есть PVS-Studio. Мы очень довольны, но этого недостаточно.

Upd. Алексей Миловидов. Добавлено некоторое множество проверок, но нужно рассмотреть все проверки подряд и добавить всё, что можно.
Upd. Рассмотрели все проверки подряд.

### 7.9. + Проверки на стиль имён с помощью clang-tidy {#proverki-na-stil-imion-s-pomoshchiu-clang-tidy}

Сделано. Только в .cpp файлах и только для имён локальных переменных. Остальное слишком сложно.

### 7.10. Включение UBSan и MSan в интеграционных тестах {#vkliuchenie-ubsan-i-msan-v-integratsionnykh-testakh}

UBSan включен в функциональных тестах, но не включен в интеграционных тестах. Требует 7.7.

### 7.11. + Включение \*San в unit тестах {#vkliuchenie-san-v-unit-testakh}

У нас мало unit тестов по сравнению с функциональными тестами и их использование не обязательно. Но они всё-равно важны и нет причин не запускать их под всеми видами sanitizers.

Илья Яцишин. Сделано.

### 7.12. Показывать тестовое покрытие нового кода в PR {#pokazyvat-testovoe-pokrytie-novogo-koda-v-pr}

Пока есть просто показ тестового покрытия всего кода.
Отложено на весну 2021.

### 7.13. + Включение аналога -Weverything в gcc {#vkliuchenie-analoga-weverything-v-gcc}

Мы используем -Wall -Wextra -Weverything -Werror.
При сборке с clang, -Weverything уже включено. Но в gcc есть уникальные warning-и, отсутствующие в clang.
Сделал Wolf Kreuzerkrieg.

### 7.14. + Альтернатива для readline и libedit {#alternativa-dlia-readline-i-libedit}

Подключение replxx вместо readline сделал Иван Лежанкин.

Есть технический долг с лицензиями файлов консорциума Unicode.
Есть технический долг с работой \G в multiline режиме.

### 7.14.1. + Улучшение возможностей интерактивного режима clickhouse-client {#uluchshenie-vozmozhnostei-interaktivnogo-rezhima-clickhouse-client}

Тагир Кускаров, ВШЭ.

Upd. В рамках данной задачи добавляем подстветку синтаксиса и исправление проблем со вставкой больших запросов.
Upd. Минимальная подсветка добавлена, а все остальные задачи не сделаны.

Для ввода запросов в интерактивном режиме в клиенте командной строки clickhouse-client использовалась библиотека readline или libedit.

Библиотеки readline и libedit обладает следующими недостатками:
- (исправлено в новых версиях readline) Очень низкая производительность вставки больших кусков текста. Вставка каждого следующего символа имеет сложность O(n = количество предыдущих символов) и при вставке 1 МБ текста, скорость падает до десятков байт в секунду.
- Крайне сложно или невозможно реализовать подсветку синтаксиса по мере набора текста, а также autocomplete без нажатия дополнительных клавиш для вызова.
- Лицензия GPL (для readline) препятствует её включению в кодовую базу продукта.
- Плохо работает навигация по истории, если история вкючает запросы, не помещающиеся на экран.
- История сохраняется лишь при завершении работы клиента.
- При параллельной работе нескольких клиентов с одним файлом истории, сохраняется история только одного из клиентов.
- Плохо работает история для многострочных запросов.
- Излишняя экономия пересылаемых данных, что часто приводит к остаткам мусора в терминале.

Кроме того, имеются следующие сложно достижимые достоинства:
- Поддержка right-to-left текста;
- Поддержка editrc конфигураций.

В качестве альтернатив можно рассмотреть следующие варианты:
- Linenoise от Salvatore Sanfilippo. Достоинства: простота и компактность кода; высокая скорость работы. Недостатки: отсутствует поддержка Unicode; отсутствует автоматический перенос текста, что затрудняет работу с многострочными запросами.
- Linenoise с патчами для поддержки Unicode. Недостаток: теряется преимущество по скорости работы.
- Fish shell. Не является библиотекой, но представляет собой отличный пример, как можно реализовать подстветку синтаксиса и удобный autocomplete. Поддерживает Unicode, но работает весьма медленно.
- Python Prompt Toolkit. Не является подходящим решением для интеграции в C++ проект. Хорошие возможности по подсветке синтаксиса и autocomplete.

Вместо этого предлагается в качестве примера изучить прототип текстового редактора Kilo: https://viewsourcecode.org/snaptoken/kilo/ и реализовать всю необходимую функциональность.

### 7.15. + Замена libressl обратно на openssl {#zamena-libressl-obratno-na-openssl}

Поводом использования libressl послужило желание нашего хорошего друга из известной компании несколько лет назад. Но сейчас ситуация состоит в том, что openssl продолжает развиваться, а libressl не особо, и можно спокойно менять обратно.

Нужно для Яндекс.Облака для поддержки TLS 1.3.
Теперь нужно заменить OpenSSL на BoringSSL.

### 7.16. + tzdata внутри бинарника {#tzdata-vnutri-binarnika}

Как в Аркадии, fallback на системные.

### 7.17. + Доделать tgz пакеты {#dodelat-tgz-pakety}

Уже давно собираются универсальные tgz пакеты, но по нелепой случайности из них исчез install скрипт.
[Александр Сапин](https://github.com/alesapin). Может делегировать эту задачу кому угодно.
Upd. Сделано всё кроме инструкции на сайте. Для этого требуется создать директории testing/stable/prestable на repo.yandex.ru. Внезапно оказалось, что человек, отвечающий за это, в отпуске, и он не отвечает на вопрос, кто его заместитель. Q1.

### 7.18. + Доделать бинарники под Mac {#dodelat-binarniki-pod-mac}

Уже есть автосборка бинарников под Mac на каждый коммит и PR, но с недостатками.
[Иван Лежанкин](https://github.com/abyss7). Требует 7.1, 7.2. Рекомендуется 7.14. Сейчас не хватает по крайней мере SSL и ICU. Нужно для Яндекс.Облака.
Upd. Сделано SSL. Ориентируемся в Q1, но приоритет средний и может потеряться.

### 7.18.1. Поместить ссылку на собранные бинарники под Mac на сайт {#pomestit-ssylku-na-sobrannye-binarniki-pod-mac-na-sait}

Сейчас людям приходится делать несколько кликов, чтобы их скачать.
[Александр Сапин](https://github.com/alesapin).
Upd. Добавлены прямые ссылки и инструкция в документации. Но всё ещё нет инструкции на главной странице сайта.

### 7.19. + Доделать (проверить) автосборку под AArch64 {#dodelat-proverit-avtosborku-pod-aarch64}

https://github.com/ClickHouse/ClickHouse/issues/8027#issuecomment-566670282
Проверили на настоящем сервере Huawei, а также в специальном Docker контейнере, который содержит внутри qemu-user-static.
Также можно проверить на Cavium, на Raspberry Pi а также на твоём Android телефоне.

### 7.20. + Автосборка для FreeBSD x86_64 {#avtosborka-dlia-freebsd-x86-64}

[Иван Лежанкин](https://github.com/abyss7).

Upd. В процессе реализации, есть pull request.
Upd. Есть сборки, [пример](https://clickhouse-builds.s3.yandex.net/0/2cb4c91c0286b774534fcbe80e5ef8835a74a83a/report.html)
Всё ещё нет инструкции на сайте!

### 7.21. Автосборка для Linux ppc64 {#avtosborka-dlia-linux-ppc64}

[Иван Лежанкин](https://github.com/abyss7).
Как-то медленно тащится.
Как-то вообще не тащится. Также договорились, что сделаем ещё автосборку для MIPS64.

### 7.22. + Дэшборд для pull requests {#deshbord-dlia-pull-requests}

Дарья Петрова, УрФУ.

Рабочий прототип: https://pulls-dashboard-demo.herokuapp.com/dashboard/ClickHouse/ClickHouse
Upd. Мы пользуемся этим инструментом в ежедневной работе.

Над ClickHouse одновременно работает большое количество разработчиков, которые оформляют свои изменения в виде pull requests. Когда непомерженных pull requests много, то возникает сложность с организацией работы - непонятно, на какой pull request смотреть в первую очередь.

Предлагается реализовать простое одностраничное веб-приложение, в котором отображается список pull requests со следующей информацией:
- размер diff - количество изменённых строк;
- как давно было последнее обновление;
- типы изменённых файлов: C++, документация, скрипты сборки;
- наличие добавленных тестов;
- есть ли описание для changelog;
- изменены ли submodules;
- был ли разрешён запуск проверок CI;
- статусы проверок CI;
- количество approve от ревьюеров;

Статусы проверок - наиболее важная часть. Так как для каждого PR выполняется несколько десятков проверок и наиболее медленные работают до нескольких часов, придётся:
- отображать сразу все проверки для каждого PR в виде красивой разноцветной матрицы с информацией по наведению мыши;
- отсортировать проверки по важности: например, если у внешнего разработчика проходят все проверки кроме стиля кода, то мы можем взять это в работу сами;
- если для предыдущего коммита проверка была завершена, а для последнего коммита ещё только идёт - то можно отображать в таблице статус предыдущей проверки более блёклым цветом.

Предлагается реализовать несколько вариантов сортировок. Очевидное - по времени обновления, более интересно - некое ранжирование с целью выяснить, «что лучше взять в работу прямо сейчас».

Похожие продукты уже есть, например: http://prs.mozilla.io/yandex:ClickHouse К сожалению, этот продукт заброшен, да и делает не совсем то, что нужно. По своему усмотрению, можно взять из него что-нибудь полезное.

### 7.23. + Функции для fuzzing {#funktsii-dlia-fuzzing}

Андрей Некрашевич, ВШЭ.

Fuzzing тестирование - это тестирование случайными данными. Мы рассмотрим несколько подходов к этой задачи:

1.  Добавление в SQL диалект ClickHouse функций для генерации случайных данных (пример - случайные бинарные строки заданной длины, случайные валидные UTF-8 строки) и «порчи» данных (например, поменять значения случайных бит с заданной частотой). Это будет использовано для тестирования SQL-функций ClickHouse.

Можно добавить функции:
`randomString(length)`
`randomFixedString(length)`
- строка заданной длины с равномерно распределёнными случайными байтами;
`randomStringASCII(length)`
`randomStringUTF8(length)`

`fuzzBits(s, inverse_probability)` - изменить каждый бит строки на противоположный с заданной вероятностью;
`fuzzBytes(s, inverse_probability)` - изменить каждый байт строки на равномерно случайный с заданной вероятностью;

У каждой функции опциональный аргумент против склейки одинаковых выражений в запросе.

Также можно сделать функции с детерминированным генератором случайных чисел (аргументом передаётся seed) для воспроизводимости тестовых кейсов.

Upd. Сергей Штыков сделал функцию `randomPrintableASCII`.
Upd. Илья Яцишин сделал табличную функцию `generateRandom`.
Upd. Эльдар Заитов добавляет OSS Fuzz.
Upd. Сделаны randomString, randomFixedString.
Upd. Сделаны fuzzBits.

### 7.24. + Fuzzing лексера и парсера запросов; кодеков и форматов {#fuzzing-leksera-i-parsera-zaprosov-kodekov-i-formatov}

Продолжение 7.23.

1.  Использование AFL или LibFuzzer для тестирования отдельных частей кодовой базы ClickHouse.

2.  Генерация и выполнение случайных синтаксически корректных запросов на случайных данных.

Upd. Александр Кузьменков сделал фазер запросов на основе мутаций AST.

### 7.25. + Синхронизация релизов в Аркадию {#sinkhronizatsiia-relizov-v-arkadiiu}

Изначально занимался Олег Алексеенков. Сейчас он перешёл работать в дружественный отдел, но обещает продолжать синхронизацию.
Затем, возможно, [Иван Лежанкин](https://github.com/abyss7). Но сейчас приостановлено, так как Максим из YT должен исправить регрессию производительности в анализе индекса.

Максим из YT сказал, что сделает это после нового года.
Максим из YT сказал, что «мы планируем в январе добиться».
Максим сейчас занимается собираемостью YT с новой версией ClickHouse.

Нужно для CHYT и YQL.

Upd: Все патчи Максима отправлены в master. Задача взята в работу.
Upd: Задача в процессе реализации. Синхронизироваться будет master. Делает [Иван Лежанкин](https://github.com/abyss7)
Upd: Есть собирающийся прототип, но сборка как будто ещё не в trunk Аркадии.
Upd: Добавлено в Аркадию, но не все файлы (не побайтово).
Upd: Добавлены все файлы побайтово.

### 7.26. + Побайтовая идентичность репозитория с Аркадией {#pobaitovaia-identichnost-repozitoriia-s-arkadiei}

Команда DevTools. Прогресс по задаче под вопросом.
Upd. Готово (все директории кроме contrib).

### 7.27. + Запуск автотестов в Аркадии {#zapusk-avtotestov-v-arkadii}

Требует 7.26. Коллеги начали делать, есть результат.
Upd. В Аркадии частично работает небольшая часть тестов. И этого достаточно.

### 7.29. + Опции clickhouse install, stop, start вместо postinst, init.d, systemd скриптов {#optsii-clickhouse-install-stop-start-vmesto-postinst-init-d-systemd-skriptov}

Низкий приоритет.

### 7.30. Возможность переключения бинарных файлов на продакшене без выкладки пакетов {#vozmozhnost-perekliucheniia-binarnykh-failov-na-prodakshene-bez-vykladki-paketov}

Низкий приоритет.
Сделали файл clickhouse.old.

### 7.31. Зеркалирование нагрузки между серверами {#zerkalirovanie-nagruzki-mezhdu-serverami}

В очереди. Нужно для Яндекс.Метрики.

### 7.32. + Обфускация продакшен запросов {#obfuskatsiia-prodakshen-zaprosov}

Роман Ильговский. Нужно для Яндекс.Метрики.
Есть pull request: https://github.com/ClickHouse/ClickHouse/pull/10973
Готово.

Имея SQL запрос, требуется вывести структуру таблиц, на которых этот запрос будет выполнен, и заполнить эти таблицы случайными данными, такими, что результат этого запроса зависит от выбора подмножества данных.

Для примера, если есть запрос `SELECT SearchPhrase, count(*) FROM table WHERE CounterID = 34 AND SearchPhrase LIKE '%ClickHouse%'`, то мы можем сделать вывод, что CounterID имеет числовой тип, а SearchPhrase - строковый. Заполнить таблицу данными, на которых отдельные условия `CounterID = 34` и `SearchPhrase LIKE '%ClickHouse%'` для некоторых строк выполнены, а для некоторых строк не выполнены.

Обфускация запросов: имея секретные запросы и структуру таблиц, заменить имена полей и константы, чтобы запросы можно было использовать в качестве публично доступных тестов.

Upd. Последняя часть пока не сделана и будет сделана отдельно.

### 7.33. Выкладывать патч релизы в репозиторий автоматически {#vykladyvat-patch-relizy-v-repozitorii-avtomaticheski}

В очереди. Иван Лежанкин.
Отсутствует прогресс.

### 7.34. + Бэкпортировать bugfix автоматически {#bekportirovat-bugfix-avtomaticheski}

В очереди. Иван Лежанкин.
Присутствует прогресс.
Сделано.

### 7.35. Начальные правила для авто-merge {#nachalnye-pravila-dlia-avto-merge}

Зелёные проверки и два ревью.
[Александр Сапин](https://github.com/alesapin). Может делегировать эту задачу кому угодно.

### 7.36. Понятие доверенных контрибьюторов {#poniatie-doverennykh-kontribiutorov}

Контрибьюторы, у которых есть 5 померженных PR. Для их новых PR автотесты запускаются сразу.
[Александр Сапин](https://github.com/alesapin). Может делегировать эту задачу кому угодно.
Сейчас добавляем некоторых доверенных контрибьюторов в ручном режиме.
Upd. Всё ещё добавляем в ручном режиме.

### 7.37. + Разобраться с repo.yandex.ru {#razobratsia-s-repo-yandex-ru}

Есть жалобы на скорость загрузки и неудобство maintenance, operations, visibility.

Upd. Иван Блинков настроил CDN repo.clickhouse.tech, что решает проблему с доступностью зарубежом.
Вопрос с operations, visibility пока актуален.

Upd. Частично решён вопрос с visibility - есть какой-то дэшборд.


## 8. Интеграция с внешними системами {#integratsiia-s-vneshnimi-sistemami}

### 8.1. Поддержка ALTER MODIFY SETTING для Kafka {#podderzhka-alter-modify-setting-dlia-kafka}

Также - возможность указать все настройки форматов в Kafka.

Altinity. Никто не делает эту задачу.

### 8.2. - Поддержка Mongo Atlas URI {#podderzhka-mongo-atlas-uri}

[Александр Кузьменков](https://github.com/akuzm).
Upd. Задача взята в работу.
Все pull requests успешно закрыты.

### 8.3. + Доработки globs (правильная поддержка диапазонов, уменьшение числа одновременных stream-ов) {#dorabotki-globs-pravilnaia-podderzhka-diapazonov-umenshenie-chisla-odnovremennykh-stream-ov}

[Ольга Хвостикова](https://github.com/stavrolia).

Уменьшение числа stream-ов сделано, а вот правильная поддержка диапазонов - нет. Будем надеяться на Q1/Q2. Сделано.

### 8.4. Унификация File, HDFS, S3 под URL {#unifikatsiia-file-hdfs-s3-pod-url}

### 8.5. + Аутентификация в S3 {#autentifikatsiia-v-s3}

[Владимир Чеботарёв](https://github.com/excitoon), Altinity.

### 8.6. Kerberos аутентификация для HDFS и Kafka {#kerberos-autentifikatsiia-dlia-hdfs-i-kafka}

Андрей Коняев, ArenaData. Он куда-то пропал.
Для Kafka готово, для HDFS в процессе.

### 8.7. + Исправление мелочи HDFS на очень старых ядрах Linux {#ispravlenie-melochi-hdfs-na-ochen-starykh-iadrakh-linux}

В ядрах 2.6 отсутствует один системный вызов, который библиотека hdfs3 использует без необходимости.
Сделал Amos Bird.

### 8.8. + Поддержка виртуальных столбцов с именем файла и путём {#podderzhka-virtualnykh-stolbtsov-s-imenem-faila-i-putiom}

[Ольга Хвостикова](https://github.com/stavrolia).

### 8.9. + Поддержка сжатых файлов (gz, bz) на чтение и запись {#podderzhka-szhatykh-failov-gz-bz-na-chtenie-i-zapis}

Сделал [Andrey Bodrov](https://github.com/apbodrov)

### 8.10. + Запись в табличную функцию ODBC {#zapis-v-tablichnuiu-funktsiiu-odbc}

Артемий Бобровский, ВШЭ
Есть pull request.

### 8.11. + Движок таблиц для чтения из Mongo {#dvizhok-tablits-dlia-chteniia-iz-mongo}

Артемий Бобровский, ВШЭ
Есть pull request.
Upd. В стадии код-ревью.
Готово.

### 8.12. Пропуск столбцов в форматах Parquet, ORC {#propusk-stolbtsov-v-formatakh-parquet-orc}

Реализовано возможно частично - проверить.

### 8.13. Поддержка массивов в Parquet, ORC {#podderzhka-massivov-v-parquet-orc}

### 8.14. + Запись данных в ORC {#zapis-dannykh-v-orc}

Павел Круглов, ВШЭ. Есть pull request. Готово.

### 8.15. Запись данных в CapNProto {#zapis-dannykh-v-capnproto}

Отложено.

### 8.16. + Поддержка формата Avro {#podderzhka-formata-avro}

Andrew Onyshchuk. Есть pull request. Q1. Сделано.

Формат Apache Avro является компактным структурированным построчным бинарным форматом данных с внешней схемой. Этот формат часто используется совместно с Kafka и поддержка его в качестве одного из форматов ввода-вывода в ClickHouse является востребованной пользователями.

### 8.16.1. + Поддержка формата JSONEachRow, засунутого в массив {#podderzhka-formata-jsoneachrow-zasunutogo-v-massiv}

Павел Круглов, ВШЭ и Яндекс. Есть pull request.

### 8.16.2. - Поддержка формата Thrift {#podderzhka-formata-thrift}

Павел Круглов, ВШЭ и Яндекс. Задача отменена.

### 8.16.3. + Поддержка формата MsgPack {#podderzhka-formata-msgpack}

Павел Круглов, ВШЭ и Яндекс.
Задача взята в работу.

Upd. Почти готово - есть лишь небольшой технический долг.
Upd. Готово.

### 8.16.4. + Формат Regexp {#format-regexp}

Павел Круглов, ВШЭ и Яндекс.
Есть pull request. Готово.

### 8.17. + ClickHouse как MySQL реплика {#clickhouse-kak-mysql-replika}

Задачу делает BohuTANG.

Реализовать возможность подписаться на row-based репликацию MySQL и сохранять полученные данные в CollapsingMergeTree или ReplacingMergeTree таблицы. Сторонние решения для этой задачи уже существуют: https://www.altinity.com/blog/2018/6/30/realtime-mysql-clickhouse-replication-in-practice Также существует стороннее решение для PostgreSQL: https://github.com/mkabilov/pg2ch

Встроенная в ClickHouse возможность работать в качестве реплики MySQL даст преимущества для дальнейшего развития.

### 8.18. + ClickHouse как Federated MySQL {#clickhouse-kak-federated-mysql}

Maxim Fedotov, Wargaming + Yuri Baranov, Яндекс.

### 8.19. + Интеграция с RabbitMQ {#integratsiia-s-rabbitmq}

Ксения Сумарокова, ВШЭ.

В ClickHouse часто используется потоковый импорт данных из распределённой очереди. Наиболее популярно использование совместно с Kafka. Эта возможность уже есть.

Следующей по востребованности является система очередей RabbitMQ. Её поддержка в ClickHouse отсутствует.

Есть pull request в процессе разработки.
Upd. В процессе code review.
Upd. Готово.

### 8.20. - Интеграция с SQS {#integratsiia-s-sqs}

Низкий приоритет. Отменено.

### 8.21. - Поддержка произвольного количества языков для имён регионов {#podderzhka-proizvolnogo-kolichestva-iazykov-dlia-imion-regionov}

Нужно для БК. Декабрь 2019.
В декабре для БК сделан минимальный вариант этой задачи.
Максимальный вариант, вроде, никому не нужен.
Upd. Всё ещё кажется, что задача не нужна.
Отменено.

### 8.22. + Поддержка синтаксиса для переменных в стиле MySQL {#podderzhka-sintaksisa-dlia-peremennykh-v-stile-mysql}

При парсинге запроса преобразовывать синтаксис вида `@@version_full` в вызов функции `getGlobalVariable('version_full')`. Поддержать популярные MySQL переменные. Может быть поможет Юрий Баранов, если будет энтузиазм.

Upd. Юрий Баранов работает в Google, там запрещено разрабатывать ClickHouse.
Upd. Сделано теми людьми, кому не запрещено разрабатывать ClickHouse.

### 8.23. Подписка для импорта обновляемых и ротируемых логов в ФС {#podpiska-dlia-importa-obnovliaemykh-i-rotiruemykh-logov-v-fs}

Желательно 2.15.
Отложено.


## 9. Безопасность {#bezopasnost}

### 9.1. + Ограничение на хосты в запросах ко внешним системам {#ogranichenie-na-khosty-v-zaprosakh-ko-vneshnim-sistemam}

Михаил Коротов.

### 9.2. Преднастроенные именованные соединения к внешним БД {#prednastroennye-imenovannye-soedineniia-k-vneshnim-bd}

ClickHouse предоставляет возможность обратиться к внешней базе данных из языка запросов. Это реализовано в виде табличных функций. В параметрах к табличной функции указывается адрес удалённой базы данных (хост, порт), а также аутентификационные данные (имя пользователя, пароль). Аутентификационные данные указываются в запросе в открытом виде и, таким образом, попадают в историю запросов и в логи, что компрометирует безопасность системы.

Вместо этого предлагается описывать необходимые данные в конфигурационном файле сервера или в отдельном сервисе и ссылаться на них по именам.

### 9.3. + Поддержка TLS для ZooKeeper {#podderzhka-tls-dlia-zookeeper}

[#10174](https://github.com/ClickHouse/ClickHouse/issues/10174)

Есть pull request.


## 10. Внешние словари {#vneshnie-slovari}

### 10.1. + Исправление зависания в библиотеке доступа к YT {#ispravlenie-zavisaniia-v-biblioteke-dostupa-k-yt}

Библиотека для доступа к YT не переживает учения.
Нужно для БК и Метрики. Поиск причин - [Александр Сапин](https://github.com/alesapin). Дальшейшее исправление возможно на стороне YT.

Цитата: «Оказывается для YT-клиента зависания на несколько минут это нормально. Убрал внутренние ретраи, снизил таймауты. Однозначно станет лучше».

### 10.2. + Исправление SIGILL в библиотеке доступа к YT {#ispravlenie-sigill-v-biblioteke-dostupa-k-yt}

Код YT использует SIGILL вместо abort. Это, опять же, происходит при учениях.
Нужно для БК и Метрики. Поиск причин - [Александр Сапин](https://github.com/alesapin). Дальшейшее исправление возможно на стороне YT.

Upd. Одну причину устранили, но ещё что-то неизвестное осталось.
Upd. Нас заставляют переписать эту библиотеку с одного API на другое, так как старое внезапно устарело. Кажется, что переписывание случайно исправит все проблемы.
Upd. Ура, нашли причину и исправили.

### 10.3. - Возможность чтения данных из статических таблиц в YT словарях {#vozmozhnost-chteniia-dannykh-iz-staticheskikh-tablits-v-yt-slovariakh}

Нужно для БК и Метрики.
Отменено.

### 10.4. - Словарь из YDB (KikiMR) {#slovar-iz-ydb-kikimr}

Нужно для Метрики, а делать будет таинственный незнакомец из команды KikiMR (под вопросом). Таинственный незнакомец не подтверждает, что он будет делать эту задачу.

### 10.5. Закрытие соединений и уменьшение числа соединений для MySQL и ODBC {#zakrytie-soedinenii-i-umenshenie-chisla-soedinenii-dlia-mysql-i-odbc}

Нужно для Метрики.

Для MySQL сделал Clément Rodriguez.

### 10.6. + Словари из Cassandra и Couchbase {#slovari-iz-cassandra-i-couchbase}

Готова Cassandra.
Couchbase отменён, так как не было спроса.
Aerospike под вопросом.

### 10.7. Поддержка Nullable в словарях {#podderzhka-nullable-v-slovariakh}

### 10.8. Поддержка массивов в словарях {#podderzhka-massivov-v-slovariakh}

### 10.9. - Уменьшение блокировок для cache словарей за счёт одновременных запросов одного и того же {#umenshenie-blokirovok-dlia-cache-slovarei-za-schiot-odnovremennykh-zaprosov-odnogo-i-togo-zhe}

Заменено в пользу 10.10, 10.11.

### 10.10. + Возможность использования старых значений из cache словаря пока они перезапрашиваются {#vozmozhnost-ispolzovaniia-starykh-znachenii-iz-cache-slovaria-poka-oni-perezaprashivaiutsia}

Никита Михайлов. Q1. Нужно для БК и Метрики.

### 10.11. + Возможность исключительно асинхронных запросов в cache словарях {#vozmozhnost-iskliuchitelno-asinkhronnykh-zaprosov-v-cache-slovariakh}

Никита Михайлов. Q1. Нужно для БК и Метрики. Требует 10.10.

### 10.12. + Layout direct для словарей {#layout-direct-dlia-slovarei}

Артём Стрельцов, Николай Дегтеринский, Наталия Михненко, ВШЭ.
Приступили к этой задаче.
Готов direct, есть pull request complex_key_direct.
Готово всё.

### 10.13. Использование Join как generic layout для словарей {#ispolzovanie-join-kak-generic-layout-dlia-slovarei}

### 10.14. Поддержка всех типов в функции transform {#podderzhka-vsekh-tipov-v-funktsii-transform}

### 10.15. + Использование словарей как специализированного layout для Join {#ispolzovanie-slovarei-kak-spetsializirovannogo-layout-dlia-join}

### 10.16. + Словари на локальном SSD {#slovari-na-lokalnom-ssd}

Никита Васильев, ВШЭ и Яндекс. Есть pull request.

Реализовать в ClickHouse специализированный движок таблиц, подходящий для быстрых key-value запросов и оптимизированный для расположения данных на SSD. Это может быть: реализация на основе RocksDB; сериализованные RowBinary данные с индексом в оперативке; секретная очень эффективная структура данных, о которой я расскажу.

Использовать эту структуру данных как отдельный вид словарей, как источник для cache словарей или как дополнительный уровень кэширования для cache словарей.

Upd. Задача в финальной стадии готовности.

### 10.17. Локальный дамп состояния словаря для быстрого старта сервера {#lokalnyi-damp-sostoianiia-slovaria-dlia-bystrogo-starta-servera}

Отложено.

### 10.18. Таблица Join или словарь на удалённом сервере как key-value БД для cache словаря {#tablitsa-join-ili-slovar-na-udalionnom-servere-kak-key-value-bd-dlia-cache-slovaria}

### 10.19. Возможность зарегистрировать некоторые функции, использующие словари, под пользовательскими именами {#vozmozhnost-zaregistrirovat-nekotorye-funktsii-ispolzuiushchie-slovari-pod-polzovatelskimi-imenami}

Отложено.


## 11. Интерфейсы {#interfeisy}

### 11.1. Вставка состояний агрегатных функций в виде кортежа аргументов или массива кортежей аргументов {#vstavka-sostoianii-agregatnykh-funktsii-v-vide-kortezha-argumentov-ili-massiva-kortezhei-argumentov}

### 11.2. Возможность использовать движок JDBC из коробки {#vozmozhnost-ispolzovat-dvizhok-jdbc-iz-korobki}

Нужно разобраться, как упаковывать Java в статический бинарник, возможно AppImage. Или предоставить максимально простую инструкцию по установке jdbc-bridge. Может быть будет заинтересован Александр Крашенинников, Badoo, так как он разработал jdbc-bridge.

Upd. Александр Крашенинников перешёл в другую компанию и больше не занимается этим.
Upd. Задачу взял Zhichun Wu.

### 11.3. + Интеграционные тесты ODBC драйвера путём подключения ClickHouse к самому себе через ODBC {#integratsionnye-testy-odbc-draivera-putiom-podkliucheniia-clickhouse-k-samomu-sebe-cherez-odbc}

Михаил Филимонов, Altinity. Готово.

### 11.4. Исправление упячек с типами Date и Decimal в clickhouse-cpp {#ispravlenie-upiachek-s-tipami-date-i-decimal-v-clickhouse-cpp}

Altinity целиком взяли на себя поддержку clickhouse-cpp драйвера.

### 11.5. Поддержка TLS в clickhouse-cpp {#podderzhka-tls-v-clickhouse-cpp}

А знаете ли вы, что библиотеку clickhouse-cpp разрабатывал один хороший человек в свободное время?

### 11.6. Интеграционные тесты clickhouse-cpp {#integratsionnye-testy-clickhouse-cpp}

### 11.7. Интерактивный режим работы программы clickhouse-local {#interaktivnyi-rezhim-raboty-programmy-clickhouse-local}

Отложено.

### 11.8. + Поддержка протокола PostgreSQL {#podderzhka-protokola-postgresql}

Элбакян Мовсес Андраникович, ВШЭ.

В ClickHouse в прошлом году добавили поддержку wire-протокола MySQL. PostgreSQL, так же как MySQL, использует несложный протокол общения между клиентом и сервером, но свой собственный. Поддержка этого протокола является востребованной и откроет новые возможности для ClickHouse.

Задача в процессе разработки.
Задача в финальной стадии разработки.

### 11.9. + Доработки ODBC драйвера {#dorabotki-odbc-draivera}

Денис Глазачев, Altinity. Хороший прогресс по этой задаче.

### 11.10. + Преднастроенные HTTP handlers для запросов {#prednastroennye-http-handlers-dlia-zaprosov}

zhang2014, есть pull request.

Возможность описать в конфигурационном файле handler (путь в URL) для HTTP запросов к серверу, которому соответствует некоторый параметризованный запрос. Пользователь может вызвать этот обработчик и не должен передавать SQL запрос.


## 12. Управление пользователями и доступом {#upravlenie-polzovateliami-i-dostupom}

### 12.1. + Role Based Access Control {#role-based-access-control}

[Виталий Баранов](https://github.com/vitlibar). Финальная стадия разработки, рабочая версия в начале апреля 2019.
Q2. Сейчас сделаны все интерфейсы в коде и запросы, но не сделаны варианты хранения прав кроме прототипа.
Upd. Сделано хранение прав. До готового к использованию состояния осталось несколько доработок.

### 12.2. + Управление пользователями и правами доступа с помощью SQL запросов {#upravlenie-polzovateliami-i-pravami-dostupa-s-pomoshchiu-sql-zaprosov}

[Виталий Баранов](https://github.com/vitlibar). Финальная стадия разработки, рабочая версия в декабре 2019.
Q1. Сделано управление правами полностью, но не реализовано их хранение, см. 12.1.

### 12.3. + Подключение справочника пользователей и прав доступа из LDAP {#podkliuchenie-spravochnika-polzovatelei-i-prav-dostupa-iz-ldap}

Аутентификация через LDAP - Денис Глазачев.
[Виталий Баранов](https://github.com/vitlibar) и Денис Глазачев, Altinity. Требует 12.1.
Q3.
Upd. Pull request на финальной стадии.

### 12.4. - Подключение IDM системы Яндекса как справочника пользователей и прав доступа {#podkliuchenie-idm-sistemy-iandeksa-kak-spravochnika-polzovatelei-i-prav-dostupa}

Пока низкий приоритет. Нужно для Метрики. Требует 12.3.
Отложено.

### 12.5. Pluggable аутентификация с помощью Kerberos (возможно, подключение GSASL) {#pluggable-autentifikatsiia-s-pomoshchiu-kerberos-vozmozhno-podkliuchenie-gsasl}

[Виталий Баранов](https://github.com/vitlibar) и Денис Глазачев, Altinity. Требует 12.1.
Upd. Есть pull request.

### 12.6. + Информация о пользователях и квотах в системной таблице {#informatsiia-o-polzovateliakh-i-kvotakh-v-sistemnoi-tablitse}

[Виталий Баранов](https://github.com/vitlibar). Требует 12.1.
Есть pull request. Q2. Готово.


## 13. Разделение ресурсов, multi-tenancy {#razdelenie-resursov-multi-tenancy}

### 13.1. Overcommit запросов по памяти и вытеснение {#overcommit-zaprosov-po-pamiati-i-vytesnenie}

Требует 2.1. Способ реализации обсуждается.

### 13.2. Общий конвейер выполнения на сервер {#obshchii-konveier-vypolneniia-na-server}

Требует 2.1. [Николай Кочетов](https://github.com/KochetovNicolai).

### 13.3. Пулы ресурсов {#puly-resursov}

Требует 13.2 или сможем сделать более неудобную реализацию раньше.
Обсуждается вариант неудобной реализации. Пока средний приоритет, целимся на Q1/Q2.
Вариант реализации выбрал Александр Казаков.
Upd. Не уследили, и задачу стали обсуждать менеджеры.
Upd. Задачу смотрит Александр Казаков.
Upd. Задача взята в работу.
Upd. Задача как будто взята в работу.
Upd. Задачу не сделал.


## 14. Диалект SQL {#dialekt-sql}

### 14.1. + Исправление семантики CAST для Nullable {#ispravlenie-semantiki-cast-dlia-nullable}

Нужно для DataLens. А также для внедрения в BI инструмент Looker.

### 14.2. + Поддержка WITH для подзапросов {#podderzhka-with-dlia-podzaprosov}

Сделал Amos Bird.

### 14.3. Поддержка подстановок для множеств в правой части IN {#podderzhka-podstanovok-dlia-mnozhestv-v-pravoi-chasti-in}

### 14.4. + Поддержка подстановок для идентификаторов (имён) в SQL запросе {#podderzhka-podstanovok-dlia-identifikatorov-imion-v-sql-zaprose}

Amos Bird сделал.

### 14.5. + Поддержка задания множества как массива в правой части секции IN {#podderzhka-zadaniia-mnozhestva-kak-massiva-v-pravoi-chasti-sektsii-in}

Василий Немков, Altinity, делал эту задачу, но забросил её в пользу других задач.
В результате, сейчас доделывает Антон Попов.

### 14.6. + Глобальный scope для WITH {#globalnyi-scope-dlia-with}

Amos Bird сделал.

### 14.7. Nullable для WITH ROLLUP, WITH CUBE, WITH TOTALS {#nullable-dlia-with-rollup-with-cube-with-totals}

Простая задача.

### 14.8. + Модификаторы DISTINCT, ORDER BY для агрегатных функций {#modifikatory-distinct-order-by-dlia-agregatnykh-funktsii}

В ClickHouse поддерживается вычисление COUNT(DISTINCT x). Предлагается добавить возможность использования модификатора DISTINCT для всех агрегатных функций. Например, AVG(DISTINCT x) - вычислить среднее значение для всех различных значений x. Под вопросом вариант, в котором фильтрация уникальных значений выполняется по одному выражению, а агрегация по другому.

Результат некоторых агрегатных функций зависит от порядка данных. Предлагается реализовать модификатор ORDER BY, задающий порядок явно. Пример: groupArray(x ORDER BY y, z).

Upd. Есть pull request-ы.
Upd. DISTINCT готов.
Upd. ORDER BY отменён и будет заново сделан уже с LIMIT.

### 14.9. + Поддержка запроса EXPLAIN {#podderzhka-zaprosa-explain}

Требует 2.1. [Николай Кочетов](https://github.com/KochetovNicolai).
Upd. Есть pull request. Готово.

### 14.10. arrayReduce как функция высшего порядка {#arrayreduce-kak-funktsiia-vysshego-poriadka}

### 14.11. Функции для grouping sets {#funktsii-dlia-grouping-sets}

Отложено.

### 14.12. Функции обработки временных рядов {#funktsii-obrabotki-vremennykh-riadov}

Отложено.

Сложная задача, так как вводит новый класс функций и требует его обработку в оптимизаторе запросов.

В time-series СУБД нужны функции, которые зависят от последовательности значений. Или даже от последовательности значений и их меток времени. Примеры: moving average, exponential smoothing, derivative, Holt-Winters forecast. Вычисление таких функций поддерживается в ClickHouse лишь частично. Так, ClickHouse поддерживает тип данных «массив» и позволяет реализовать эти функции как функции, принимающие массивы. Но гораздо удобнее для пользователя было бы иметь возможность применить такие функции к таблице (промежуточному результату запроса после сортировки).

Это требует введение нового класса функций (помимо обычных и агрегатных функций) - такие функции будут иметь в коде ClickHouse свой собственный интерфейс, и их вычисление придётся отдельно учитывать в конвейере выполнения запросов. Для примера, вычисление обычных функций тривиально распараллеливается по процессорным ядрам и по серверам; вычисление агрегатных функций распараллеливается с некоторыми особенностями (работа с промежуточными состояниями вычислений, операция merge); а для функций по обработке временных рядов этот вопрос остаётся открытым - возможно, их придётся вычислять на одном сервере и в одном потоке.

### 14.13. Применимость функций высшего порядка для кортежей и Nested {#primenimost-funktsii-vysshego-poriadka-dlia-kortezhei-i-nested}

После задачи "чтение срезов столбцов".

### 14.14. Неявные преобразования типов констант {#neiavnye-preobrazovaniia-tipov-konstant}

Сделано для операторов сравнения с константами (подавляющее большинство use cases).
В общем виде требует 2.12.

### 14.15. Неявные преобразования типов под настройкой {#neiavnye-preobrazovaniia-tipov-pod-nastroikoi}

Требует 2.12. Для внедрения в BI инструмент Looker.

### 14.16. Синонимы для функций из MySQL {#sinonimy-dlia-funktsii-iz-mysql}

### 14.17. + Ввести понятие stateful функций {#vvesti-poniatie-stateful-funktsii}

Для runningDifference, neighbour - их учёт в оптимизаторе запросов.
В интерфейсе уже сделано. Надо проверить, что учитывается в нужных местах (например, что работает predicate pushdown сквозь ORDER BY, если таких функций нет).
Александр Кузьменков.

### 14.18. + UNION DISTINCT и возможность включить его по-умолчанию {#union-distinct-i-vozmozhnost-vkliuchit-ego-po-umolchaniiu}

Для BI систем. flynn ucasFL.

### 14.19. + Совместимость парсера типов данных с SQL {#sovmestimost-parsera-tipov-dannykh-s-sql}

Павел Потёмкин, ВШЭ.
Для BI систем.

### 14.20. Позиционные аргументы для GROUP BY и ORDER BY {#pozitsionnye-argumenty-dlia-group-by-i-order-by}

Тривиально и используется многими системами, но не входит в стандарт SQL.

### 14.21. Приведение типов для IN (подзапрос) и для JOIN {#privedenie-tipov-dlia-in-podzapros-i-dlia-join}


## 15. Улучшение поддержки JOIN {#uluchshenie-podderzhki-join}

### 15.1. + Доведение merge JOIN до продакшена {#dovedenie-merge-join-do-prodakshena}

Артём Зуйков. Сейчас merge JOIN включается вручную опцией и всегда замедляет запросы. Хотим, чтобы он замедлял запросы только когда это неизбежно.
Кстати, смысл merge JOIN появляется только совместно с 15.2 и 15.3.
Q1. Сделали адаптивный вариант, но вроде он что-то всё-ещё замедляет.
Задача сделана, но всё работает слишком медленно.

### 15.1.1. Алгоритм two-level merge JOIN {#algoritm-two-level-merge-join}

Также известен как grace hash join.
Артём Зуйков. В очереди.

### 15.1.2. Тестирование реализации JOIN в Greenplum {#testirovanie-realizatsii-join-v-greenplum}

В очереди. Как будто задача самоотменилась.

### 15.2. Прокидывание условий в OUTER JOIN {#prokidyvanie-uslovii-v-outer-join}

Возможно, Артём Зуйков, но задача ещё не продумана до конца. Возможно, требует 2.1.

### 15.3. Логический вывод для цепочек вида ON t1.x = t2.y WHERE t1.x = 10 {#logicheskii-vyvod-dlia-tsepochek-vida-on-t1-x-t2-y-where-t1-x-10}

Возможно, Артём Зуйков. Для полноценной работы 15.2.

### 15.4. Distributed JOIN с помощью перераспределения данных {#distributed-join-s-pomoshchiu-pereraspredeleniia-dannykh}

Артём Зуйков.

### 15.5. Использование ключа таблицы для оптимизации merge JOIN {#ispolzovanie-kliucha-tablitsy-dlia-optimizatsii-merge-join}

### 15.6. + SEMI и ANTI JOIN {#semi-i-anti-join}

Артём Зуйков.


## 16. Типы данных и функции {#tipy-dannykh-i-funktsii}

### 16.1. + DateTime64 {#datetime64}

Василий Немков, Altinity, декабрь 2019.

### 16.2. Тип данных для JSON {#tip-dannykh-dlia-json}

zhang2014

Есть PR, в процессе ревью.

### 16.3. Поддержка неконстантных аргументов с регулярными выражениями в функциях {#podderzhka-nekonstantnykh-argumentov-s-reguliarnymi-vyrazheniiami-v-funktsiiakh}

Данила Кутенин, но только после секретного изменения в работе.
Upd. Секретного изменения в работе не будет, задачу будет делать другой человек.

### 16.4. Функция rowNumberForKey {#funktsiia-rownumberforkey}

### 16.5. Функции для XML и HTML escape {#funktsii-dlia-xml-i-html-escape}

### 16.6. + Функции нормализации и хэширования SQL запросов {#funktsii-normalizatsii-i-kheshirovaniia-sql-zaprosov}

Алексей Миловидов. Сделано.


## 17. Работа с географическими данными {#rabota-s-geograficheskimi-dannymi}

### 17.1. + Гео-словари для определения региона по координатам {#geo-slovari-dlia-opredeleniia-regiona-po-koordinatam}

[Андрей Чулков](https://github.com/achulkov2), Антон Кваша, Артур Петуховский, ВШЭ.
Будет основано на коде от Арслана Урташева.

ClickHouse не является geospatial СУБД. Тем не менее, в ClickHouse есть несколько функций для таких задач. Например, функция `pointInPolygon` позволяет быстро проверить попадание точек в полигон на плоскости. При этом, полигон задаётся в явном виде и должен быть константным для вызова функции (то есть - проверяется принадлежность многих точек одному полигону). Эта функциональность нужна, например, для рекламного таргетинга мобильных устройств по координатам.

Похожая, но более сложная задача, которую ClickHouse пока не умеет решать - определение полигона среди множества полигонов, в которые попадают точки. Для примера: определение района города по географическим координатам. Для решения этой задачи нужно будет реализовать поддержку словарей с полигонами, в которых данные проиндексированы для быстрого поиска.

Upd. Андрей сделал прототип интерфейса и реализацию-заглушку внутри него.
Upd. Андрей сделал прототип более оптимальной структуры данных.
Upd. Есть обнадёживающие результаты.
Upd. В ревью.
Upd. В релизе.

### 17.2. GIS типы данных и операции {#gis-tipy-dannykh-i-operatsii}

Алексей Коряков, Алексей Илюхов, ВШЭ, Яндекс.Карты.

Реализовать в ClickHouse типы данных для задач обработки геоинформационных данных: Point, Line, MultiLine, Polygon и операции над ними - проверка вхождения, пересечения. Вариантом минимум будет реализация этих операций в евклидовой системе координат. Дополнительно - на сфере и WGS84.

Upd. Есть pull request.

### 17.3. + Ускорение greatCircleDistance {#uskorenie-greatcircledistance}

[Ольга Хвостикова](https://github.com/stavrolia), основано на коде Андрея Аксёнова, получено разрешение на использование кода.

### 17.4. Ускорение geohash с помощью библиотеки из Аркадии {#uskorenie-geohash-s-pomoshchiu-biblioteki-iz-arkadii}

Получено одобрение от руководства.

### 17.5. + Проверки в функции pointInPolygon {#proverki-v-funktsii-pointinpolygon}

Сейчас функция тихо не работает в случае полигонов с самопересечениями, надо кидать исключение.


## 18. Машинное обучение и статистика {#mashinnoe-obuchenie-i-statistika}

### 18.1. Инкрементальная кластеризация данных {#inkrementalnaia-klasterizatsiia-dannykh}

Александр Кожихов, Максим Кузнецов. Обнаружена фундаментальная проблема в реализации, доделывает предположительно [Николай Кочетов](https://github.com/KochetovNicolai). Он может делегировать задачу кому угодно.

Исправление фундаментальной проблемы - есть PR.
Фундаментальная проблема решена.

### 18.2. + Агрегатные функции для статистических тестов {#agregatnye-funktsii-dlia-statisticheskikh-testov}

Артём Цыганов, Руденский Константин Игоревич, Семёнов Денис, ВШЭ.

Предлагается реализовать в ClickHouse статистические тесты (Analysis of Variance, тесты нормальности распределения и т. п.) в виде агрегатных функций. Пример: `welchTTest(value, sample_idx)`.

Сделали прототип двух тестов, есть pull request. Также есть pull request для корелляции рангов.
Upd. Помержили корелляцию рангов, но ещё не помержили сравнение t-test, u-test.
Upd. Всё доделал Никита Михайлов.

### 18.3. Инфраструктура для тренировки моделей в ClickHouse {#infrastruktura-dlia-trenirovki-modelei-v-clickhouse}

В очереди.
Отложено.


## 19. Улучшение работы кластера {#uluchshenie-raboty-klastera}

### 19.1. + Параллельные кворумные вставки без линеаризуемости {#parallelnye-kvorumnye-vstavki-bez-linearizuemosti}

Upd. В работе, ожидается в начале октября.

Репликация данных в ClickHouse по-умолчанию является асинхронной без выделенного мастера. Это значит, что клиент, осуществляющий вставку данных, получает успешный ответ после того, как данные попали на один сервер; репликация данных по остальным серверам осуществляется в другой момент времени. Это ненадёжно, потому что допускает потерю только что вставленных данных при потере лишь одного сервера.

Для решения этой проблемы, в ClickHouse есть возможность включить «кворумную» вставку. Это значит, что клиент, осуществляющий вставку данных, получает успешный ответ после того, как данные попали на несколько (кворум) серверов. Обеспечивается линеаризуемость: клиент, получает успешный ответ после того, как данные попали на несколько реплик, *которые содержат все предыдущие данные, вставленные с кворумом* (такие реплики можно называть «синхронными»), и при запросе SELECT можно выставить настройку, разрешающую только чтение с синхронных реплик.

Если бы свойства линеаризуемости не было, то для трёх серверов A, B, C, значения кворума = 2, и для трёх вставок данных 1, 2, 3, возможна ситуация, что первая вставка прошла на серверы A и B, вторая прошла на серверы B и C, а третья - на серверы A и C, и теперь ни один из серверов не содержит полный набор данных 1, 2, 3.

Как ни странно, такое свойство не нужно большинству пользователей. Оно запрещает параллельно выполняющиеся вставки. А пользователи хотят вставлять данные надёжно (на более чем одну реплику), но не важно, в каком порядке. Предлагается сделать опцию, которая отключает линеаризуемость.

Иногда пользователь хочет реализовать кворумную вставку вручную: просто соединиться с несколькими репликами и вставть на них одинаковые данные (чтобы обеспечить надёжную вставку, не ориентируясь на то, как работает механизм репликации). Сейчас ожидания пользователя не оправдываются. В ClickHouse есть механизм дедупликации для обеспечения идемпотентности вставок. Вторая вставка с такими же данными (пусть даже на другую реплику) будет проигнорирована. Надо сделать так, чтобы вместо этого, вставка одинаковых данных на другую реплику, имела такой же эффект, как если бы эти данные были получены с помощью механизма репликации.

### 19.2. Подключение Etcd или Consul как альтернативы ZooKeeper {#podkliuchenie-etcd-ili-consul-kak-alternativy-zookeeper}

Алексей Лёвушкин, ВШЭ и Яндекс.

Для координации реплик в ClickHouse используется ZooKeeper. Многие пользователи ClickHouse хотели бы иметь возможность использовать для координации некоторые другие системы вместо ZooKeeper. Рассматриваемыми вариантами таких систем являются Etcd, Consul, FoundationDB. Это весьма проблематично, так как эти системы существенно отличаются по интерфейсам и возможностям. Тем не менее, для того, чтобы эта задача стала возможной, в ClickHouse обобщён интерфейс взаимодействия с ZooKeeper, и теперь на его место можно подставлять другие реализации.

В прошлом году, Алексей добавил модельную реализацию (mock) интерфейса ZooKeeper для тестирования. Сейчас предлагается сделать реализацию поверх Etcd, а также расширить возможности тестовой реализации.

Upd. Алексей сделал какой-то вариант, но борется с тем, что ничего не работает.
Upd. Есть pull request на начальной стадии.
Upd. Взято в работу, но непонятна перспектива, так как не ясно, подлежат ли исправлению некоторые нюансы.

### 19.3. - Подключение YT Cypress или YDB как альтернативы ZooKeeper {#podkliuchenie-yt-cypress-ili-ydb-kak-alternativy-zookeeper}

Hold. Полезно для заказчиков внутри Яндекса, но есть риски. Эту задачу никто не будет делать.

### 19.4. internal_replication = ‘auto’ {#internal-replication-auto}

### 19.5. Реплицируемые базы данных {#replitsiruemye-bazy-dannykh}

В очереди, возможно Валерий Батурин, ВШЭ.

Репликация в ClickHouse работает на уровне отдельных таблиц. Это является очень гибким решением: на одном сервере одна из таблиц может быть не реплицирована, другая иметь двухкратную репликацию, а третья - реплицирована по всем серверам. Но если все таблицы в базе данных реплицированы одинаковым образом. то это затрудняет управление кластером. Например, при восстановлени сервера, требуется отдельно создавать реплику для каждой таблицы.

Предлагается реализовать «движок баз данных», который осуществляет репликацию метаданных (множество имеющихся таблиц и лог DDL операций над ними: CREATE, DROP, RENAME, ALTER). Пользователь сможет создать реплицируемую базу данных; при её создании или восстановлении на другом сервере, все реплицируемые таблицы будут созданы автоматически.

Upd. Задача в разработке.

### 19.6. + Одновременный выбор кусков для слияния многими репликами, отказ от leader election в ZK {#odnovremennyi-vybor-kuskov-dlia-sliianiia-mnogimi-replikami-otkaz-ot-leader-election-v-zk}

Готово.

### 19.7. Возможность записи данных при недоступности ZK и отказ от линейного порядка кусков в большинстве случаев {#vozmozhnost-zapisi-dannykh-pri-nedostupnosti-zk-i-otkaz-ot-lineinogo-poriadka-kuskov-v-bolshinstve-sluchaev}

### 19.8. Отказ от хранения в ZK множества кусков для каждой реплики отдельно {#otkaz-ot-khraneniia-v-zk-mnozhestva-kuskov-dlia-kazhdoi-repliki-otdelno}

### 19.9. Отказ от хранения в ZK лога вставок и мержей. Обмен данными о кусках напрямую {#otkaz-ot-khraneniia-v-zk-loga-vstavok-i-merzhei-obmen-dannymi-o-kuskakh-napriamuiu}

Три задачи выше обсуждаются, есть варианты.

### 19.10. Облачные таблицы {#oblachnye-tablitsy}

Требует 1.6, 19.1, 19.6, 19.7, 19.8, 19.9.

## 20. Мутации данных {#mutatsii-dannykh}

Пока все задачи по точечным UPDATE/DELETE имеют низкий приоритет, но ожидаем взять в работу в середине 2020.

### 20.1. Поддержка DELETE путём запоминания множества затронутых кусков и ключей {#podderzhka-delete-putiom-zapominaniia-mnozhestva-zatronutykh-kuskov-i-kliuchei}

### 20.2. Поддержка DELETE путём преобразования множества ключей в множество row_numbers на реплике, столбца флагов и индекса по диапазонам {#podderzhka-delete-putiom-preobrazovaniia-mnozhestva-kliuchei-v-mnozhestvo-row-numbers-na-replike-stolbtsa-flagov-i-indeksa-po-diapazonam}

Задача назначена на 2021.

### 20.3. Поддержка ленивых DELETE путём запоминания выражений и преобразования к множеству ключей в фоне {#podderzhka-lenivykh-delete-putiom-zapominaniia-vyrazhenii-i-preobrazovaniia-k-mnozhestvu-kliuchei-v-fone}

### 20.4. Поддержка UPDATE с помощью преобразования в DELETE и вставок {#podderzhka-update-s-pomoshchiu-preobrazovaniia-v-delete-i-vstavok}


## 21. Оптимизации производительности {#optimizatsii-proizvoditelnosti}

### 21.1. + Параллельный парсинг форматов {#parallelnyi-parsing-formatov}

Начинал Олег Ершов, доделывает Никита Михайлов, помогает [Александр Кузьменков](https://github.com/akuzm). Готово.

### 21.1.1. Избавление от лишнего копирования при параллельном парсинге форматов, если возможен mmap файла целиком {#izbavlenie-ot-lishnego-kopirovaniia-pri-parallelnom-parsinge-formatov-esli-vozmozhen-mmap-faila-tselikom}

### 21.2. Параллельное форматирование форматов {#parallelnoe-formatirovanie-formatov}

После 21.1, предположительно Никита Михайлов. Задача сильно проще чем 21.1.
В процессе.

### 21.3. + Исправление низкой производительности анализа индекса в случае большого множества в секции IN {#ispravlenie-nizkoi-proizvoditelnosti-analiza-indeksa-v-sluchae-bolshogo-mnozhestva-v-sektsii-in}

Нужно всем (Zen, БК, DataLens, TestEnv…). Антон Попов, Q1/Q2.

Upd. Антон делает эту задачу. Большая часть уже реализована.

### 21.4. Использование ORDER BY ключа для оптимизации GROUP BY и DISTINCT {#ispolzovanie-order-by-kliucha-dlia-optimizatsii-group-by-i-distinct}

Дмитрий Рубашкин, ВШЭ. Помогает Антон Попов.

Если таблица имеет ключ сортировки, то возможно эффективное чтение упорядоченных данных. Если запрос содержит операцию GROUP BY, содержащую по крайней мере префикс от ключа сортировки таблицы, либо инъективные функции от него, то возможно более эффективное выполнение GROUP BY: промежуточный результат агрегации финализируется и отправляется клиенту как только в потоке данных при чтении из таблицы встретился следующий ключ.

Аналогичную оптимизацию следует реализовать для DISTINCT и LIMIT BY.

В прошлом году, аналогичное решение сделали для операции ORDER BY.

Upd. Есть pull request для GROUP BY. Приличные результаты.
Upd. Для GROUP BY готово, в процессе для DISTINCT.
Upd. Для DISTINCT есть pull request.

### 21.5. + Распараллеливание INSERT при INSERT SELECT, если это необходимо {#rasparallelivanie-insert-pri-insert-select-esli-eto-neobkhodimo}

[Vxider](https://github.com/Vxider), ICT
Есть pull request.

### 21.6. + Уменьшение числа потоков для SELECT в случае тривиального INSERT SELECT {#umenshenie-chisla-potokov-dlia-select-v-sluchae-trivialnogo-insert-select}

ucasFL, в разработке. Готово.

### 21.7. Кэш результатов запросов {#kesh-rezultatov-zaprosov}

[Achimbab](https://github.com/achimbab).
Есть pull request. Но это не совсем то.
Upd. В обсуждении.
Upd. Назначено на 2021.

### 21.8. Взаимная интеграция аллокатора и кэша {#vzaimnaia-integratsiia-allokatora-i-kesha}

Михаил Кот, ВШЭ. Задача сложная и рискованная.

Для выделения памяти, аллокаторы запрашивают её у операционной системы (`mmap`). Это возможно только для достаточно крупных кусков памяти является довольно медленной операцией. Поэтому, современные аллокаторы кэшируют крупные куски памяти в программе. При вызове free, кусок памяти, как правило, не отдаётся ОС, а остаётся для последующего переиспользования. Для выделения мелких кусков памяти, крупные куски разбиваются с помощью специальных структур данных (free-list, heap, bitmap). Для уменьшения contention в многопоточных программах, эти структуры также делаются thread-локальными.

Часто в программе есть кэши некоторых данных. Например - кэш данных после разжатия, использующийся чтобы сэкономить на повторных запросах одних и тех же данных. При вытеснении из кэша, блок данных освобождается (`free`) и данные, бывшие в кэше, становятся недоступными для переиспользования. Но если принимать во внимание то, как работает аллокатор памяти, то оказывается, что после освобождения памяти, данные всё ещё остаются доступными в программе. И если этот кусок памяти не будет выделен аллокатором снова, его можно было бы продолжить использовать в качестве кэша. Иными словами, в программе есть domain-specific кэш, а аллокатор имеет свой кэш, и они не знают друг о друге.

Для domain-specific кэшей (как например, кэш разжатых данных) выгодно, чтобы они использовали как можно больший объём свободной памяти. Но в этом случае, памяти может не хватить для других структур данных в программе. Если аллокатор памяти знает про кэш, то выделение памяти можно было бы делать путём вытеснения данных из кэша.

Upd. Есть нерабочий прототип, скорее всего будет отложено.
Upd. Отложено до осени.
Upd. Отложено до.
Upd. Отложено.

### 21.8.1. Отдельный аллокатор для кэшей с ASLR {#otdelnyi-allokator-dlia-keshei-s-aslr}

В прошлом году задачу пытался сделать Данила Кутенин с помощью lfalloc из Аркадии и mimalloc из Microsoft, но оба решения не были квалифицированы для использования в продакшене. Успешная реализация задачи 21.8 отменит необходимость в этой задаче, поэтому холд.

Upd. Ещё попробовали новый tcmalloc, результаты неудовлетворительные. Пока отменено.

### 21.9. Исправить push-down выражений с помощью Processors {#ispravit-push-down-vyrazhenii-s-pomoshchiu-processors}

[Николай Кочетов](https://github.com/KochetovNicolai). Требует 2.1.

### 21.10. + Улучшение эвристики PREWHERE {#uluchshenie-evristiki-prewhere}

Amos Bird.

### 21.11. + Peephole оптимизации запросов {#peephole-optimizatsii-zaprosov}

Руслан Камалов, Михаил Малафеев, Виктор Гришанин, ВШЭ

Реализовать в ClickHouse оптимизации запросов, основанные на упрощении отдельных небольших кусков выражений (так называемые «peephole» оптимизации). Примеры:
- Замена цепочек if на multiIf.
- Удаление min/max/any-агрегатов от выражений от ключей GROUP BY.
- Вынесение арифметических операций из агрегатных функций;
- Вынесение любых функций наружу any, anyLast.
- При GROUP BY по transform или if по строкам, замена строк на Enum.

Сделана замена цепочек if на multiIf, но внезапно оказалось, что это является не оптимизацией, а наоборот.
Сделано ещё несколько оптимизаций.
Upd. Все вышеперечисленные оптимизации доступны в pull requests.
Upd. Из них почти все помержены, осталась одна.
Upd. Помержили всё.

### 21.12. + Алгебраические оптимизации запросов {#algebraicheskie-optimizatsii-zaprosov}

Руслан Камалов, Михаил Малафеев, Виктор Гришанин, ВШЭ

Реализовать в ClickHouse оптимизации запросов, основанные на алгебраических свойствах функций. Примеры:
- Обращение инъективных функций в сравнениях на равенство.
- Вынесение инъективных функцию наружу uniq.
- Удаление монотонных функций из ORDER BY.
- Удаление избыточных выражений из ORDER BY.
- Удаление из GROUP BY функций от других ключей GROUP BY.
- Удаление дублирующихся DISTINCT, ORDER BY из подзапросов.

Несколько оптимизаций есть в PR.
Upd. Все оптимизации кроме "Обращение инъективных функций в сравнениях на равенство" есть в PR.
Upd. Из них больше половины помержены, осталось ещё две.
Upd. Помержили всё.

### 21.13. Fusion агрегатных функций {#fusion-agregatnykh-funktsii}

После или совместно с 21.11.

### 21.14. Оптимизация запросов с помощью constraints {#optimizatsiia-zaprosov-s-pomoshchiu-constraints}

Constraints позволяют задать выражение, истинность которого проверяется при вставке данных в таблицу. Предположение о том, что выражение истинно, может использоваться и для оптимизации запросов. Например, встретив в запросе точно такое же выражение, можно заменить его на константу 1.

Если выражение содержит равенство, то встретив в запросе одну из частей равенства, её можно заменить на другую часть равенства, если это сделает проще чтение данных или вычисление выражения. Например, задан constraint: `URLDomain = domain(URL)`. Значит, выражение `domain(URL)` можно заменить на `URLDomain`.

Upd. Возможно будет отложено на следующий год.
Отложено на следующий год.

### 21.15. Многоступенчатое чтение данных вместо PREWHERE {#mnogostupenchatoe-chtenie-dannykh-vmesto-prewhere}

Требует 2.1 и 21.10.

### 21.16. Оптимизация GROUP BY с большим количеством агрегатных функций путём вычисления в два прохода {#optimizatsiia-group-by-s-bolshim-kolichestvom-agregatnykh-funktsii-putiom-vychisleniia-v-dva-prokhoda}

Нужно для БК.

### 21.17. Оптимизация GROUP BY при наличии ORDER BY по тем же ключам с LIMIT {#optimizatsiia-group-by-pri-nalichii-order-by-po-tem-zhe-kliucham-s-limit}

Нужно для БК.

### 21.18. Внутренняя параллелизация мержа больших состояний агрегатных функций {#vnutrenniaia-parallelizatsiia-merzha-bolshikh-sostoianii-agregatnykh-funktsii}

### 21.19. + Оптимизация сортировки {#optimizatsiia-sortirovki}

Василий Морозов, Арслан Гумеров, Альберт Кидрачев, ВШЭ.
В прошлом году задачу начинал делать другой человек, но не добился достаточного прогресса.
Upd. Сделаны самые существенные из предложенных вариантов.

\+ 1.  Оптимизация top sort.

В ClickHouse используется неоптимальный вариант top sort. Суть его в том, что из каждого блока достаётся top N записей, а затем, все блоки мержатся. Но доставание top N записей у каждого следующего блока бессмысленно, если мы знаем, что из них в глобальный top N войдёт меньше. Конечно нужно реализовать вариацию на тему priority queue (heap) с быстрым пропуском целых блоков, если ни одна строка не попадёт в накопленный top.

\+ 2.  Рекурсивный вариант сортировки по кортежам.

Для сортировки по кортежам используется обычная сортировка с компаратором, который в цикле по элементам кортежа делает виртуальные вызовы `IColumn::compareAt`. Это неоптимально - как из-за короткого цикла по неизвестному в compile-time количеству элементов, так и из-за виртуальных вызовов. Чтобы обойтись без виртуальных вызовов, есть метод `IColumn::getPermutation`. Он используется в случае сортировки по одному столбцу. Есть вариант, что в случае сортировки по кортежу, что-то похожее тоже можно применить… например, сделать метод `updatePermutation`, принимающий аргументы offset и limit, и допереставляющий перестановку в диапазоне значений, в которых предыдущий столбец имел равные значения.

\+ 3.  RadixSort для сортировки.

Один наш знакомый начал делать задачу по попытке использования RadixSort для сортировки столбцов. Был сделан вариант indirect сортировки (для `getPermutation`), но не оптимизирован до конца - есть лишние ненужные перекладывания элементов. Для того, чтобы его оптимизировать, придётся добавить немного шаблонной магии (на последнем шаге что-то не копировать, вместо перекладывания индексов - складывать их в готовое место). Также этот человек добавил метод MSD Radix Sort для реализации radix partial sort. Но даже не проверил производительность.

Наиболее содержательная часть задачи может состоять в применении Radix Sort для сортировки кортежей, расположенных в оперативке в виде Structure Of Arrays неизвестного в compile-time размера. Это может работать хуже, чем то, что описано в пункте 2… Но попробовать не помешает.

4.  Three-way comparison sort.

Виртуальный метод `compareAt` возвращает -1, 0, 1. Но алгоритмы сортировки сравнениями обычно рассчитаны на `operator<` и не могут получить преимущества от three-way comparison. А можно ли написать так, чтобы преимущество было?

\+ 5.  pdq partial sort

Upd. Данила Кутенин решил эту задачу ультимативно, используя Floyd–Rivest алгоритм.

Хороший алгоритм сортировки сравнениями `pdqsort` не имеет варианта partial sort. Заметим, что на практике, почти все сортировки в запросах ClickHouse являются partial_sort, так как `ORDER BY` почти всегда идёт с `LIMIT`. Кстати, Данила Кутенин уже попробовал это и показал, что в тривиальном случае преимущества нет. Но не очевидно, что нельзя сделать лучше.

### 21.20. Использование материализованных представлений для оптимизации запросов {#ispolzovanie-materializovannykh-predstavlenii-dlia-optimizatsii-zaprosov}

В ByteDance есть готовая реализация, но они её боятся из-за, возможно, низкого качества кода.
Upd. Вместо этого будем делать задачу 1.16.

### 21.21. + Чтение больших файлов с помощью mmap {#chtenie-bolshikh-failov-s-pomoshchiu-mmap}

Сделан вариант, но достаточно топорный. Без тестирования в продакшене включать по-умолчанию нельзя.

### 21.22. Userspace page cache {#userspace-page-cache}

Требует 21.8.
Отложено.

### 21.23. + Ускорение работы с вторичными индексами {#uskorenie-raboty-s-vtorichnymi-indeksami}

zhang2014.
Есть pull request.
Готово.


## 22. Долги и недоделанные возможности {#dolgi-i-nedodelannye-vozmozhnosti}

### 22.1. + Исправление неработающих таймаутов, если используется TLS {#ispravlenie-nerabotaiushchikh-taimautov-esli-ispolzuetsia-tls}

Нужно для Яндекс.Облака. Сделал Алексей Миловидов.

### 22.2. + Убрать возможность изменить настройки в native протоколе в случае readonly {#ubrat-vozmozhnost-izmenit-nastroiki-v-native-protokole-v-sluchae-readonly}

N.Vartolomei.

### 22.3. + Защита от абсурдно заданных пользователем кодеков {#zashchita-ot-absurdno-zadannykh-polzovatelem-kodekov}

### 22.4. + Исправление оставшихся deadlocks в табличных RWLock-ах {#ispravlenie-ostavshikhsia-deadlocks-v-tablichnykh-rwlock-akh}

Александр Казаков. Нужно для Яндекс.Метрики и Datalens. Задача постепенно тащится и исправлениями в соседних местах стала менее актуальна.
В Q1 будет сделана или отменена с учётом 1.2. и 1.3.
Upd. Добавили таймауты.

### 22.5. + Исправление редких срабатываний TSan в stress тестах в CI {#ispravlenie-redkikh-srabatyvanii-tsan-v-stress-testakh-v-ci}

Александр Казаков сделал эту задачу.

### 22.6. + Изменение только DEFAULT в ALTER TABLE может поменять тип столбца {#izmenenie-tolko-default-v-alter-table-mozhet-pomeniat-tip-stolbtsa}

Александр Сапин сделал эту задачу.

### 22.7. + Row-Level Security не работает в случае наличия в запросе IN подзапросов {#row-level-security-ne-rabotaet-v-sluchae-nalichiia-v-zaprose-in-podzaprosov}

Нужно для Метрики. Иван Лежанкин.

### 22.8. + Исправить десериализацию параметров для параметризованных запросов {#ispravit-deserializatsiiu-parametrov-dlia-parametrizovannykh-zaprosov}

Хотел исправить Василий Немков, Altinity, но есть маленькие затруднения, наверное переделает Алексей Миловидов.

### 22.9. Разобраться с десериализацией массивов со значениями по-умолчанию в Protobuf формате в случае protobuf 3 {#razobratsia-s-deserializatsiei-massivov-so-znacheniiami-po-umolchaniiu-v-protobuf-formate-v-sluchae-protobuf-3}

[Виталий Баранов](https://github.com/vitlibar). Возможно, это - фундаментальная проблема и следует её только документировать.
Кажется, отменяем, но пока ещё не всё ясно.

### 22.10. + Исправление дрифта при отслеживании потребления памяти запросами {#ispravlenie-drifta-pri-otslezhivanii-potrebleniia-pamiati-zaprosami}

Требует 6.3., но можно улучшить отдельными хаками. Нужно Метрике и БК.

### 22.11. + Более простая ser/de настроек запросов {#bolee-prostaia-serde-nastroek-zaprosov}

И пропуск неизвестных настроек. Важно для Метрики для упрощения апгрейда без изменения конфига.
[Виталий Баранов](https://github.com/vitlibar), готово.

### 22.12. + Исправление низкой производительности чтения из Kafka {#ispravlenie-nizkoi-proizvoditelnosti-chteniia-iz-kafka}

Для ClickHouse нехарактерно наличие кода, обладающего столь низкой производительностью. Практики разработки не подразумевают, что такой код должен попасть в продакшен без надлежащего тестирования производительности.

Изначально было назначено на [Ивана Лежанкина](https://github.com/abyss7), но по неизвестной причине было не сделано в течение нескольких месяцев.
Сделал Михаил Филимонов, Altinity.

### 22.13. + Посмотреть, почему не работают некоторые collations {#posmotret-pochemu-ne-rabotaiut-nekotorye-collations}

Изначально было назначено на [Ивана Лежанкина](https://github.com/abyss7), но в результате сделал Александр Сапин.

### 22.14. + Посмотреть, почему не работает StorageSet для MergeTree таблиц при некоторых условиях {#posmotret-pochemu-ne-rabotaet-storageset-dlia-mergetree-tablits-pri-nekotorykh-usloviiakh}

Вроде бы сделал Никита Михайлов - проверить существующие issues на эту тему.

### 22.15. Нормализация коммитов в Kafka и идемпотентности операций {#normalizatsiia-kommitov-v-kafka-i-idempotentnosti-operatsii}

Altinity.
Я не в курсе, какой статус.
Там предлагают очень сложное решение вместо простого.

### 22.16. + Исправление низкой производительности кодека DoubleDelta {#ispravlenie-nizkoi-proizvoditelnosti-kodeka-doubledelta}

Василий Немков, Altinity - в процессе.
Upd. Готово.

### 22.17. Консистентно работающий POPULATE для MaterializedView {#konsistentno-rabotaiushchii-populate-dlia-materializedview}

### 22.18. Исправление заметного падения производительности форматов после добавления доменов типов {#ispravlenie-zametnogo-padeniia-proizvoditelnosti-formatov-posle-dobavleniia-domenov-tipov}

Василий Немков, Altinity.

### 22.19. + Одновременное использование SAMPLE и PREWHERE {#odnovremennoe-ispolzovanie-sample-i-prewhere}

Нужно для Метрики. [Николай Кочетов](https://github.com/KochetovNicolai), ноябрь 2019.

### 22.20. + Неправильная работа PREWHERE при некоторых условиях {#nepravilnaia-rabota-prewhere-pri-nekotorykh-usloviiakh}

[Николай Кочетов](https://github.com/KochetovNicolai), декабрь 2019.

### 22.21. + Неправильное поведение DateTime в районе начала unix epoch {#nepravilnoe-povedenie-datetime-v-raione-nachala-unix-epoch}

Алексей Миловидов.

### 22.22. Nullable в функции transform и в CASE по множеству значений {#nullable-v-funktsii-transform-i-v-case-po-mnozhestvu-znachenii}

После 10.14.

[#7237](https://github.com/ClickHouse/ClickHouse/issues/7237)
[#2655](https://github.com/ClickHouse/ClickHouse/issues/2655)

### 22.23. Правильная обработка Nullable в функциях, которые кидают исключение на default значении: modulo, intDiv {#pravilnaia-obrabotka-nullable-v-funktsiiakh-kotorye-kidaiut-iskliuchenie-na-default-znachenii-modulo-intdiv}

### 22.24. + Излишняя фильтрация ODBC connection string {#izlishniaia-filtratsiia-odbc-connection-string}

Нужно для Метрики. Алексей Миловидов.

### 22.25. + Избавиться от библиотеки btrie {#izbavitsia-ot-biblioteki-btrie}

Владимир Черкасов сделал эту задачу.

### 22.26. Плохая производительность quantileTDigest {#plokhaia-proizvoditelnost-quantiletdigest}

[#2668](https://github.com/ClickHouse/ClickHouse/issues/2668)

Павел Круглов и Илья Щербак (ВК).

### 22.27. Проверить несколько PR, которые были закрыты zhang2014 и sundy-li {#proverit-neskolko-pr-kotorye-byli-zakryty-zhang2014-i-sundy-li}

Алексей Миловидов.

### 22.28. Изучить и исправить поведение работы с Kafka при ребалансировке {#izuchit-i-ispravit-povedenie-raboty-s-kafka-pri-rebalansirovke}

Altinity.

### 22.29. + Уязвимость DDL для словарей executable {#uiazvimost-ddl-dlia-slovarei-executable}

[Александр Сапин](https://github.com/alesapin)


## 23. Default Festival {#default-festival}

### 23.1. + Включение minimalistic_part_header в ZooKeeper {#vkliuchenie-minimalistic-part-header-v-zookeeper}

Сильно уменьшает объём данных в ZooKeeper. Уже год в продакшене в Яндекс.Метрике.
Алексей Миловидов, ноябрь 2019.

### 23.2. Включение distributed_aggregation_memory_efficient {#vkliuchenie-distributed-aggregation-memory-efficient}

Есть риски меньшей производительности лёгких запросов, хотя производительность тяжёлых запросов всегда увеличивается.

### 23.3. Включение min_bytes_to_external_sort и min_bytes_to_external_group_by {#vkliuchenie-min-bytes-to-external-sort-i-min-bytes-to-external-group-by}

Желательно 5.2. и 13.1.

### 23.4. Включение синхронной записи в Distributed таблицы по-умолчанию {#vkliuchenie-sinkhronnoi-zapisi-v-distributed-tablitsy-po-umolchaniiu}

Есть гипотеза, что плохо работает на очень больших кластерах.

### 23.5. Включение compile_expressions {#vkliuchenie-compile-expressions}

Требует 7.2. Задачу изначально на 99% сделал Денис Скоробогатов, ВШЭ и Яндекс. Остальной процент доделывал Алексей Миловидов, а затем [Александр Сапин](https://github.com/alesapin).

### 23.6. + Включение учёта порядка столбцов в CSV {#vkliuchenie-uchiota-poriadka-stolbtsov-v-csv}

Просто аккуратно включить.

### 23.7. Включение NULL as Default в CSV {#vkliuchenie-null-as-default-v-csv}

Просто аккуратно включить.

### 23.8. + Включение оптимизации VALUES {#vkliuchenie-optimizatsii-values}

Просто аккуратно включить.

### 23.9. + Включение Processors {#vkliuchenie-processors}

Q1. [Николай Кочетов](https://github.com/KochetovNicolai).

### 23.10. + Включение mlock бинарника {#vkliuchenie-mlock-binarnika}

Возможность mlock бинарника сделал Олег Алексеенков [#3553](https://github.com/ClickHouse/ClickHouse/pull/3553)
. Поможет, когда на серверах кроме ClickHouse работает много посторонних программ (мы иногда называем их в шутку «треш-программами»).


## 24. Экспериментальные задачи {#eksperimentalnye-zadachi}

### 24.1. Веб-интерфейс для просмотра состояния кластера и профилирования запросов {#veb-interfeis-dlia-prosmotra-sostoianiia-klastera-i-profilirovaniia-zaprosov}

Антон Мамонов, УрФУ, Яндекс.

Внутри ClickHouse есть богатые возможности по интроспекции и профилированию. Эти возможности доступны через системные таблицы и использовать их приходится путём формулирования SQL запросов. Это неудобно.

Вместо этого предлагается сделать, чтобы ClickHouse отдавал HTML страницу, реализующую интерактивный web-интерфейс со следующими возможностями:
- отображение состояния кластеров (какие кластеры известны, статус каждого сервера);
- графики нагрузки текущего сервера или выбранного сервера кластера;
- обновляемый список запросов;
- просмотр лога запросов с наиболее востребованными фильтрациями по одной кнопке;
- просмотр лога на кластере, например - последние ошибки;
- просмотр метрик использования ресурсов, flame graph и pprof-граф для выбранных запросов;
- отчёт по использованию кластера (пример: количество ядер CPU по пользователям за сегодня).

### 24.2. Экспериментальные алгоритмы сжатия {#eksperimentalnye-algoritmy-szhatiia}

Отложено.

ClickHouse поддерживает LZ4 и ZSTD для сжатия данных. Эти алгоритмы являются парето-оптимальными по соотношению скорости и коэффициентам сжатия среди достаточно известных. Тем не менее, существуют менее известные алгоритмы сжатия, которые могут превзойти их по какому-либо критерию. Из потенциально более быстрых по сравнимом коэффициенте сжатия: Lizard, LZSSE, density. Из более сильных: bsc и csc. Необходимо изучить эти алгоритмы, добавить их поддержку в ClickHouse и исследовать их работу на тестовых датасетах.

### 24.3. - Экспериментальные кодеки {#eksperimentalnye-kodeki}

Существуют специализированные алгоритмы кодирования числовых последовательностей: Group VarInt, MaskedVByte, PFOR. Необходимо изучить наиболее эффективные реализации этих алгоритмов. Примеры вы сможете найти на https://github.com/lemire и https://github.com/powturbo/ а также https://github.com/schizofreny/middle-out

Внедрить их в ClickHouse в виде кодеков и изучить их работу на тестовых датасетах.

Upd. Есть два pull requests в начальной стадии, отложено.
Upd. Отменено.

### 24.4. Шифрование в ClickHouse на уровне VFS {#shifrovanie-v-clickhouse-na-urovne-vfs}

Данные в ClickHouse хранятся без шифрования. При наличии доступа к дискам, злоумышленник может прочитать данные. Предлагается реализовать два подхода к шифрованию:

1.  Шифрование на уровне VFS.

Обсуждаются детали реализации. Q3/Q4.
Виталий Баранов.
Отложено, после бэкапов.

### 24.5. + Поддержка функций шифрования для отдельных значений {#podderzhka-funktsii-shifrovaniia-dlia-otdelnykh-znachenii}

Смотрите также 24.5.

2.  Шифрование отдельных значений.
    Для этого требуется реализовать функции шифрования и расшифрования, доступные из SQL. Для шифрования реализовать возможность добавления нужного количества случайных бит для исключения одинаковых зашифрованных значений на одинаковых данных. Это позволит реализовать возможность «забывания» данных без удаления строк таблицы: можно шифровать данные разных клиентов разными ключами, и для того, чтобы забыть данные одного клиента, потребуется всего лишь удалить ключ.
    
Делает Василий Немков, Altinity
Есть pull request в процессе ревью, исправляем проблемы производительности.
Сейчас в состоянии, что уже добавлено в продакшен, но производительность всё ещё низкая (тех долг).

### 24.6. Userspace RAID {#userspace-raid}

Глеб Новиков, ВШЭ.

RAID позволяет одновременно увеличить надёжность хранения данных на дисках и увеличить скорость работы дискового массива. Обычно RAID настраивается с помощью встроенных возможностей ядра Linux (mdraid) или с помощью hardware контроллера. У этого есть следующие ограничения:

1.  Иногда (в облачной инфраструктуре некоторых компаний) сервер предоставляется с отдельными дисками, подмонтированными в виде отдельных разделов (JBOD), без возможности создания RAID.

2.  В ClickHouse для обеспечения избыточности обычно используется репликация между серверами. Но при восстановлении одного из дисков RAID не используются данные с реплик, а в случае отказа одного из дисков в RAID-0, приходится передавать с реплики все данные, а не только данные, соответствующие одному из дисков. Это происходит, потому что RAID не интегрирован в ClickHouse и «не знает» про его особенности.

3.  Отсутствуют продвинутые варианты обеспечения избыточности, как например, LRC.

Для преодоления этих ограничений, предлагается реализовать в ClickHouse встроенный алгоритм расположения данных на дисках.

Есть pull request на начальной стадии.
Отложено.

### 24.7. Вероятностные структуры данных для фильтрации по подзапросам {#veroiatnostnye-struktury-dannykh-dlia-filtratsii-po-podzaprosam}

Рузель Ибрагимов, ВШЭ и Яндекс.

Частой задачей является выполнение запроса с фильтрацией по множеству, полученному по подзапросу. Пример: найти пользователей, которые заходили на сайт сегодня и заходили неделю назад. Это выражается в виде запроса: `SELECT UserID FROM table WHERE EventDate = today() AND UserID IN (SELECT ...)`. При выполнении этого запроса, сначала выполняется подзапрос в правой части `IN` и формируется хэш-таблица в оперативке; затем эта хэш-таблица используется для фильтрации.

Иногда объём данных достаточно большой, и хэш-таблица не помещается в оперативку. В этом случае можно рассмотреть в качестве варианта приближённый рассчёт: найти пользователей, которые заходили на сайт сегодня и наверное заходили неделю назад. Для этого можно вместо хэш-таблицы использовать Bloom Filter. Другая задача: найти пользователей, которые встречались, скорее всего, не менее некоторого количества раз. Для этого можно использовать Counting Bloom Filter. Также следует изучить структуры данных Quotient Filter и Cuckoo Filer, а ещё - секретный алгоритм Chaotic Map от Андрея Плахова.

Предлагается реализовать это в языке запросов ClickHouse с помощью специального синтаксиса, например `x IN BLOOM FILTER (n, m) (SELECT ...)`.

Есть pull request на стадии работающего прототипа.

### 24.8. + Специализация векторизованного кода для AVX/AVX2/AVX512 и ARM NEON {#spetsializatsiia-vektorizovannogo-koda-dlia-avxavx2avx512-i-arm-neon}

[#1017](https://github.com/ClickHouse/ClickHouse/issues/1017)

Дмитрий Ковальков, ВШЭ и Яндекс.

Подавляющее большинство кода ClickHouse написана для x86_64 с набором инструкций до SSE 4.2 включительно. Лишь отдельные редкие функции поддерживают AVX/AVX2/AVX512 с динамической диспетчеризацией.

В первой части задачи, следует добавить в ClickHouse реализации некоторых примитивов, оптимизированные под более новый набор инструкций. Например, AVX2 реализацию генератора случайных чисел pcg: https://github.com/lemire/simdpcg

Во второй части задачи, предлагается адаптировать существующие куски кода, использующие SSE intrinsics на AVX/AVX2 и сравнить производительность. Также рассматривается оптимизация под ARM NEON.

### 24.9. + Общий подход к CPU dispatching в фабрике функций {#obshchii-podkhod-k-cpu-dispatching-v-fabrike-funktsii}

Дмитрий Ковальков, ВШЭ и Яндекс.

Продолжение 24.8.

Upd. Есть pull request. В стадии ревью. Готово.

### 24.10. - Поддержка типов half/bfloat16/unum {#podderzhka-tipov-halfbfloat16unum}

[#7657](https://github.com/ClickHouse/ClickHouse/issues/7657)

Рустам Гусейн-заде, ВШЭ.

Есть pull request на промежуточной стадии.
Отложено.
Отменено.

### 24.11. User Defined Functions {#user-defined-functions}

Игорь Минеев, ВШЭ.

ClickHouse предоставляет достаточно богатый набор встроенных функций языка запросов, но не позволяет пользователю добавлять свои функции без редактировния исходников и перекомпиляции системы. Это мотивировано следующими потенциальными проблемами:

1.  ClickHouse является array-oriented системой, и все функции внутри кода принимают для обработки целые массивы, а не отдельные значения. Это усложняет внутренний интерфейс и делает его менее удобным для пользователя.
2.  Предоставление возможности подключения UDF в виде shared библиотек, потребовало бы фиксировать этот интерфейс или поддерживать обратную совместимость, тогда как мы бы хотели, при разработке ClickHouse, менять этот интерфейс по своему усмотрению без оглядки.
3.  Сложность внутренних структур данных повышает вероятность ошибок типа buffer overflow и повреждения памяти, что сильно затруднит сопровождение ClickHouse с пользовательскими функциями.

Тем не менее, можно выбрать более аккуратный подход, избегающий непосредственной линковки с shared библиотеками.

Сначала можно реализовать поддержку UDF в виде выражений, составленных из простых функций ClickHouse. В ClickHouse есть встроенная кодогенерация на LLVM, что позволит таким функциям работать весьма эффективно. Но этот подход весьма ограничен и поэтому не является исчерпывающим.

Затем предлагается реализовать поддержку UDF в виде исходников на C++, которые компилируются в runtime, с использованием заголовочных файлов ClickHouse. Требование компиляции из исходников вместо shared библиотек, позволит ослабить необходимость в поддержке совместимости ABI.

Для безопасности, потребуется исследовать возможность размещения буферов данных в shared memory для выполнения UDF в отдельных процессах с изоляцией по памяти. Возможно, для этого пригодится интеграция с Apache Arrow.

Также рассматривается возможность написания UDF на Rust, а также использование Web Assembly. Отдельно можно рассмотреть подключение NumPy и R и других технологий, которые предоставляют операции над целыми массивами.

Upd. В работе два варианта реализации UDF.

### 24.12. - GPU offloading {#gpu-offloading}

Риск состоит в том, что даже известные GPU базы, такие как OmniSci, работают медленнее, чем ClickHouse.
Преимущество возможно только на полной сортировке и JOIN.
Алексей Соловей, nVidia и Рита Коннова, ВШЭ.

В компании nVidia сделали прототип offloading вычисления GROUP BY с некоторыми из агрегатных функций в ClickHouse и обещат предоставить исходники в публичный доступ для дальнейшего развития. Предлагается изучить этот прототип и расширить его применимость для более широкого сценария использования. В качестве альтернативы, предлагается изучить исходные коды системы `OmniSci` или `Alenka` или библиотеку `CUB` https://nvlabs.github.io/cub/ и применить некоторые из алгоритмов в ClickHouse.

Upd. В компании nVidia выложили прототип, теперь нужна интеграция в систему сборки.
Upd. Интеграция в систему сборки - Иван Лежанкин (не сделано).
Upd. Есть прототип bitonic sort.
Upd. Прототип bitonic sort помержен, но целесообразность под вопросом (он работает медленнее).
Наверное надо будет подержать и удалить.
Удалили.

### 24.13. Stream запросы {#stream-zaprosy}

Пререквизит для ClickHouse как CEP-системы.

### 24.14. Window функции {#window-funktsii}

[#1469](https://github.com/ClickHouse/ClickHouse/issues/1469)

Требует 2.1.

Upd. Есть два прототипа от внешних контрибьюторов.
Александр Кузьменков.

### 24.15. Поддержка полуструктурированных данных {#podderzhka-polustrukturirovannykh-dannykh}

Требует 1.14 и 2.10.
Антон Попов.

### 24.16. Улучшение эвристики слияний {#uluchshenie-evristiki-sliianii}

В прошлом году исследование по этой задаче сделал Егор Соловьёв, ВШЭ и Яндекс.Такси. Его исследование показало, что алгоритм нельзя существенно улучшить путём изменения параметров. Но исследование лажовое, так как рассмотрен только уже использующийся алгоритм. То есть, задача остаётся открытой.

Отложено.

### 24.17. Экспериментальные способы ускорения параллельного GROUP BY {#eksperimentalnye-sposoby-uskoreniia-parallelnogo-group-by}

Максим Серебряков

Задача в работе.
Upd. Достигнуты обнадёживающие результаты.
Upd. Есть pull request - в большинстве случаев одновременно и ускорение и снижение потребления памяти, но требуются доработки.

### 24.18. Не TCP протокол передачи файлов при репликации {#ne-tcp-protokol-peredachi-failov-pri-replikatsii}

### 24.19. Промежуточное состояние GROUP BY как структура данных для key-value доступа {#promezhutochnoe-sostoianie-group-by-kak-struktura-dannykh-dlia-key-value-dostupa}

Отложено.

### 24.20. Short-circuit вычисления некоторых выражений {#short-circuit-vychisleniia-nekotorykh-vyrazhenii}

Два года назад задачу попробовала сделать Анастасия Царькова, ВШЭ и Яндекс, но реализация получилась слишком неудобной и её удалили.
В обсуждении.

### 24.21. Реализация в ClickHouse протокола распределённого консенсуса {#realizatsiia-v-clickhouse-protokola-raspredelionnogo-konsensusa}

Имеет смысл только после 19.2.
Александр Сапин.

### 24.22. Вывод типов по блоку данных. Вывод формата данных по примеру {#vyvod-tipov-po-bloku-dannykh-vyvod-formata-dannykh-po-primeru}

Задача отложена.

ClickHouse является строго типизированной системой. Для того, чтобы прочитать данные в каком либо формате (например, CSV), требуется заранее указать типы данных. Если при чтении формата выясняется, что данные не могут быть прочитаны в рамках заданных типов, то кидается исключение.

ClickHouse также может использоваться для быстрой аналитики по локальным файлам, без загрузки их в базу данных (программа `clickhouse-local`). В этом случае, его использование может заменить `awk`, `sed`, `grep`. Но остаётся неудобство - необходимость указания типов данных.

Предлагается реализовать функциональность вывода типов по первому блоку данных путём применения эвристик и постепенного расширения типов.

Другая экспериментальная задача - реализация эвристик для обработки данных в неизвестном построчном текстовом формате. Детектирование CSV, TSV, JSON, детектирование разделителей и форматов значений.

### 24.23. - Минимальная поддержка транзакций для множества вставок/чтений {#minimalnaia-podderzhka-tranzaktsii-dlia-mnozhestva-vstavokchtenii}

Максим Кузнецов, ВШЭ.
Отменено.

Таблицы типа MergeTree состоят из набора независимых неизменяемых «кусков» данных. При вставках данных (INSERT), формируются новые куски. При модификациях данных (слияние кусков), формируются новые куски, а старые - становятся неактивными и перестают использоваться следующими запросами. Чтение данных (SELECT) производится из снэпшота множества кусков на некоторый момент времени. Таким образом, чтения и вставки не блокируют друг друга.

Если же выполняется несколько запросов SELECT, то чтение данных может осуществляться из снэпшотов по состоянию на несколько разных моментов времени и быть неконсистентным. Пример: пользователю отображается отчёт из нескольких графиков и таблиц, но из-за того, что между разными запросами, данные успели обновиться, отображаемые данные не соответствуют друг другу.

Пример с другой стороны - пользователь хочет осуществить несколько вставок (INSERT) в одну или несколько таблиц, но так, чтобы данные появились в них атомарно с точки зрения других запросов (SELECT).

Для решения этих проблем, предлагается ввести глобальные метки времени для кусков данных (сейчас уже есть инкрементальные номера кусков, но они выделяются в рамках одной таблицы). Первым шагом сделаем эти метки времени в рамках сервера. Вторым шагом сделаем метки времени в рамках всех серверов, но неточные на основе локальных часов. Третьим шагом сделаем метки времени, выдаваемые сервисом координации.

### 24.24. - Реализация алгоритмов differential privacy {#realizatsiia-algoritmov-differential-privacy}

[#6874](https://github.com/ClickHouse/ClickHouse/issues/6874)

Артём Вишняков, ВШЭ. Есть pull request.
Отменено, так как решение имеет низкую практичность.

### 24.25. Интеграция в ClickHouse функциональности обработки HTTP User Agent {#integratsiia-v-clickhouse-funktsionalnosti-obrabotki-http-user-agent}

[#157](https://github.com/ClickHouse/ClickHouse/issues/157)
Есть хороший код в Яндекс.Метрике. Получено согласие от руководства.
Михаил Филитов, ВШЭ.
Upd. Есть pull request. Нужно ещё чистить код библиотеки.

### 24.26. + Поддержка open tracing или аналогов {#podderzhka-open-tracing-ili-analogov}

[#5182](https://github.com/ClickHouse/ClickHouse/issues/5182)

Александр Кожихов, ВШЭ и Яндекс.YT.
Upd. Есть pull request с прототипом.
Upd. Александ Кузьменков взял задачу в работу.
Сделано.

### 24.27. Реализация алгоритмов min-hash, sim-hash для нечёткого поиска полудубликатов {#realizatsiia-algoritmov-min-hash-sim-hash-dlia-nechiotkogo-poiska-poludublikatov}

[#7649](https://github.com/ClickHouse/ClickHouse/pull/7649)

ucasFL, ICT.

Алгоритмы min-hash и sim-hash позволяют вычислить для текста несколько хэш-значений таких, что при небольшом изменении текста, по крайней мере один из хэшей не меняется. Вычисления можно реализовать на n-грамах и словарных шинглах. Предлагается добавить поддержку этих алгоритмов в виде функций в ClickHouse и изучить их применимость для задачи нечёткого поиска полудубликатов.

Есть pull request, есть что доделывать.
Upd. Николай Кочетов взял задачу в работу.

### 24.28. Другой sketch для квантилей {#drugoi-sketch-dlia-kvantilei}

Похоже на quantileTiming, но с логарифмическими корзинами. См. DDSketch.
Отложено.

### 24.29. Поддержка Arrow Flight {#podderzhka-arrow-flight}

[#7554](https://github.com/ClickHouse/ClickHouse/issues/7554)

Жанна Зосимова, ВШЭ.
Upd. Пока поддержали Arrow как формат ввода-вывода.

### 24.30. - ClickHouse как графовая СУБД {#clickhouse-kak-grafovaia-subd}

Amos Bird, но его решение слишком громоздкое и пока не open-source. Отменено.

### 24.31. Кореллированные подзапросы {#korellirovannye-podzaprosy}

Перепиcывание в JOIN. Не раньше 21.11, 21.12, 21.9. Низкий приоритет.
Отложено.

### 24.32. + Поддержка GRPC {#podderzhka-grpc}

Мария Конькова, ВШЭ и Яндекс.
Также смотрите 24.29.

В ClickHouse есть два основных протокола: родной протокол общения между серверами и HTTP/1.1 протокол. HTTP/1.1 протокол удобен для работы из самых разных языков программирования, но, в отличие от родного протокола, не поддерживает двусторонний обмен информацией во время запроса:
- передачу информации о прогрессе во время выполнения запроса;
- передачу логов во время выполнения запроса;
- отмену выполнения запроса в тот момент как данные ещё не начали передаваться;

Рассматривается вариант - поддержка GRPC в ClickHouse. Здесь есть неочевидные моменты, такие как - эффективная передача массивов данных в column-oriented формате - насколько удобно будет обернуть это в GRPC.

Задача в работе, есть pull request. [#10136](https://github.com/ClickHouse/ClickHouse/pull/10136)
Upd. Задачу взял в работу Виталий Баранов.
Сделано.


## 25. DevRel {#devrel}

### 25.1. + Перевод инструкции для начинающих разработчиков {#perevod-instruktsii-dlia-nachinaiushchikh-razrabotchikov}

Александр Казаков, ноябрь 2019.

### 25.2. + Вычитка и выкладка статьи про обфускацию данных на английском {#vychitka-i-vykladka-stati-pro-obfuskatsiiu-dannykh-na-angliiskom}

Эми, Александр Казаков, Алексей Миловидов, Q1.
Готово к выкладке.

### 25.3. Подготовка статьи «Секреты оптимизации производительности ClickHouse» {#podgotovka-stati-sekrety-optimizatsii-proizvoditelnosti-clickhouse}

Алексей Миловидов, Леонид.

### 25.4. Подготовка статьи «Профайлер запросов: трудный путь» {#podgotovka-stati-profailer-zaprosov-trudnyi-put}

Алексей Миловидов, Леонид.

### 25.5. Подготовка статьи «Тестирование ClickHouse, которое мы заслужили» {#podgotovka-stati-testirovanie-clickhouse-kotoroe-my-zasluzhili}

### 25.6. Перевод этих статей на английский {#perevod-etikh-statei-na-angliiskii}

Требует 25.3, 25.4, 25.5. Эми

### 25.7. Перевод статьи Данилы Кутенина на английский {#perevod-stati-danily-kutenina-na-angliiskii}

Эми

### 25.8. + Выступление keynote на BDTC {#vystuplenie-keynote-na-bdtc}

Алексей Миловидов

### 25.9. Подготовка докладчиков: khvostikao, ilezhankin, nikitamikhailov, akuzm и другие {#podgotovka-dokladchikov-khvostikao-ilezhankin-nikitamikhailov-akuzm-i-drugie}

[Ольга Хвостикова](https://github.com/stavrolia), [Иван Лежанкин](https://github.com/abyss7), Никита Михайлов, [Александр Кузьменков](https://github.com/akuzm), Артём Зуйков.
Уже готовые докладчики: Алексей Миловидов, [Николай Кочетов](https://github.com/KochetovNicolai), [Александр Сапин](https://github.com/alesapin).
Получаем минимум 8 докладчиков в 2020 году.

### 25.10. Митапы в России и Беларуси: Москва x2 + митап для разработчиков или хакатон, Санкт-Петербург, Минск, Нижний Новгород, Екатеринбург, Новосибирск и/или Академгородок, Иннополис или Казань {#mitapy-v-rossii-i-belarusi-moskva-x2-mitap-dlia-razrabotchikov-ili-khakaton-sankt-peterburg-minsk-nizhnii-novgorod-ekaterinburg-novosibirsk-iili-akademgorodok-innopolis-ili-kazan}

Екатерина - организация. Upd. Проведено два онлайн митапа на русском и два на английском.

### 25.11. + Митапы зарубежные: восток США (Нью Йорк, возможно Raleigh), возможно северо-запад (Сиэтл), Китай (Пекин снова, возможно митап для разработчиков или хакатон), Лондон {#mitapy-zarubezhnye-vostok-ssha-niu-iork-vozmozhno-raleigh-vozmozhno-severo-zapad-sietl-kitai-pekin-snova-vozmozhno-mitap-dlia-razrabotchikov-ili-khakaton-london}

[Иван Блинков](https://github.com/blinkov/) - организация. Две штуки в США запланированы. Upd. Два митапа в США и один в Европе проведены. Upd. Все остальные перенесены в онлайн.

### 25.12. Статья «научная» - про устройство хранения данных и индексов или whitepaper по архитектуре. Есть вариант подать на VLDB {#statia-nauchnaia-pro-ustroistvo-khraneniia-dannykh-i-indeksov-ili-whitepaper-po-arkhitekture-est-variant-podat-na-vldb}

Низкий приоритет. Алексей Миловидов.

### 25.13. + Участие во всех мероприятиях Яндекса, которые связаны с разработкой бэкенда, C++ разработкой или с базами данных, возможно участие в DevRel мероприятиях {#uchastie-vo-vsekh-meropriiatiiakh-iandeksa-kotorye-sviazany-s-razrabotkoi-bekenda-c-razrabotkoi-ili-s-bazami-dannykh-vozmozhno-uchastie-v-devrel-meropriiatiiakh}

Алексей Миловидов и все подготовленные докладчики.
Upd. Участвуем.

### 25.14. + Конференции в России: все HighLoad, возможно CodeFest, DUMP или UWDC, возможно C++ Russia {#konferentsii-v-rossii-vse-highload-vozmozhno-codefest-dump-ili-uwdc-vozmozhno-c-russia}

Алексей Миловидов и все подготовленные докладчики.
Upd. Есть Saint HighLoad online.
Upd. Есть C++ Russia.
CodeFest, DUMP, UWDC отменились.
Upd. Добавились Highload Fwdays, Матемаркетинг.
Upd. Добавились подкасты C++ Russia.

### 25.15. Конференции зарубежные: Percona, DataOps, попытка попасть на более крупные {#konferentsii-zarubezhnye-percona-dataops-popytka-popast-na-bolee-krupnye}

Алексей Миловидов и все подготовленные докладчики
Upd. Есть Percona.
DataOps отменилась.

### 25.16. Сайт play.clickhouse {#sait-play-clickhouse}

Цель состоит в реализации сайта, на котором можно попробовать задавать произвольные запросы к временному экземпляру ClickHouse и изучать его поведение. Из похожих проектов можно отметить: [Compiler Explorer](https://godbolt.org/), http://ideone.com/, [SQLFiddle](http://sqlfiddle.com/), [DB-Fiddle](https://www.db-fiddle.com/).

С помощью такого сайта можно решать следующие задачи:
- ознакомление с языком запросов ClickHouse;
- демонстрация примеров из документации;
- демонстрация скорости работы на тестовых датасетах;
- сравнение поведения разных версий ClickHouse друг с другом;
- демонстрация неожиданного поведения или багов;

Требуется проработать вопрос безопасности и изоляции инстансов (поднятие в контейнерах с ограничениями по сети), подключение тестовых датасетов с помощью copy-on-write файловой системы; органичения ресурсов.

Есть минимальный прототип. Сделал Илья Яцишин. Этот прототип не позволяет делиться ссылками на результаты запросов.
Upd. На финальной стадии инструмент для экспериментирования с разными версиями ClickHouse.
Upd. По факту, задача считается не сделанной (готово только 99%, не 100%).

### 25.17. Взаимодействие с ВУЗами: ВШЭ, УрФУ, ICT Beijing {#vzaimodeistvie-s-vuzami-vshe-urfu-ict-beijing}

Алексей Миловидов и вся группа разработки.
Благодаря Robert Hodges добавлен CMU.
Upd. Взаимодействие с ВШЭ 2019/2020 успешно выполнено.
Upd. Идёт подготовка к 2020/2021.
Upd. Уже взяли несколько десятков человек на 2020/2021.

### 25.18. - Лекция в ШАД {#lektsiia-v-shad}

Алексей Миловидов.

### 25.19. - Участие в курсе разработки на C++ в ШАД {#uchastie-v-kurse-razrabotki-na-c-v-shad}

### 25.20. Ещё одно сравнение производительности аналитических СУБД {#eshchio-odno-sravnenie-proizvoditelnosti-analiticheskikh-subd}

Матвей Бубнов, УрФУ

Существуют мало известные специализированные СУБД, способные конкурировать с ClickHouse по скорости обработки некоторых классов запросов. Пример: `TDEngine` и `DolphinDB`, `VictoriaMetrics`, а также `Apache Doris` и `LocustDB`. Предлагается изучить и классифицировать архитектурные особенности этих систем - их особенности и преимущества. Установить эти системы, загрузить тестовые данные, изучить производительность. Проанализировать, за счёт чего достигаются преимущества.

Upd. Есть поползновения с TDEngine.
Upd. Добавили OmniSci, обновили MonetDB.
Также посмотрели QuestDB и VectorSQL (они не работают).

### 25.21. Повторное награждение контрибьюторов в Китае {#povtornoe-nagrazhdenie-kontribiutorov-v-kitae}

Upd. Ждём снятия ограничений и восстановления активности по онлайн митапам.

### 25.22. On-site помощь с ClickHouse компаниям в дни рядом с мероприятиями {#on-site-pomoshch-s-clickhouse-kompaniiam-v-dni-riadom-s-meropriiatiiami}

[Иван Блинков](https://github.com/blinkov/) - организация. Провёл мероприятие для турецкой компании.
Upd. On-site заменяется на Online.
Upd. Проведены консультации для нескольких секретных компаний.

### 25.23. Новый мерч для ClickHouse {#novyi-merch-dlia-clickhouse}

Upd. Старого пока хватает, раздача уменьшилась.

### 25.24. Конкурсы bughunter или оптимизации кода на C++ {#konkursy-bughunter-ili-optimizatsii-koda-na-c}

Проведение конкурсов должно начинаться для сотрудников Яндекса, пока нет согласования.

### 25.25. Семинары для потенциальных клиентов Яндекс.Облака {#seminary-dlia-potentsialnykh-klientov-iandeks-oblaka}

По мере необходимости. Алексей Миловидов, организация - Яндекс.Облако.

### 25.26. - Участие в GSoC {#uchastie-v-gsoc}

Андрей Бородин пытается уговорить нас участвовать, но пока загружены задачей 25.17.

UPD: не участвуем.

### 25.27. + Обновить сайт ClickHouse {#obnovit-sait-clickhouse}

Иван Блинков. Нет рисков. Нужно для Яндекс.Облака. Upd. Сделано.
