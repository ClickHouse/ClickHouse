# Generated by Grammarinator 19.3

from itertools import chain
from grammarinator.runtime import *

charset_0 = list(chain(*multirange_diff(printable_unicode_ranges, [(92, 93),(92, 93)])))
charset_1 = list(chain(range(32, 33), range(11, 12), range(12, 13), range(9, 10), range(13, 14), range(10, 11)))
charset_2 = list(chain(range(97, 98), range(65, 66)))
charset_3 = list(chain(range(98, 99), range(66, 67)))
charset_4 = list(chain(range(99, 100), range(67, 68)))
charset_5 = list(chain(range(100, 101), range(68, 69)))
charset_6 = list(chain(range(101, 102), range(69, 70)))
charset_7 = list(chain(range(102, 103), range(70, 71)))
charset_8 = list(chain(range(103, 104), range(71, 72)))
charset_9 = list(chain(range(104, 105), range(72, 73)))
charset_10 = list(chain(range(105, 106), range(73, 74)))
charset_11 = list(chain(range(106, 107), range(74, 75)))
charset_12 = list(chain(range(107, 108), range(75, 76)))
charset_13 = list(chain(range(108, 109), range(76, 77)))
charset_14 = list(chain(range(109, 110), range(77, 78)))
charset_15 = list(chain(range(110, 111), range(78, 79)))
charset_16 = list(chain(range(111, 112), range(79, 80)))
charset_17 = list(chain(range(112, 113), range(80, 81)))
charset_18 = list(chain(range(113, 114), range(81, 82)))
charset_19 = list(chain(range(114, 115), range(82, 83)))
charset_20 = list(chain(range(115, 116), range(83, 84)))
charset_21 = list(chain(range(116, 117), range(84, 85)))
charset_22 = list(chain(range(117, 118), range(85, 86)))
charset_23 = list(chain(range(118, 119), range(86, 87)))
charset_24 = list(chain(range(119, 120), range(87, 88)))
charset_25 = list(chain(range(120, 121), range(88, 89)))
charset_26 = list(chain(range(121, 122), range(89, 90)))
charset_27 = list(chain(range(122, 123), range(90, 91)))
charset_28 = list(chain(range(97, 123), range(65, 91)))
charset_29 = list(chain(range(48, 58)))
charset_30 = list(chain(*multirange_diff(printable_unicode_ranges, [(92, 93),(92, 93)])))


class ClickHouseUnlexer(Grammarinator):

    def __init__(self, *, max_depth=float('inf'), weights=None, cooldown=1.0):
        super(ClickHouseUnlexer, self).__init__()
        self.unlexer = self
        self.max_depth = max_depth
        self.weights = weights or dict()
        self.cooldown = cooldown

    def EOF(self, *args, **kwargs):
        pass

    @depthcontrol
    def LINE_COMMENT(self):
        current = self.create_node(UnlexerRule(name='LINE_COMMENT'))
        current += self.create_node(UnlexerRule(src='--'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                current += UnlexerRule(src=self.char_from_list(charset_0))

        choice = self.choice([0 if [0, 0, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_2', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_2', choice)] = self.unlexer.weights.get(('alt_2', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='\n'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='\r'))
        elif choice == 2:
            current += self.unlexer.EOF()
        return current
    LINE_COMMENT.min_depth = 0

    @depthcontrol
    def WHITESPACE(self):
        current = self.create_node(UnlexerRule(name='WHITESPACE'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_1)))
        return current
    WHITESPACE.min_depth = 0

    @depthcontrol
    def A(self):
        current = self.create_node(UnlexerRule(name='A'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_2)))
        return current
    A.min_depth = 0

    @depthcontrol
    def B(self):
        current = self.create_node(UnlexerRule(name='B'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_3)))
        return current
    B.min_depth = 0

    @depthcontrol
    def C(self):
        current = self.create_node(UnlexerRule(name='C'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_4)))
        return current
    C.min_depth = 0

    @depthcontrol
    def D(self):
        current = self.create_node(UnlexerRule(name='D'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_5)))
        return current
    D.min_depth = 0

    @depthcontrol
    def E(self):
        current = self.create_node(UnlexerRule(name='E'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_6)))
        return current
    E.min_depth = 0

    @depthcontrol
    def F(self):
        current = self.create_node(UnlexerRule(name='F'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_7)))
        return current
    F.min_depth = 0

    @depthcontrol
    def G(self):
        current = self.create_node(UnlexerRule(name='G'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_8)))
        return current
    G.min_depth = 0

    @depthcontrol
    def H(self):
        current = self.create_node(UnlexerRule(name='H'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_9)))
        return current
    H.min_depth = 0

    @depthcontrol
    def I(self):
        current = self.create_node(UnlexerRule(name='I'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_10)))
        return current
    I.min_depth = 0

    @depthcontrol
    def J(self):
        current = self.create_node(UnlexerRule(name='J'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_11)))
        return current
    J.min_depth = 0

    @depthcontrol
    def K(self):
        current = self.create_node(UnlexerRule(name='K'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_12)))
        return current
    K.min_depth = 0

    @depthcontrol
    def L(self):
        current = self.create_node(UnlexerRule(name='L'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_13)))
        return current
    L.min_depth = 0

    @depthcontrol
    def M(self):
        current = self.create_node(UnlexerRule(name='M'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_14)))
        return current
    M.min_depth = 0

    @depthcontrol
    def N(self):
        current = self.create_node(UnlexerRule(name='N'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_15)))
        return current
    N.min_depth = 0

    @depthcontrol
    def O(self):
        current = self.create_node(UnlexerRule(name='O'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_16)))
        return current
    O.min_depth = 0

    @depthcontrol
    def P(self):
        current = self.create_node(UnlexerRule(name='P'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_17)))
        return current
    P.min_depth = 0

    @depthcontrol
    def Q(self):
        current = self.create_node(UnlexerRule(name='Q'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_18)))
        return current
    Q.min_depth = 0

    @depthcontrol
    def R(self):
        current = self.create_node(UnlexerRule(name='R'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_19)))
        return current
    R.min_depth = 0

    @depthcontrol
    def S(self):
        current = self.create_node(UnlexerRule(name='S'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_20)))
        return current
    S.min_depth = 0

    @depthcontrol
    def T(self):
        current = self.create_node(UnlexerRule(name='T'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_21)))
        return current
    T.min_depth = 0

    @depthcontrol
    def U(self):
        current = self.create_node(UnlexerRule(name='U'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_22)))
        return current
    U.min_depth = 0

    @depthcontrol
    def V(self):
        current = self.create_node(UnlexerRule(name='V'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_23)))
        return current
    V.min_depth = 0

    @depthcontrol
    def W(self):
        current = self.create_node(UnlexerRule(name='W'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_24)))
        return current
    W.min_depth = 0

    @depthcontrol
    def X(self):
        current = self.create_node(UnlexerRule(name='X'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_25)))
        return current
    X.min_depth = 0

    @depthcontrol
    def Y(self):
        current = self.create_node(UnlexerRule(name='Y'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_26)))
        return current
    Y.min_depth = 0

    @depthcontrol
    def Z(self):
        current = self.create_node(UnlexerRule(name='Z'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_27)))
        return current
    Z.min_depth = 0

    @depthcontrol
    def LETTER(self):
        current = self.create_node(UnlexerRule(name='LETTER'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_28)))
        return current
    LETTER.min_depth = 0

    @depthcontrol
    def DIGIT(self):
        current = self.create_node(UnlexerRule(name='DIGIT'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_29)))
        return current
    DIGIT.min_depth = 0

    @depthcontrol
    def ARROW(self):
        current = self.create_node(UnlexerRule(name='ARROW'))
        current += self.create_node(UnlexerRule(src='->'))
        return current
    ARROW.min_depth = 0

    @depthcontrol
    def ASTERISK(self):
        current = self.create_node(UnlexerRule(name='ASTERISK'))
        current += self.create_node(UnlexerRule(src='*'))
        return current
    ASTERISK.min_depth = 0

    @depthcontrol
    def BACKQUOTE(self):
        current = self.create_node(UnlexerRule(name='BACKQUOTE'))
        current += self.create_node(UnlexerRule(src='`'))
        return current
    BACKQUOTE.min_depth = 0

    @depthcontrol
    def BACKSLASH(self):
        current = self.create_node(UnlexerRule(name='BACKSLASH'))
        current += self.create_node(UnlexerRule(src='\\'))
        return current
    BACKSLASH.min_depth = 0

    @depthcontrol
    def COLON(self):
        current = self.create_node(UnlexerRule(name='COLON'))
        current += self.create_node(UnlexerRule(src=':'))
        return current
    COLON.min_depth = 0

    @depthcontrol
    def COMMA(self):
        current = self.create_node(UnlexerRule(name='COMMA'))
        current += self.create_node(UnlexerRule(src=','))
        return current
    COMMA.min_depth = 0

    @depthcontrol
    def CONCAT(self):
        current = self.create_node(UnlexerRule(name='CONCAT'))
        current += self.create_node(UnlexerRule(src='||'))
        return current
    CONCAT.min_depth = 0

    @depthcontrol
    def DASH(self):
        current = self.create_node(UnlexerRule(name='DASH'))
        current += self.create_node(UnlexerRule(src='-'))
        return current
    DASH.min_depth = 0

    @depthcontrol
    def DOT(self):
        current = self.create_node(UnlexerRule(name='DOT'))
        current += self.create_node(UnlexerRule(src='.'))
        return current
    DOT.min_depth = 0

    @depthcontrol
    def EQ(self):
        current = self.create_node(UnlexerRule(name='EQ'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_17', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_17', choice)] = self.unlexer.weights.get(('alt_17', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='='))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='=='))
        return current
    EQ.min_depth = 0

    @depthcontrol
    def GE(self):
        current = self.create_node(UnlexerRule(name='GE'))
        current += self.create_node(UnlexerRule(src='>='))
        return current
    GE.min_depth = 0

    @depthcontrol
    def GT(self):
        current = self.create_node(UnlexerRule(name='GT'))
        current += self.create_node(UnlexerRule(src='>'))
        return current
    GT.min_depth = 0

    @depthcontrol
    def LBRACKET(self):
        current = self.create_node(UnlexerRule(name='LBRACKET'))
        current += self.create_node(UnlexerRule(src='['))
        return current
    LBRACKET.min_depth = 0

    @depthcontrol
    def LE(self):
        current = self.create_node(UnlexerRule(name='LE'))
        current += self.create_node(UnlexerRule(src='<='))
        return current
    LE.min_depth = 0

    @depthcontrol
    def LPAREN(self):
        current = self.create_node(UnlexerRule(name='LPAREN'))
        current += self.create_node(UnlexerRule(src='('))
        return current
    LPAREN.min_depth = 0

    @depthcontrol
    def LT(self):
        current = self.create_node(UnlexerRule(name='LT'))
        current += self.create_node(UnlexerRule(src='<'))
        return current
    LT.min_depth = 0

    @depthcontrol
    def NOT_EQ(self):
        current = self.create_node(UnlexerRule(name='NOT_EQ'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_28', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_28', choice)] = self.unlexer.weights.get(('alt_28', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='!='))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='<>'))
        return current
    NOT_EQ.min_depth = 0

    @depthcontrol
    def PERCENT(self):
        current = self.create_node(UnlexerRule(name='PERCENT'))
        current += self.create_node(UnlexerRule(src='%'))
        return current
    PERCENT.min_depth = 0

    @depthcontrol
    def PLUS(self):
        current = self.create_node(UnlexerRule(name='PLUS'))
        current += self.create_node(UnlexerRule(src='+'))
        return current
    PLUS.min_depth = 0

    @depthcontrol
    def QUERY(self):
        current = self.create_node(UnlexerRule(name='QUERY'))
        current += self.create_node(UnlexerRule(src='?'))
        return current
    QUERY.min_depth = 0

    @depthcontrol
    def QUOTE_SINGLE(self):
        current = self.create_node(UnlexerRule(name='QUOTE_SINGLE'))
        current += self.create_node(UnlexerRule(src='\''))
        return current
    QUOTE_SINGLE.min_depth = 0

    @depthcontrol
    def RBRACKET(self):
        current = self.create_node(UnlexerRule(name='RBRACKET'))
        current += self.create_node(UnlexerRule(src=']'))
        return current
    RBRACKET.min_depth = 0

    @depthcontrol
    def RPAREN(self):
        current = self.create_node(UnlexerRule(name='RPAREN'))
        current += self.create_node(UnlexerRule(src=')'))
        return current
    RPAREN.min_depth = 0

    @depthcontrol
    def SEMICOLON(self):
        current = self.create_node(UnlexerRule(name='SEMICOLON'))
        current += self.create_node(UnlexerRule(src=';'))
        return current
    SEMICOLON.min_depth = 0

    @depthcontrol
    def SLASH(self):
        current = self.create_node(UnlexerRule(name='SLASH'))
        current += self.create_node(UnlexerRule(src='/'))
        return current
    SLASH.min_depth = 0

    @depthcontrol
    def UNDERSCORE(self):
        current = self.create_node(UnlexerRule(name='UNDERSCORE'))
        current += self.create_node(UnlexerRule(src='_'))
        return current
    UNDERSCORE.min_depth = 0

    @depthcontrol
    def IDENTIFIER(self):
        current = self.create_node(UnlexerRule(name='IDENTIFIER'))
        choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_42', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_42', choice)] = self.unlexer.weights.get(('alt_42', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.LETTER()
        elif choice == 1:
            current += self.unlexer.UNDERSCORE()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_46', i), 1) for i, w in enumerate([1, 1, 1])])
                self.unlexer.weights[('alt_46', choice)] = self.unlexer.weights.get(('alt_46', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.LETTER()
                elif choice == 1:
                    current += self.unlexer.UNDERSCORE()
                elif choice == 2:
                    current += self.unlexer.DIGIT()

        return current
    IDENTIFIER.min_depth = 1

    @depthcontrol
    def LITERAL(self):
        current = self.create_node(UnlexerRule(name='LITERAL'))
        choice = self.choice([0 if [2, 2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_50', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_50', choice)] = self.unlexer.weights.get(('alt_50', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.NUMBER_LITERAL()
        elif choice == 1:
            current += self.unlexer.STRING_LITERAL()
        elif choice == 2:
            current += self.unlexer.NULL()
        return current
    LITERAL.min_depth = 2

    @depthcontrol
    def NUMBER_LITERAL(self):
        current = self.create_node(UnlexerRule(name='NUMBER_LITERAL'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.unlexer.DIGIT()

        return current
    NUMBER_LITERAL.min_depth = 1

    @depthcontrol
    def STRING_LITERAL(self):
        current = self.create_node(UnlexerRule(name='STRING_LITERAL'))
        current += self.unlexer.QUOTE_SINGLE()
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [0, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_55', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_55', choice)] = self.unlexer.weights.get(('alt_55', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += UnlexerRule(src=self.char_from_list(charset_30))
                elif choice == 1:
                    current += self.unlexer.BACKSLASH()
                    current += UnlexerRule(src=self.any_char())

        current += self.unlexer.QUOTE_SINGLE()
        return current
    STRING_LITERAL.min_depth = 1

    @depthcontrol
    def ALL(self):
        current = self.create_node(UnlexerRule(name='ALL'))
        current += self.unlexer.A()
        current += self.unlexer.L()
        current += self.unlexer.L()
        return current
    ALL.min_depth = 1

    @depthcontrol
    def AND(self):
        current = self.create_node(UnlexerRule(name='AND'))
        current += self.unlexer.A()
        current += self.unlexer.N()
        current += self.unlexer.D()
        return current
    AND.min_depth = 1

    @depthcontrol
    def ARRAY(self):
        current = self.create_node(UnlexerRule(name='ARRAY'))
        current += self.unlexer.A()
        current += self.unlexer.R()
        current += self.unlexer.R()
        current += self.unlexer.A()
        current += self.unlexer.Y()
        return current
    ARRAY.min_depth = 1

    @depthcontrol
    def AS(self):
        current = self.create_node(UnlexerRule(name='AS'))
        current += self.unlexer.A()
        current += self.unlexer.S()
        return current
    AS.min_depth = 1

    @depthcontrol
    def ASCENDING(self):
        current = self.create_node(UnlexerRule(name='ASCENDING'))
        choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_58', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_58', choice)] = self.unlexer.weights.get(('alt_58', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.A()
            current += self.unlexer.S()
            current += self.unlexer.C()
        elif choice == 1:
            current += self.unlexer.A()
            current += self.unlexer.S()
            current += self.unlexer.C()
            current += self.unlexer.E()
            current += self.unlexer.N()
            current += self.unlexer.D()
            current += self.unlexer.I()
            current += self.unlexer.N()
            current += self.unlexer.G()
        return current
    ASCENDING.min_depth = 1

    @depthcontrol
    def BETWEEN(self):
        current = self.create_node(UnlexerRule(name='BETWEEN'))
        current += self.unlexer.B()
        current += self.unlexer.E()
        current += self.unlexer.T()
        current += self.unlexer.W()
        current += self.unlexer.E()
        current += self.unlexer.E()
        current += self.unlexer.N()
        return current
    BETWEEN.min_depth = 1

    @depthcontrol
    def BOTH(self):
        current = self.create_node(UnlexerRule(name='BOTH'))
        current += self.unlexer.B()
        current += self.unlexer.O()
        current += self.unlexer.T()
        current += self.unlexer.H()
        return current
    BOTH.min_depth = 1

    @depthcontrol
    def BY(self):
        current = self.create_node(UnlexerRule(name='BY'))
        current += self.unlexer.B()
        current += self.unlexer.Y()
        return current
    BY.min_depth = 1

    @depthcontrol
    def CASE(self):
        current = self.create_node(UnlexerRule(name='CASE'))
        current += self.unlexer.C()
        current += self.unlexer.A()
        current += self.unlexer.S()
        current += self.unlexer.E()
        return current
    CASE.min_depth = 1

    @depthcontrol
    def CAST(self):
        current = self.create_node(UnlexerRule(name='CAST'))
        current += self.unlexer.C()
        current += self.unlexer.A()
        current += self.unlexer.S()
        current += self.unlexer.T()
        return current
    CAST.min_depth = 1

    @depthcontrol
    def COLLATE(self):
        current = self.create_node(UnlexerRule(name='COLLATE'))
        current += self.unlexer.C()
        current += self.unlexer.O()
        current += self.unlexer.L()
        current += self.unlexer.L()
        current += self.unlexer.A()
        current += self.unlexer.T()
        current += self.unlexer.E()
        return current
    COLLATE.min_depth = 1

    @depthcontrol
    def DAY(self):
        current = self.create_node(UnlexerRule(name='DAY'))
        current += self.unlexer.D()
        current += self.unlexer.A()
        current += self.unlexer.Y()
        return current
    DAY.min_depth = 1

    @depthcontrol
    def DESCENDING(self):
        current = self.create_node(UnlexerRule(name='DESCENDING'))
        choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_61', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_61', choice)] = self.unlexer.weights.get(('alt_61', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.D()
            current += self.unlexer.E()
            current += self.unlexer.S()
            current += self.unlexer.C()
        elif choice == 1:
            current += self.unlexer.D()
            current += self.unlexer.E()
            current += self.unlexer.S()
            current += self.unlexer.C()
            current += self.unlexer.E()
            current += self.unlexer.N()
            current += self.unlexer.D()
            current += self.unlexer.I()
            current += self.unlexer.N()
            current += self.unlexer.G()
        return current
    DESCENDING.min_depth = 1

    @depthcontrol
    def DISTINCT(self):
        current = self.create_node(UnlexerRule(name='DISTINCT'))
        current += self.unlexer.D()
        current += self.unlexer.I()
        current += self.unlexer.S()
        current += self.unlexer.T()
        current += self.unlexer.I()
        current += self.unlexer.N()
        current += self.unlexer.C()
        current += self.unlexer.T()
        return current
    DISTINCT.min_depth = 1

    @depthcontrol
    def ELSE(self):
        current = self.create_node(UnlexerRule(name='ELSE'))
        current += self.unlexer.E()
        current += self.unlexer.L()
        current += self.unlexer.S()
        current += self.unlexer.E()
        return current
    ELSE.min_depth = 1

    @depthcontrol
    def END(self):
        current = self.create_node(UnlexerRule(name='END'))
        current += self.unlexer.E()
        current += self.unlexer.N()
        current += self.unlexer.D()
        return current
    END.min_depth = 1

    @depthcontrol
    def EXTRACT(self):
        current = self.create_node(UnlexerRule(name='EXTRACT'))
        current += self.unlexer.E()
        current += self.unlexer.X()
        current += self.unlexer.T()
        current += self.unlexer.R()
        current += self.unlexer.A()
        current += self.unlexer.C()
        current += self.unlexer.T()
        return current
    EXTRACT.min_depth = 1

    @depthcontrol
    def FINAL(self):
        current = self.create_node(UnlexerRule(name='FINAL'))
        current += self.unlexer.F()
        current += self.unlexer.I()
        current += self.unlexer.N()
        current += self.unlexer.A()
        current += self.unlexer.L()
        return current
    FINAL.min_depth = 1

    @depthcontrol
    def FIRST(self):
        current = self.create_node(UnlexerRule(name='FIRST'))
        current += self.unlexer.F()
        current += self.unlexer.I()
        current += self.unlexer.R()
        current += self.unlexer.S()
        current += self.unlexer.T()
        return current
    FIRST.min_depth = 1

    @depthcontrol
    def FORMAT(self):
        current = self.create_node(UnlexerRule(name='FORMAT'))
        current += self.unlexer.F()
        current += self.unlexer.O()
        current += self.unlexer.R()
        current += self.unlexer.M()
        current += self.unlexer.A()
        current += self.unlexer.T()
        return current
    FORMAT.min_depth = 1

    @depthcontrol
    def FROM(self):
        current = self.create_node(UnlexerRule(name='FROM'))
        current += self.unlexer.F()
        current += self.unlexer.R()
        current += self.unlexer.O()
        current += self.unlexer.M()
        return current
    FROM.min_depth = 1

    @depthcontrol
    def GLOBAL(self):
        current = self.create_node(UnlexerRule(name='GLOBAL'))
        current += self.unlexer.G()
        current += self.unlexer.L()
        current += self.unlexer.O()
        current += self.unlexer.B()
        current += self.unlexer.A()
        current += self.unlexer.L()
        return current
    GLOBAL.min_depth = 1

    @depthcontrol
    def GROUP(self):
        current = self.create_node(UnlexerRule(name='GROUP'))
        current += self.unlexer.G()
        current += self.unlexer.R()
        current += self.unlexer.O()
        current += self.unlexer.U()
        current += self.unlexer.P()
        return current
    GROUP.min_depth = 1

    @depthcontrol
    def HAVING(self):
        current = self.create_node(UnlexerRule(name='HAVING'))
        current += self.unlexer.H()
        current += self.unlexer.A()
        current += self.unlexer.V()
        current += self.unlexer.I()
        current += self.unlexer.N()
        current += self.unlexer.G()
        return current
    HAVING.min_depth = 1

    @depthcontrol
    def HOUR(self):
        current = self.create_node(UnlexerRule(name='HOUR'))
        current += self.unlexer.H()
        current += self.unlexer.O()
        current += self.unlexer.U()
        current += self.unlexer.R()
        return current
    HOUR.min_depth = 1

    @depthcontrol
    def IN(self):
        current = self.create_node(UnlexerRule(name='IN'))
        current += self.unlexer.I()
        current += self.unlexer.N()
        return current
    IN.min_depth = 1

    @depthcontrol
    def INTERVAL(self):
        current = self.create_node(UnlexerRule(name='INTERVAL'))
        current += self.unlexer.I()
        current += self.unlexer.N()
        current += self.unlexer.T()
        current += self.unlexer.E()
        current += self.unlexer.R()
        current += self.unlexer.V()
        current += self.unlexer.A()
        current += self.unlexer.L()
        return current
    INTERVAL.min_depth = 1

    @depthcontrol
    def INTO(self):
        current = self.create_node(UnlexerRule(name='INTO'))
        current += self.unlexer.I()
        current += self.unlexer.N()
        current += self.unlexer.T()
        current += self.unlexer.O()
        return current
    INTO.min_depth = 1

    @depthcontrol
    def IS(self):
        current = self.create_node(UnlexerRule(name='IS'))
        current += self.unlexer.I()
        current += self.unlexer.S()
        return current
    IS.min_depth = 1

    @depthcontrol
    def JOIN(self):
        current = self.create_node(UnlexerRule(name='JOIN'))
        current += self.unlexer.J()
        current += self.unlexer.O()
        current += self.unlexer.I()
        current += self.unlexer.N()
        return current
    JOIN.min_depth = 1

    @depthcontrol
    def LAST(self):
        current = self.create_node(UnlexerRule(name='LAST'))
        current += self.unlexer.L()
        current += self.unlexer.A()
        current += self.unlexer.S()
        current += self.unlexer.T()
        return current
    LAST.min_depth = 1

    @depthcontrol
    def LEADING(self):
        current = self.create_node(UnlexerRule(name='LEADING'))
        current += self.unlexer.L()
        current += self.unlexer.E()
        current += self.unlexer.A()
        current += self.unlexer.D()
        current += self.unlexer.I()
        current += self.unlexer.N()
        current += self.unlexer.G()
        return current
    LEADING.min_depth = 1

    @depthcontrol
    def LEFT(self):
        current = self.create_node(UnlexerRule(name='LEFT'))
        current += self.unlexer.L()
        current += self.unlexer.E()
        current += self.unlexer.F()
        current += self.unlexer.T()
        return current
    LEFT.min_depth = 1

    @depthcontrol
    def LIKE(self):
        current = self.create_node(UnlexerRule(name='LIKE'))
        current += self.unlexer.L()
        current += self.unlexer.I()
        current += self.unlexer.K()
        current += self.unlexer.E()
        return current
    LIKE.min_depth = 1

    @depthcontrol
    def LIMIT(self):
        current = self.create_node(UnlexerRule(name='LIMIT'))
        current += self.unlexer.L()
        current += self.unlexer.I()
        current += self.unlexer.M()
        current += self.unlexer.I()
        current += self.unlexer.T()
        return current
    LIMIT.min_depth = 1

    @depthcontrol
    def MINUTE(self):
        current = self.create_node(UnlexerRule(name='MINUTE'))
        current += self.unlexer.M()
        current += self.unlexer.I()
        current += self.unlexer.N()
        current += self.unlexer.U()
        current += self.unlexer.T()
        current += self.unlexer.E()
        return current
    MINUTE.min_depth = 1

    @depthcontrol
    def MONTH(self):
        current = self.create_node(UnlexerRule(name='MONTH'))
        current += self.unlexer.M()
        current += self.unlexer.O()
        current += self.unlexer.N()
        current += self.unlexer.T()
        current += self.unlexer.H()
        return current
    MONTH.min_depth = 1

    @depthcontrol
    def NOT(self):
        current = self.create_node(UnlexerRule(name='NOT'))
        current += self.unlexer.N()
        current += self.unlexer.O()
        current += self.unlexer.T()
        return current
    NOT.min_depth = 1

    @depthcontrol
    def NULL(self):
        current = self.create_node(UnlexerRule(name='NULL'))
        current += self.unlexer.N()
        current += self.unlexer.U()
        current += self.unlexer.L()
        current += self.unlexer.L()
        return current
    NULL.min_depth = 1

    @depthcontrol
    def NULLS(self):
        current = self.create_node(UnlexerRule(name='NULLS'))
        current += self.unlexer.N()
        current += self.unlexer.U()
        current += self.unlexer.L()
        current += self.unlexer.L()
        current += self.unlexer.S()
        return current
    NULLS.min_depth = 1

    @depthcontrol
    def OFFSET(self):
        current = self.create_node(UnlexerRule(name='OFFSET'))
        current += self.unlexer.O()
        current += self.unlexer.F()
        current += self.unlexer.F()
        current += self.unlexer.S()
        current += self.unlexer.E()
        current += self.unlexer.T()
        return current
    OFFSET.min_depth = 1

    @depthcontrol
    def OR(self):
        current = self.create_node(UnlexerRule(name='OR'))
        current += self.unlexer.O()
        current += self.unlexer.R()
        return current
    OR.min_depth = 1

    @depthcontrol
    def ORDER(self):
        current = self.create_node(UnlexerRule(name='ORDER'))
        current += self.unlexer.O()
        current += self.unlexer.R()
        current += self.unlexer.D()
        current += self.unlexer.E()
        current += self.unlexer.R()
        return current
    ORDER.min_depth = 1

    @depthcontrol
    def OUTFILE(self):
        current = self.create_node(UnlexerRule(name='OUTFILE'))
        current += self.unlexer.O()
        current += self.unlexer.U()
        current += self.unlexer.T()
        current += self.unlexer.F()
        current += self.unlexer.I()
        current += self.unlexer.L()
        current += self.unlexer.E()
        return current
    OUTFILE.min_depth = 1

    @depthcontrol
    def PREWHERE(self):
        current = self.create_node(UnlexerRule(name='PREWHERE'))
        current += self.unlexer.P()
        current += self.unlexer.R()
        current += self.unlexer.E()
        current += self.unlexer.W()
        current += self.unlexer.H()
        current += self.unlexer.E()
        current += self.unlexer.R()
        current += self.unlexer.E()
        return current
    PREWHERE.min_depth = 1

    @depthcontrol
    def QUARTER(self):
        current = self.create_node(UnlexerRule(name='QUARTER'))
        current += self.unlexer.Q()
        current += self.unlexer.U()
        current += self.unlexer.A()
        current += self.unlexer.R()
        current += self.unlexer.T()
        current += self.unlexer.E()
        current += self.unlexer.R()
        return current
    QUARTER.min_depth = 1

    @depthcontrol
    def SAMPLE(self):
        current = self.create_node(UnlexerRule(name='SAMPLE'))
        current += self.unlexer.S()
        current += self.unlexer.A()
        current += self.unlexer.M()
        current += self.unlexer.P()
        current += self.unlexer.L()
        current += self.unlexer.E()
        return current
    SAMPLE.min_depth = 1

    @depthcontrol
    def SECOND(self):
        current = self.create_node(UnlexerRule(name='SECOND'))
        current += self.unlexer.S()
        current += self.unlexer.E()
        current += self.unlexer.C()
        current += self.unlexer.O()
        current += self.unlexer.N()
        current += self.unlexer.D()
        return current
    SECOND.min_depth = 1

    @depthcontrol
    def SELECT(self):
        current = self.create_node(UnlexerRule(name='SELECT'))
        current += self.unlexer.S()
        current += self.unlexer.E()
        current += self.unlexer.L()
        current += self.unlexer.E()
        current += self.unlexer.C()
        current += self.unlexer.T()
        return current
    SELECT.min_depth = 1

    @depthcontrol
    def SETTINGS(self):
        current = self.create_node(UnlexerRule(name='SETTINGS'))
        current += self.unlexer.S()
        current += self.unlexer.E()
        current += self.unlexer.T()
        current += self.unlexer.T()
        current += self.unlexer.I()
        current += self.unlexer.N()
        current += self.unlexer.G()
        current += self.unlexer.S()
        return current
    SETTINGS.min_depth = 1

    @depthcontrol
    def THEN(self):
        current = self.create_node(UnlexerRule(name='THEN'))
        current += self.unlexer.T()
        current += self.unlexer.H()
        current += self.unlexer.E()
        current += self.unlexer.N()
        return current
    THEN.min_depth = 1

    @depthcontrol
    def TOTALS(self):
        current = self.create_node(UnlexerRule(name='TOTALS'))
        current += self.unlexer.T()
        current += self.unlexer.O()
        current += self.unlexer.T()
        current += self.unlexer.A()
        current += self.unlexer.L()
        current += self.unlexer.S()
        return current
    TOTALS.min_depth = 1

    @depthcontrol
    def TRAILING(self):
        current = self.create_node(UnlexerRule(name='TRAILING'))
        current += self.unlexer.T()
        current += self.unlexer.R()
        current += self.unlexer.A()
        current += self.unlexer.I()
        current += self.unlexer.L()
        current += self.unlexer.I()
        current += self.unlexer.N()
        current += self.unlexer.G()
        return current
    TRAILING.min_depth = 1

    @depthcontrol
    def TRIM(self):
        current = self.create_node(UnlexerRule(name='TRIM'))
        current += self.unlexer.T()
        current += self.unlexer.R()
        current += self.unlexer.I()
        current += self.unlexer.M()
        return current
    TRIM.min_depth = 1

    @depthcontrol
    def UNION(self):
        current = self.create_node(UnlexerRule(name='UNION'))
        current += self.unlexer.U()
        current += self.unlexer.N()
        current += self.unlexer.I()
        current += self.unlexer.O()
        current += self.unlexer.N()
        return current
    UNION.min_depth = 1

    @depthcontrol
    def WEEK(self):
        current = self.create_node(UnlexerRule(name='WEEK'))
        current += self.unlexer.W()
        current += self.unlexer.E()
        current += self.unlexer.E()
        current += self.unlexer.K()
        return current
    WEEK.min_depth = 1

    @depthcontrol
    def WHEN(self):
        current = self.create_node(UnlexerRule(name='WHEN'))
        current += self.unlexer.W()
        current += self.unlexer.H()
        current += self.unlexer.E()
        current += self.unlexer.N()
        return current
    WHEN.min_depth = 1

    @depthcontrol
    def WHERE(self):
        current = self.create_node(UnlexerRule(name='WHERE'))
        current += self.unlexer.W()
        current += self.unlexer.H()
        current += self.unlexer.E()
        current += self.unlexer.R()
        current += self.unlexer.E()
        return current
    WHERE.min_depth = 1

    @depthcontrol
    def WITH(self):
        current = self.create_node(UnlexerRule(name='WITH'))
        current += self.unlexer.W()
        current += self.unlexer.I()
        current += self.unlexer.T()
        current += self.unlexer.H()
        return current
    WITH.min_depth = 1

    @depthcontrol
    def YEAR(self):
        current = self.create_node(UnlexerRule(name='YEAR'))
        current += self.unlexer.Y()
        current += self.unlexer.E()
        current += self.unlexer.A()
        current += self.unlexer.R()
        return current
    YEAR.min_depth = 1

    @depthcontrol
    def INTERVAL_TYPE(self):
        current = self.create_node(UnlexerRule(name='INTERVAL_TYPE'))
        choice = self.choice([0 if [2, 2, 2, 2, 2, 2, 2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_64', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_64', choice)] = self.unlexer.weights.get(('alt_64', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.SECOND()
        elif choice == 1:
            current += self.unlexer.MINUTE()
        elif choice == 2:
            current += self.unlexer.HOUR()
        elif choice == 3:
            current += self.unlexer.DAY()
        elif choice == 4:
            current += self.unlexer.WEEK()
        elif choice == 5:
            current += self.unlexer.MONTH()
        elif choice == 6:
            current += self.unlexer.QUARTER()
        elif choice == 7:
            current += self.unlexer.YEAR()
        return current
    INTERVAL_TYPE.min_depth = 2

