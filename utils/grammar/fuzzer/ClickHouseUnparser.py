# Generated by Grammarinator 19.3

from itertools import chain
from grammarinator.runtime import *

import ClickHouseUnlexer


class ClickHouseUnparser(Grammarinator):

    def __init__(self, unlexer):
        super(ClickHouseUnparser, self).__init__()
        self.unlexer = unlexer
    @depthcontrol
    def query_list(self):
        current = self.create_node(UnparserRule(name='query_list'))
        current += self.query_stmt()
        if self.unlexer.max_depth >= 6:
            for _ in self.zero_or_more():
                current += self.unlexer.SEMICOLON()
                current += self.query_stmt()

        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.SEMICOLON()

        return current
    query_list.min_depth = 6

    @depthcontrol
    def query_stmt(self):
        current = self.create_node(UnparserRule(name='query_stmt'))
        current += self.select_union_stmt()
        return current
    query_stmt.min_depth = 5

    @depthcontrol
    def select_union_stmt(self):
        current = self.create_node(UnparserRule(name='select_union_stmt'))
        current += self.select_stmt()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_more():
                current += self.unlexer.UNION()
                current += self.unlexer.ALL()
                current += self.select_stmt()

        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.INTO()
                current += self.unlexer.OUTFILE()
                current += self.unlexer.STRING_LITERAL()

        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.unlexer.FORMAT()
                current += self.identifier()

        return current
    select_union_stmt.min_depth = 4

    @depthcontrol
    def select_stmt(self):
        current = self.create_node(UnparserRule(name='select_stmt'))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.unlexer.WITH()
                current += self.column_expr_list()

        current += self.unlexer.SELECT()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.DISTINCT()

        current += self.column_expr_list()
        if self.unlexer.max_depth >= 5:
            for _ in self.zero_or_one():
                current += self.unlexer.FROM()
                current += self.join_expr()
                if self.unlexer.max_depth >= 2:
                    for _ in self.zero_or_one():
                        current += self.unlexer.FINAL()


        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.unlexer.SAMPLE()
                current += self.ratio_expr()
                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_one():
                        current += self.unlexer.OFFSET()
                        current += self.ratio_expr()


        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                if self.unlexer.max_depth >= 2:
                    for _ in self.zero_or_one():
                        current += self.unlexer.LEFT()

                current += self.unlexer.ARRAY()
                current += self.unlexer.JOIN()
                current += self.column_expr_list()

        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.PREWHERE()
                current += self.column_expr()

        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.WHERE()
                current += self.column_expr()

        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.unlexer.GROUP()
                current += self.unlexer.BY()
                current += self.column_expr_list()
                if self.unlexer.max_depth >= 2:
                    for _ in self.zero_or_one():
                        current += self.unlexer.WITH()
                        current += self.unlexer.TOTALS()


        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.HAVING()
                current += self.column_expr()

        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.unlexer.ORDER()
                current += self.unlexer.BY()
                current += self.order_expr_list()

        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.unlexer.LIMIT()
                current += self.limit_expr()
                current += self.unlexer.BY()
                current += self.column_expr_list()

        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.unlexer.LIMIT()
                current += self.limit_expr()

        if self.unlexer.max_depth >= 5:
            for _ in self.zero_or_one():
                current += self.unlexer.SETTINGS()
                current += self.setting_expr_list()

        return current
    select_stmt.min_depth = 3

    @depthcontrol
    def join_expr(self):
        current = self.create_node(UnparserRule(name='join_expr'))
        current += self.table_identifier()
        return current
    join_expr.min_depth = 4

    @depthcontrol
    def limit_expr(self):
        current = self.create_node(UnparserRule(name='limit_expr'))
        choice = self.choice([0 if [2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_95', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_95', choice)] = self.unlexer.weights.get(('alt_95', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.NUMBER_LITERAL()
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    current += self.unlexer.COMMA()
                    current += self.unlexer.NUMBER_LITERAL()

        elif choice == 1:
            current += self.unlexer.NUMBER_LITERAL()
            current += self.unlexer.OFFSET()
            current += self.unlexer.NUMBER_LITERAL()
        return current
    limit_expr.min_depth = 2

    @depthcontrol
    def order_expr_list(self):
        current = self.create_node(UnparserRule(name='order_expr_list'))
        current += self.order_expr()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_more():
                current += self.unlexer.COMMA()
                current += self.order_expr()

        return current
    order_expr_list.min_depth = 3

    @depthcontrol
    def order_expr(self):
        current = self.create_node(UnparserRule(name='order_expr'))
        current += self.column_expr()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                choice = self.choice([0 if [2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_101', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_101', choice)] = self.unlexer.weights.get(('alt_101', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.ASCENDING()
                elif choice == 1:
                    current += self.unlexer.DESCENDING()

        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.NULLS()
                choice = self.choice([0 if [2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_105', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_105', choice)] = self.unlexer.weights.get(('alt_105', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.FIRST()
                elif choice == 1:
                    current += self.unlexer.LAST()

        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.COLLATE()
                current += self.unlexer.STRING_LITERAL()

        return current
    order_expr.min_depth = 2

    @depthcontrol
    def ratio_expr(self):
        current = self.create_node(UnparserRule(name='ratio_expr'))
        current += self.unlexer.NUMBER_LITERAL()
        current += self.unlexer.SLASH()
        current += self.unlexer.NUMBER_LITERAL()
        return current
    ratio_expr.min_depth = 2

    @depthcontrol
    def setting_expr_list(self):
        current = self.create_node(UnparserRule(name='setting_expr_list'))
        current += self.setting_expr()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_more():
                current += self.unlexer.COMMA()
                current += self.setting_expr()

        return current
    setting_expr_list.min_depth = 4

    @depthcontrol
    def setting_expr(self):
        current = self.create_node(UnparserRule(name='setting_expr'))
        current += self.identifier()
        current += self.unlexer.EQ()
        current += self.unlexer.LITERAL()
        return current
    setting_expr.min_depth = 3

    @depthcontrol
    def column_expr_list(self):
        current = self.create_node(UnparserRule(name='column_expr_list'))
        current += self.column_expr()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                current += self.unlexer.COMMA()
                current += self.column_expr()

        return current
    column_expr_list.min_depth = 2

    @depthcontrol
    def column_expr(self):
        current = self.create_node(UnparserRule(name='column_expr'))
        choice = self.choice([0 if [2, 4, 1, 2, 2, 3, 3, 4, 3, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_111', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_111', choice)] = self.unlexer.weights.get(('alt_111', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.LPAREN()
            current += self.column_expr()
            current += self.unlexer.RPAREN()
        elif choice == 1:
            current += self.unlexer.LPAREN()
            current += self.select_stmt()
            current += self.unlexer.RPAREN()
        elif choice == 2:
            current += self.unlexer.LBRACKET()
            if self.unlexer.max_depth >= 3:
                for _ in self.zero_or_one():
                    current += self.column_expr_list()

            current += self.unlexer.RBRACKET()
        elif choice == 3:
            current += self.column_expr()
            current += self.unlexer.LBRACKET()
            current += self.column_expr()
            current += self.unlexer.RBRACKET()
        elif choice == 4:
            current += self.column_expr()
            current += self.unlexer.DOT()
            current += self.unlexer.NUMBER_LITERAL()
        elif choice == 5:
            current += self.column_op_expr()
        elif choice == 6:
            current += self.column_function_expr()
        elif choice == 7:
            current += self.column_identifier()
        elif choice == 8:
            current += self.unlexer.LITERAL()
        elif choice == 9:
            current += self.unlexer.ASTERISK()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.unlexer.AS()
                current += self.identifier()

        return current
    column_expr.min_depth = 1

    @depthcontrol
    def column_op_expr(self):
        current = self.create_node(UnparserRule(name='column_op_expr'))
        choice = self.choice([0 if [2, 2, 2, 2, 2, 2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_124', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_124', choice)] = self.unlexer.weights.get(('alt_124', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unary_op()
            current += self.column_expr()
        elif choice == 1:
            current += self.column_expr()
            current += self.unlexer.IS()
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    current += self.unlexer.NOT()

            current += self.unlexer.NULL()
        elif choice == 2:
            current += self.column_expr()
            current += self.binary_op()
            current += self.column_expr()
        elif choice == 3:
            current += self.column_expr()
            current += self.unlexer.QUERY()
            current += self.column_expr()
            current += self.unlexer.COLON()
            current += self.column_expr()
        elif choice == 4:
            current += self.column_expr()
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    current += self.unlexer.NOT()

            current += self.unlexer.BETWEEN()
            current += self.column_expr()
            current += self.unlexer.AND()
            current += self.column_expr()
        elif choice == 5:
            current += self.unlexer.CASE()
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    current += self.column_expr()

            if self.unlexer.max_depth >= 0:
                for _ in self.one_or_more():
                    current += self.unlexer.WHEN()
                    current += self.column_expr()
                    current += self.unlexer.THEN()
                    current += self.column_expr()

            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    current += self.unlexer.ELSE()
                    current += self.column_expr()

            current += self.unlexer.END()
        elif choice == 6:
            current += self.unlexer.INTERVAL()
            current += self.column_expr()
            current += self.unlexer.INTERVAL_TYPE()
        return current
    column_op_expr.min_depth = 2

    @depthcontrol
    def column_function_expr(self):
        current = self.create_node(UnparserRule(name='column_function_expr'))
        choice = self.choice([0 if [3, 3, 3, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_136', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_136', choice)] = self.unlexer.weights.get(('alt_136', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.identifier()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_one():
                    current += self.unlexer.LPAREN()
                    if self.unlexer.max_depth >= 3:
                        for _ in self.zero_or_one():
                            current += self.unlexer.LITERAL()
                            if self.unlexer.max_depth >= 3:
                                for _ in self.zero_or_more():
                                    current += self.unlexer.COMMA()
                                    current += self.unlexer.LITERAL()


                    current += self.unlexer.RPAREN()

            current += self.unlexer.LPAREN()
            if self.unlexer.max_depth >= 4:
                for _ in self.zero_or_one():
                    current += self.column_arg_list()

            current += self.unlexer.RPAREN()
        elif choice == 1:
            current += self.unlexer.EXTRACT()
            current += self.unlexer.LPAREN()
            current += self.unlexer.INTERVAL_TYPE()
            current += self.unlexer.FROM()
            current += self.column_expr()
            current += self.unlexer.RPAREN()
        elif choice == 2:
            current += self.unlexer.CAST()
            current += self.unlexer.LPAREN()
            current += self.column_expr()
            current += self.unlexer.AS()
            current += self.identifier()
            current += self.unlexer.RPAREN()
        elif choice == 3:
            current += self.unlexer.TRIM()
            current += self.unlexer.LPAREN()
            choice = self.choice([0 if [2, 2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_145', i), 1) for i, w in enumerate([1, 1, 1])])
            self.unlexer.weights[('alt_145', choice)] = self.unlexer.weights.get(('alt_145', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.unlexer.BOTH()
            elif choice == 1:
                current += self.unlexer.LEADING()
            elif choice == 2:
                current += self.unlexer.TRAILING()
            current += self.unlexer.STRING_LITERAL()
            current += self.unlexer.FROM()
            current += self.column_expr()
            current += self.unlexer.RPAREN()
        return current
    column_function_expr.min_depth = 2

    @depthcontrol
    def column_arg_list(self):
        current = self.create_node(UnparserRule(name='column_arg_list'))
        current += self.column_arg_expr()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_more():
                current += self.unlexer.COMMA()
                current += self.column_arg_expr()

        return current
    column_arg_list.min_depth = 3

    @depthcontrol
    def column_arg_expr(self):
        current = self.create_node(UnparserRule(name='column_arg_expr'))
        choice = self.choice([0 if [2, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_150', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_150', choice)] = self.unlexer.weights.get(('alt_150', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.column_expr()
        elif choice == 1:
            current += self.column_lambda_expr()
        return current
    column_arg_expr.min_depth = 2

    @depthcontrol
    def column_lambda_expr(self):
        current = self.create_node(UnparserRule(name='column_lambda_expr'))
        choice = self.choice([0 if [3, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_153', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_153', choice)] = self.unlexer.weights.get(('alt_153', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.LPAREN()
            current += self.identifier()
            if self.unlexer.max_depth >= 3:
                for _ in self.zero_or_more():
                    current += self.unlexer.COMMA()
                    current += self.identifier()

            current += self.unlexer.RPAREN()
        elif choice == 1:
            current += self.identifier()
            if self.unlexer.max_depth >= 3:
                for _ in self.zero_or_more():
                    current += self.unlexer.COMMA()
                    current += self.identifier()

        current += self.unlexer.ARROW()
        current += self.column_expr()
        return current
    column_lambda_expr.min_depth = 3

    @depthcontrol
    def column_identifier(self):
        current = self.create_node(UnparserRule(name='column_identifier'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.table_identifier()
                current += self.unlexer.DOT()

        current += self.identifier()
        return current
    column_identifier.min_depth = 3

    @depthcontrol
    def table_identifier(self):
        current = self.create_node(UnparserRule(name='table_identifier'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.database_identifier()
                current += self.unlexer.DOT()

        current += self.identifier()
        return current
    table_identifier.min_depth = 3

    @depthcontrol
    def database_identifier(self):
        current = self.create_node(UnparserRule(name='database_identifier'))
        current += self.identifier()
        return current
    database_identifier.min_depth = 3

    @depthcontrol
    def identifier(self):
        current = self.create_node(UnparserRule(name='identifier'))
        current += self.unlexer.IDENTIFIER()
        return current
    identifier.min_depth = 2

    @depthcontrol
    def unary_op(self):
        current = self.create_node(UnparserRule(name='unary_op'))
        choice = self.choice([0 if [1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_160', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_160', choice)] = self.unlexer.weights.get(('alt_160', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.DASH()
        elif choice == 1:
            current += self.unlexer.NOT()
        return current
    unary_op.min_depth = 1

    @depthcontrol
    def binary_op(self):
        current = self.create_node(UnparserRule(name='binary_op'))
        choice = self.choice([0 if [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_163', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_163', choice)] = self.unlexer.weights.get(('alt_163', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.ASTERISK()
        elif choice == 1:
            current += self.unlexer.SLASH()
        elif choice == 2:
            current += self.unlexer.PERCENT()
        elif choice == 3:
            current += self.unlexer.PLUS()
        elif choice == 4:
            current += self.unlexer.DASH()
        elif choice == 5:
            current += self.unlexer.EQ()
        elif choice == 6:
            current += self.unlexer.NOT_EQ()
        elif choice == 7:
            current += self.unlexer.LE()
        elif choice == 8:
            current += self.unlexer.GE()
        elif choice == 9:
            current += self.unlexer.LT()
        elif choice == 10:
            current += self.unlexer.GT()
        elif choice == 11:
            current += self.unlexer.CONCAT()
        elif choice == 12:
            current += self.unlexer.AND()
        elif choice == 13:
            current += self.unlexer.OR()
        elif choice == 14:
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    current += self.unlexer.NOT()

            current += self.unlexer.LIKE()
        elif choice == 15:
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    current += self.unlexer.GLOBAL()

            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    current += self.unlexer.NOT()

            current += self.unlexer.IN()
        return current
    binary_op.min_depth = 1

    default_rule = query_list

