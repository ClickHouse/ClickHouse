<!DOCTYPE html>
<html>

<!--

# Paste Service On Top Of ClickHouse

## About

This service is developed to demonstrate some features of ClickHouse
like asynchronous INSERTs, direct querying from HTML page, EPHEMERAL columns,
custom HTTP handlers, quotas and user access control, etc.
in a toy service similar to "pastebin" or "gist".

Features:
- data is instantly saved in ClickHouse after pasting or editing - single page with no "save" button;
- after data is saved or loaded, you see the check mark in the bottom right corner;
- just copy the link from the address bar - it is a permanent link to the data;
- you can host Markdown pages - just add .md to the URL and share it;
- you can host HTML pages - just add .html to the URL and share it;
- browser history is used while editing for easy undo;
- edit history is also saved in database: after you load the data,
  previous version of the data is available by clicking the "back" button in bottom right corner;

## Terms Of Use

This service can be used for helping ClickHouse development.
No other usages permitted.

## Warranty

No warranties or conditions of any kind, either express or implied.
The data can be removed or lost at any moment of time.

## Security And Privacy

This service may not provide any security or privacy.

## Cookie Policy

This service does not use cookies.

## Report Abuse

To report abuse, write to feedback@clickhouse.com

-->

<head>
    <meta charset="UTF-8">
    <title>Paste</title>
    <style>
        html, body, textarea {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: sans-serif;
        }

        textarea {
            outline: none;
            border: none;
            margin: 0.5em;
            width: calc(100% - 1em);
            height: calc(100% - 1em);
        }

        .status {
            position: absolute;
            right: 1em;
            bottom: 0.5em;
            z-index: 1;
            font-size: 200%;
            font-family: sans-serif;
            display: none;
        }

        #hourglass {
            color: gray;
            animation: spin 2s infinite;
        }

        #check-mark {
            color: green;
        }

        @keyframes spin {
            100% { transform: rotate(360deg); }
        }

        #back {
            cursor: pointer;
            font-weight: bold;
        }

        a:hover {
            color: #00b3ee;
        }

        .markdown {
            margin: 1em;
            width: calc(100% - 2em);
            height: auto;
        }
    </style>
</head>
<body>
<span class="status" id="hourglass">⧗</span>
<span class="status" id="check-mark">✔</span>
<span class="status" id="error">❌</span>
<a class="status" id="back">⎌</a>
<textarea id="data" autofocus></textarea>
<script type="text/javascript">

const encoder = new TextEncoder();

function sipHash128(m) {
    function rotl(v, offset, bits) {
        v[offset] = (v[offset] << bits) | (v[offset] >> (64n - bits));
    }

    function compress(v) {
        v[0] += v[1];
        v[2] += v[3];
        rotl(v, 1, 13n);
        rotl(v, 3, 16n);
        v[1] ^= v[0];
        v[3] ^= v[2];
        rotl(v, 0, 32n);
        v[2] += v[1];
        v[0] += v[3];
        rotl(v, 1, 17n);
        rotl(v, 3, 21n);
        v[1] ^= v[2];
        v[3] ^= v[0];
        rotl(v, 2, 32n);
    }

    const view = new DataView(m.buffer);
    let buf = new Uint8Array(new ArrayBuffer(8));
    let v = new BigUint64Array([0x736f6d6570736575n, 0x646f72616e646f6dn, 0x6c7967656e657261n, 0x7465646279746573n]);

    let offset = 0;
    for (; offset < m.length - 7; offset += 8) {
        let word = view.getBigUint64(offset, true);
        v[3] ^= word;
        compress(v);
        compress(v);
        v[0] ^= word;
    }

    buf.set(m.slice(offset));
    buf.fill(0, m.length - offset, 7);
    buf[7] = m.length;

    let word = new DataView(buf.buffer).getBigUint64(0, true);

    v[3] ^= word;
    compress(v);
    compress(v);
    v[0] ^= word;
    v[2] ^= 0xFFn;
    compress(v);
    compress(v);
    compress(v);
    compress(v);

    return ('00000000000000000000000000000000' + ((v[0] ^ v[1]) + ((v[2] ^ v[3]) << 64n)).toString(16)).substr(-32).
        match(/../g).reverse().join('');
}

function getFingerprint(text) {
    return text.match(/\p{L}{4,100}/gu).
        map((elem, idx, arr) => idx + 2 < arr.length ? [elem, arr[idx + 1], arr[idx + 2]] : []).
        filter(elem => elem.length === 3).map(elem => elem.join()).
        filter((elem, idx, arr) => arr.indexOf(elem) === idx).
        map(elem => sipHash128(encoder.encode(elem)).substr(0, 8)).
        reduce((min, curr) => curr < min ? curr : min, 'ffffffff');
}

let curr_fingerprint = '';
let curr_hash = '';
let prev_fingerprint = '';
let prev_hash = '';

let request_num = 0;

let back = document.getElementById('back');
let check = document.getElementById('check-mark');
let error = document.getElementById('error');
let wait = document.getElementById('hourglass');

function hide() {
    back.style.display = 'none';
    check.style.display = 'none';
    error.style.display = 'none';
    wait.style.display = 'none';
}

function show(what) {
    hide();
    what.style.display = 'block';
}

const clickhouse_url = "http://localhost:8123/?add_http_cors_header=1&async_insert=1";

async function load(fingerprint, hash, type) {
    show(wait);

    const response = await fetch(
        clickhouse_url,
        { method: "POST", body: `SELECT content, lower(hex(reinterpretAsFixedString(prev_hash))) AS prev_hash, lower(hex(reinterpretAsFixedString(prev_fingerprint))) AS prev_fingerprint FROM paste WHERE fingerprint = reinterpretAsUInt32(unhex('${fingerprint}')) AND hash = reinterpretAsUInt128(unhex('${hash}')) ORDER BY time LIMIT 1 FORMAT JSON` });

    function onError() {
        show(error);
        throw new Error(`Load failed\nHTTP status ${response.status}\nMessage: ${response.body}`);
    }

    if (!response.ok) onError();
    const json = await response.json();
    if (json.rows != 1) onError();

    const result = json.data[0];
    const content = result.content;

    prev_hash = result.prev_hash;
    prev_fingerprint = result.prev_fingerprint;

    curr_hash = hash;
    curr_fingerprint = fingerprint;

    if (type === '.html' || type == '.htm') {
        document.open();
        document.write(content);
        document.close();
    } else if (type === '.md' || type === '.markdown') {
        await loadMarkdownRenderer();
        document.body.className = 'markdown';
        document.body.innerHTML = marked.parse(content);
    } else {
        document.getElementById('data').value = content;

        if (prev_hash == '00000000000000000000000000000000') {
            hide();
        } else {
            show(back);
        }
    }
}

async function save(text) {
    const my_request_num = ++request_num;

    show(wait);

    const response = await fetch(
        clickhouse_url,
        {
            method: "POST",
            body: "INSERT INTO paste (fingerprint_hex, hash_hex, prev_fingerprint_hex, prev_hash_hex, content) FORMAT JSONEachRow " + JSON.stringify(
            {
                fingerprint_hex: curr_fingerprint,
                hash_hex: curr_hash,
                prev_fingerprint_hex: prev_fingerprint,
                prev_hash_hex: prev_hash,
                content: text
            })
        });

    if (!response.ok) {
        show(error);
        throw new Error(`Saving failed\nHTTP status ${response.status}`);
    }

    if (my_request_num == request_num) {
        history.pushState(null, null, window.location.pathname.replace(/(\?.+)?$/, `?${curr_fingerprint}/${curr_hash}`));
        show(check);
    }
}

/// Huge JS libraries should be loaded only if needed.
function loadJS(src, integrity) {
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        if (integrity) {
            script.crossOrigin = 'anonymous';
            script.integrity = integrity;
        } else {
            console.warn('no integrity for', src)
        }
        script.addEventListener('load', function() { marked.setOptions({ gfm: true, breaks: true }); resolve(true); });
        document.head.appendChild(script);
    });
}

let load_markdown_promise;
function loadMarkdownRenderer() {
    if (load_markdown_promise) { return load_markdown_promise; }

    return loadJS('https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.2/marked.min.js',
        'sha512-hzyXu3u+VDu/7vpPjRKFp9w33Idx7pWWNazPm+aCMRu26yZXFCby1gn1JxevVv3LDwnSbyKrvLo3JNdi4Qx1ww==');
}


document.getElementById('data').addEventListener('input', (event) => {

    prev_fingerprint = curr_fingerprint;
    prev_hash = curr_hash

    const text = document.getElementById('data').value;

    curr_hash = sipHash128(encoder.encode(text));
    curr_fingerprint = getFingerprint(text);

    save(text);
});

back.addEventListener('click', (event) => {
    load(prev_fingerprint, prev_hash);
    history.pushState(null, null, window.location.pathname.replace(/(\?.+)?$/, `?${curr_fingerprint}/${curr_hash}`));
});

function restore() {
    const components = window.location.search.match(/^\?([0-9a-f]{8})\/([0-9a-f]{32})(\.md|\.html?)?/);
    if (components) load(components[1], components[2], components[3]);
}

window.onpopstate = function(event) {
    restore();
};

restore();


/*

CREATE TABLE paste
(
    fingerprint UInt32 DEFAULT reinterpretAsUInt32(unhex(fingerprint_hex)),
    hash UInt128 DEFAULT reinterpretAsUInt128(unhex(hash_hex)),
    prev_fingerprint UInt32 DEFAULT reinterpretAsUInt32(unhex(prev_fingerprint_hex)),
    prev_hash UInt128 DEFAULT reinterpretAsUInt128(unhex(prev_hash_hex)),
    content String,

    size UInt32 MATERIALIZED length(content),
    time DateTime64 MATERIALIZED now64(),
    query_id String MATERIALIZED queryID(),

    fingerprint_hex String EPHEMERAL '',
    hash_hex String EPHEMERAL '',
    prev_fingerprint_hex String EPHEMERAL '',
    prev_hash_hex String EPHEMERAL '',

    CONSTRAINT length CHECK length(content) < 10 * 1024 * 1024,
    CONSTRAINT hash_is_correct CHECK sipHash128(content) = reinterpretAsFixedString(hash),

    PRIMARY KEY (fingerprint, hash)
)
ENGINE = MergeTree

*/

</script>
</body>
</html>
