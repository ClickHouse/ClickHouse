#include <DataTypes/DataTypeArray.h>
#include <DataTypes/DataTypeDate.h>
#include <DataTypes/DataTypeDateTime.h>
#include <DataTypes/DataTypeLowCardinality.h>
#include <DataTypes/DataTypeNullable.h>
#include <DataTypes/DataTypeString.h>
#include <DataTypes/DataTypesNumber.h>
#include <Interpreters/CrashLog.h>
#include <base/getFQDNOrHostName.h>
#include <Common/ClickHouseRevision.h>
#include <Common/DateLUTImpl.h>
#include <Common/StackTrace.h>
#include <Common/Stopwatch.h>
#include <Common/SymbolIndex.h>

#include <Common/config_version.h>
#include <Poco/Environment.h>


extern const char * GIT_HASH;


namespace DB
{

std::weak_ptr<CrashLog> CrashLog::crash_log;


ColumnsDescription CrashLogElement::getColumnsDescription()
{
    return ColumnsDescription
    {
        {"hostname", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>()), "The hostname where the crash occurred."},
        {"event_date", std::make_shared<DataTypeDate>(), "The date of the crash."},
        {"event_time", std::make_shared<DataTypeDateTime>(), "The time of the crash."},
        {"timestamp_ns", std::make_shared<DataTypeUInt64>(), "Timestamp of the event with nanoseconds."},
        {"signal", std::make_shared<DataTypeInt32>(), "Signal number."},
        {"signal_code", std::make_shared<DataTypeInt32>(), "Signal code. Provides additional context about the signal cause."},
        {"thread_id", std::make_shared<DataTypeUInt64>(), "Thread ID."},
        {"query_id", std::make_shared<DataTypeString>(), "Query ID."},
        {"query", std::make_shared<DataTypeString>(), "Query text that was being executed when the crash occurred."},
        {"trace", std::make_shared<DataTypeArray>(std::make_shared<DataTypeUInt64>()), "Stack trace at the moment of crash. Each element is a virtual memory address inside ClickHouse server process."},
        {"trace_full", std::make_shared<DataTypeArray>(std::make_shared<DataTypeString>()), "Stack trace at the moment of crash. Each element contains a called method inside ClickHouse server process."},
        {"fault_address", std::make_shared<DataTypeNullable>(std::make_shared<DataTypeUInt64>()), "Memory address that caused the fault."},
        {"fault_access_type", std::make_shared<DataTypeString>(), "Type of memory access that caused the fault (e.g., 'read', 'write')."},
        {"signal_description", std::make_shared<DataTypeString>(), "Human-readable description based on signal_code (e.g., 'Address not mapped to object')."},
        {"current_exception", std::make_shared<DataTypeString>(), "Current exception message with stack trace (std::terminate crashes only)."},
        {"version", std::make_shared<DataTypeString>(), "ClickHouse server version."},
        {"revision", std::make_shared<DataTypeUInt32>(), "ClickHouse server revision."},
        {"build_id", std::make_shared<DataTypeString>(), "BuildID that is generated by compiler."},
        {"git_hash", std::make_shared<DataTypeString>(), "Git commit hash of the ClickHouse source code."},
        {"architecture", std::make_shared<DataTypeString>(), "CPU architecture (e.g., x86_64, aarch64)."},
    };
}

void CrashLogElement::appendToBlock(MutableColumns & columns) const
{
    size_t i = 0;

    columns[i++]->insert(getFQDNOrHostName());
    columns[i++]->insert(DateLUT::instance().toDayNum(event_time).toUnderType());
    columns[i++]->insert(event_time);
    columns[i++]->insert(timestamp_ns);
    columns[i++]->insert(signal);
    columns[i++]->insert(signal_code);
    columns[i++]->insert(thread_id);
    columns[i++]->insertData(query_id.data(), query_id.size());
    columns[i++]->insertData(query.data(), query.size());
    columns[i++]->insert(trace);
    columns[i++]->insert(trace_full);

    if (fault_address.has_value())
        columns[i++]->insert(*fault_address);
    else
        columns[i++]->insertDefault();

    columns[i++]->insertData(fault_access_type.data(), fault_access_type.size());
    columns[i++]->insertData(signal_description.data(), signal_description.size());
    columns[i++]->insertData(current_exception.data(), current_exception.size());
    columns[i++]->insert(VERSION_FULL);
    columns[i++]->insert(ClickHouseRevision::getVersionRevision());

    String build_id_hex;
#if defined(__ELF__) && !defined(OS_FREEBSD)
    build_id_hex = SymbolIndex::instance().getBuildIDHex();
#endif
    columns[i++]->insert(build_id_hex);
    columns[i++]->insertData(git_hash.data(), git_hash.size());
    columns[i++]->insertData(architecture.data(), architecture.size());
}

}

void collectCrashLog(
    Int32 signal,
    Int32 signal_code,
    UInt64 thread_id,
    const String & query_id,
    const String & query,
    const StackTrace & stack_trace,
    std::optional<UInt64> fault_address,
    const String & fault_access_type,
    const String & signal_description,
    const String & current_exception)
{
    using namespace DB;

    if (auto crash_log_owned = CrashLog::crash_log.lock())
    {
        UInt64 time = clock_gettime_ns(CLOCK_REALTIME);

        size_t stack_trace_size = stack_trace.getSize();
        size_t stack_trace_offset = stack_trace.getOffset();
        size_t num_frames = stack_trace_size - stack_trace_offset;

        Array trace;
        Array trace_full;

        trace.reserve(num_frames);
        trace_full.reserve(num_frames);

        for (size_t i = stack_trace_offset; i < stack_trace_size; ++i)
            trace.push_back(reinterpret_cast<uintptr_t>(stack_trace.getFramePointers()[i]));

        stack_trace.toStringEveryLine([&trace_full](std::string_view line) { trace_full.push_back(line); });

        CrashLogElement element{
            static_cast<time_t>(time / 1000000000),
            time,
            signal,
            signal_code,
            thread_id,
            query_id,
            query,
            trace,
            trace_full,
            fault_address,
            fault_access_type,
            signal_description,
            current_exception,
            GIT_HASH,
            Poco::Environment::osArchitecture()};
        crash_log_owned->add(std::move(element));
    }
}
