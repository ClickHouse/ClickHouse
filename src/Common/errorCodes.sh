#!/usr/bin/env bash

# Parse src/Common/ErrorCodes.cpp
# And generate src/Functions/errorCodes.generated.cpp
# For errorCode() function.
#
# Later it may contain some description of the error.

set -e
set -o pipefail

CUR_DIR="$(readlink -f "$(dirname "${BASH_SOURCE[0]}")")"
ERROR_CODES_IN_FILE=${ERROR_CODES_IN_FILE=$CUR_DIR/../Common/ErrorCodes.cpp}
ERROR_CODES_OUT_FILE=${ERROR_CODES_OUT_FILE=$CUR_DIR/errorCodes.generated.cpp}
CXX=${CXX=g++}

trap 'rm -f $TMP_FILE' EXIT
TMP_FILE="$(mktemp clichouse_generate_errorCodes_XXXXXXXX.cpp)"

function parse_ErrorCodes()
{
    # This is the simplest command that can be written to parse the file
    # And it does not requires any extra tools and works everywhere where you have g++/clang++
    #
    # Generate:
    #
    #     CODE VAR_NAME
    #
    $CXX -E "$ERROR_CODES_IN_FILE" | {
        awk -F '[ =;]*' '/extern const int / { print $(NF-1), $(NF-2); }'
    }
}
function parse_for_errorCodeToName()
{
    parse_ErrorCodes | awk '{ printf("        case %s: return std::string_view(\"%s\");\n", $1, $2); }'
}
function generate_errorCodeToName()
{
    cat <<EOL
#include <string_view>

std::string_view errorCodeToName(int code)
{
    switch (code)
    {
        case 0: return std::string_view("OK");
$(parse_for_errorCodeToName)
        default: return std::string_view("");
    }
};

EOL
}

function parse_for_error_codes_count()
{
    parse_ErrorCodes | awk '{ printf("        error_codes_count[%s] = 0; /* %s */\n", $1, $2); }'
}
function generate_error_codes_count()
{
    cat <<EOL
#include <Common/HashTable/HashMap.h>
#include <Databases/IDatabase.h>
#include <Interpreters/AggregationCommon.h>
#include <atomic>

HashMap<int, std::atomic<uint64_t>, DefaultHash<int>> error_codes_count;

struct InitializeErrorCodesCount
{
    InitializeErrorCodesCount()
    {
$(parse_for_error_codes_count)
    }
} error_codes_count_initialize;
EOL
}

function main()
{
    echo "// autogenerated by ${BASH_SOURCE[0]}" > "$TMP_FILE"
    generate_errorCodeToName >> "$TMP_FILE"
    generate_error_codes_count >> "$TMP_FILE"

    if [[ ! -e $ERROR_CODES_OUT_FILE ]]; then
        cp -a "$TMP_FILE" "$ERROR_CODES_OUT_FILE"
    fi
    # update it only if it differs, to avoid costly recompilation
    if ! diff -q "$TMP_FILE" "$ERROR_CODES_OUT_FILE"; then
        cp -a "$TMP_FILE" "$ERROR_CODES_OUT_FILE"
    fi
}
main "$@"
