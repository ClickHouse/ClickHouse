#include <Columns/ColumnArray.h>
#include <Columns/ColumnFixedString.h>
#include <Columns/ColumnQBit.h>

#include <DataTypes/DataTypeArray.h>
#include <DataTypes/DataTypeFixedString.h>
#include <DataTypes/DataTypeQBit.h>
#include <DataTypes/DataTypesNumber.h>
#include <DataTypes/Serializations/SerializationQBit.h>

#include <Functions/FunctionFactory.h>
#include <Functions/FunctionHelpers.h>

/// TODO: when p is <=16, downcast to BFloat16. If <=32, downcast to Float32


namespace DB
{
namespace ErrorCodes
{
extern const int BAD_ARGUMENTS;
extern const int ILLEGAL_TYPE_OF_ARGUMENT;
extern const int LOGICAL_ERROR;
extern const int TOO_FEW_ARGUMENTS_FOR_FUNCTION;
extern const int TOO_MANY_ARGUMENTS_FOR_FUNCTION;
}

struct L2DistanceTransposed
{
    static constexpr auto name = "L2DistanceTransposed";
    struct ConstParams
    {
        UInt8 groups;
    };

    template <typename FloatType>
    struct State
    {
        FloatType sum{};
    };

    template <typename ResultType>
    static void accumulate(State<ResultType> & state, ResultType x, ResultType y, const ConstParams &)
    {
        state.sum += (x - y) * (x - y);
    }

    template <typename ResultType>
    static void combine(State<ResultType> & state, const State<ResultType> & other, const ConstParams &)
    {
        state.sum += other.sum;
    }

    template <typename ResultType>
    static ResultType finalize(const State<ResultType> & state, const ConstParams &)
    {
        return sqrt(state.sum);
    }
};

template <typename Kernel>
class FunctionArrayDistance : public IFunction
{
public:
    String getName() const override { return Kernel::name; }
    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionArrayDistance<Kernel>>(); }
    bool isVariadic() const override { return true; }
    size_t getNumberOfArguments() const override { return 0; }
    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {}; }
    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
    bool useDefaultImplementationForConstants() const override { return true; }

    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
    {
        if (arguments.size() < 3)
            throw Exception(
                ErrorCodes::TOO_FEW_ARGUMENTS_FOR_FUNCTION,
                "Number of arguments for function {} can't be {}, should be at least 3",
                getName(),
                arguments.size());

        /// Check if we are in optimised L2DistanceTransposed(vec.1, ..., vec.p, qbit_size, ref_vec) case. If something goes wrong, we
        /// fallback to the original L2DistanceTransposed(qbit, ref_vec, p) handling. The arguments in optimised case are generated by us
        /// and are almost certainly correct. It is extremely unlikely that user will write optimised case manually. Thus, any error in
        /// arguments is treated as user error from the original case.
        if (validateOptimizedArguments(arguments))
        {
            const auto * ref_vec_type = checkAndGetDataType<DataTypeArray>(arguments.back().type.get());

            switch (ref_vec_type->getNestedType()->getTypeId())
            {
                case TypeIndex::BFloat16:
                case TypeIndex::Float32:
                    return std::make_shared<DataTypeFloat32>();
                case TypeIndex::Float64:
                    return std::make_shared<DataTypeFloat64>();
                default:
                    UNREACHABLE();
            }
        }

        if (arguments.size() > 3)
            throw Exception(
                ErrorCodes::TOO_MANY_ARGUMENTS_FOR_FUNCTION,
                "Number of arguments for function {} is {}. Expected 3",
                getName(),
                arguments.size());

        /// Check the first two arguments
        const auto * zeroth_arg_type = checkAndGetDataType<DataTypeQBit>(arguments[0].type.get());
        const auto * first_arg_type = checkAndGetDataType<DataTypeArray>(arguments[1].type.get());

        if (!zeroth_arg_type)
            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "First argument of function {} must be a QBit", getName());

        if (!first_arg_type)
            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Second argument of function {} must be an Array", getName());

        const auto zeroth_arg_nested_type = zeroth_arg_type->getElementType();
        const auto first_arg_nested_type = first_arg_type->getNestedType();
        const auto zeroth_arg_nested_type_id = zeroth_arg_nested_type->getTypeId();
        const auto first_arg_nested_type_id = first_arg_nested_type->getTypeId();

        if (zeroth_arg_nested_type_id != first_arg_nested_type_id)
            throw Exception(
                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
                "Arguments 1 and 2 of function {} have different nested types: {} and {}. They must be the same",
                getName(),
                zeroth_arg_nested_type->getName(),
                first_arg_nested_type->getName());

        /// Check that precision (third argument) is valid
        const auto & precision_col = arguments[2];
        WhichDataType which(precision_col.type);

        if (!which.isUInt8())
            throw Exception(
                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
                "The third argument of function {} must be a UInt8 constant, got {}",
                getName(),
                precision_col.type->getName());

        if (!(precision_col.column && precision_col.column->isConst()))
            throw Exception(
                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
                "The third argument of function {} must be a UInt8 constant, got {} (not constant)",
                getName(),
                precision_col.type->getName());

        const auto precision = precision_col.column->getUInt(0);

        switch (first_arg_nested_type_id)
        {
            case TypeIndex::BFloat16:
                if (precision == 0 || precision > 16)
                    throw Exception(
                        ErrorCodes::BAD_ARGUMENTS,
                        "The third argument (precision) of function {} must be in range [1, 16] for BFloat16 QBit, got {}",
                        getName(),
                        precision);
                return std::make_shared<DataTypeFloat32>();

            case TypeIndex::Float32:
                if (precision == 0 || precision > 32)
                    throw Exception(
                        ErrorCodes::BAD_ARGUMENTS,
                        "The third argument (precision) of function {} must be in range [1, 32] for Float32 QBit, got {}",
                        getName(),
                        precision);
                return std::make_shared<DataTypeFloat32>();

            case TypeIndex::Float64:
                if (precision == 0 || precision > 64)
                    throw Exception(
                        ErrorCodes::BAD_ARGUMENTS,
                        "The third argument (precision) function {} must be in range [1, 64] for Float64 QBit, got {}",
                        getName(),
                        precision);
                return std::make_shared<DataTypeFloat64>();

            default:
                throw Exception(
                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
                    "Arguments of function {} have nested or unsupported type {}. The supported types are BFloat16, Float32 and Float64",
                    getName(),
                    first_arg_type->getNestedType()->getName());
        }

        UNREACHABLE();
    }

    /// Validates arguments for optimised L2DistanceTransposed(vec.1, ..., vec.p, qbit_size, ref_vec) case
    bool validateOptimizedArguments(const ColumnsWithTypeAndName & arguments) const
    {
        constexpr size_t max_precision = 64;
        const size_t num_arguments = arguments.size();
        const auto * ref_vec_type = checkAndGetDataType<DataTypeArray>(arguments.back().type.get());
        const auto & qbit_size_column = (arguments.end() - 2)->column;
        const auto & qbit_size_arg_type = (arguments.end() - 2)->type;
        const WhichDataType which_qbit_size_arg_type(qbit_size_arg_type);

        /// Note: we only allow constant qbit_size_column
        if (!ref_vec_type || num_arguments - 2 > max_precision || !qbit_size_column || !qbit_size_column->isConst()
            || !which_qbit_size_arg_type.isUInt())
            return false;

        const auto ref_vec_type_id = ref_vec_type->getNestedType()->getTypeId();
        if (ref_vec_type_id != TypeIndex::BFloat16 && ref_vec_type_id != TypeIndex::Float32 && ref_vec_type_id != TypeIndex::Float64)
            return false;

        const auto qbit_size = qbit_size_column->getUInt(0);
        const auto qbit_size_bytes = DataTypeQBit::bitsToBytes(qbit_size);

        /// All QBit subcolumns should be FixedString and have a consistent size
        for (size_t i = 0; i < arguments.size() - 2; ++i)
        {
            const auto * arg_type = checkAndGetDataType<DataTypeFixedString>(arguments[i].type.get());

            if (!arg_type || arg_type->getN() != qbit_size_bytes)
                return false;
        }

        return true;
    }

    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override
    {
        switch (result_type->getTypeId())
        {
            /// Result type cannot be BFloat16 as there is no sqrt function for it
            case TypeIndex::BFloat16:
            case TypeIndex::Float32:
                return executeWithResultType<Float32>(arguments, input_rows_count);
            case TypeIndex::Float64:
                return executeWithResultType<Float64>(arguments, input_rows_count);
            default:
                UNREACHABLE();
        }
    }

private:
    static ColumnPtr extractFromConst(const ColumnPtr & column)
    {
        return column->isConst() ? assert_cast<const ColumnConst *>(column.get())->getDataColumnPtr() : column;
    }

    template <typename ResultType>
    ColumnPtr executeWithResultType(const ColumnsWithTypeAndName & arguments, size_t input_rows_count) const
    {
        const auto & last_arg = arguments.back();

        /// If last argument is UInt, we are in L2DistanceTransposed(qbit, ref_vec, p) case
        WhichDataType which_last(last_arg.type);
        if (which_last.isUInt8())
            return executeWithQBitColumnConverted<ResultType>(arguments, input_rows_count);

        /// Otherwise, L2DistanceTransposed(vec.1, ..., vec.p, qbit_size, ref_vec)

        /// First, check that the reference vector sizes match qbit size
        const ColumnArray & reference_vector = *assert_cast<const ColumnArray *>(extractFromConst(arguments.back().column).get());
        const auto qbit_size = (arguments.end() - 2)->column->getUInt(0);
        const auto & offsets = reference_vector.getOffsets();

        /// In dry run, the offsets can be empty with non-constant reference vector
        if (!offsets.empty())
        {
            for (size_t i = 0; i < reference_vector.size(); ++i)
            {
                if (offsets[i] - offsets[i - 1] != qbit_size)
                    throw Exception(
                        ErrorCodes::BAD_ARGUMENTS,
                        "The reference vector in the last argument of function {} has wrong size. Got: {}, expected: {}",
                        getName(),
                        offsets[i] - offsets[i - 1],
                        qbit_size);
            }
        }

        /// Continue with execution
        auto type_y = typeid_cast<const DataTypeArray *>(last_arg.type.get())->getNestedType();
        switch (type_y->getTypeId())
        {
            case TypeIndex::BFloat16:
                return executeWithResultTypeAndLeftTypeAndRightType<ResultType, BFloat16, BFloat16>(arguments, qbit_size, input_rows_count);
            case TypeIndex::Float32:
                return executeWithResultTypeAndLeftTypeAndRightType<ResultType, Float32, Float32>(arguments, qbit_size, input_rows_count);
            case TypeIndex::Float64:
                return executeWithResultTypeAndLeftTypeAndRightType<ResultType, Float64, Float64>(arguments, qbit_size, input_rows_count);
            default:
                throw Exception(
                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
                    "Arguments of function {} have nested or unsupported type {}. Supported types: BFloat16, Float32, Float64",
                    getName(),
                    type_y->getName());
        }
    }

    /// L2DistanceTransposed(qbit, ref_vec, p) case. Convert arguments to [qbit.1, ..., qbit.p, ref_vec] format before executing
    template <typename ResultType>
    ColumnPtr executeWithQBitColumnConverted(const ColumnsWithTypeAndName & arguments, size_t input_rows_count) const
    {
        ColumnsWithTypeAndName converted_arguments;

        const auto precision = arguments[2].column->getUInt(0);
        const auto * qbit_type = assert_cast<const DataTypeQBit *>(arguments[0].type.get());
        const auto * qbit_ptr = assert_cast<const ColumnQBit *>(extractFromConst(arguments[0].column).get());
        const auto qbit_dimension = qbit_type->getDimension();
        const auto & qbit_tuple = assert_cast<const ColumnTuple &>(qbit_ptr->getTupleColumn());
        const auto bit_plane_type = qbit_type->getNestedTupleElementType();

        for (size_t bit = 0; bit < precision; ++bit)
            converted_arguments.emplace_back(qbit_tuple.getColumn(bit).getPtr(), bit_plane_type, toString(bit + 1));
        /// Add dimension as penultimate argument and reference vector as last argument
        auto dimension_column = DataTypeUInt64().createColumnConst(1, qbit_dimension);
        converted_arguments.emplace_back(dimension_column, std::make_shared<DataTypeUInt64>(), "dimension");
        converted_arguments.emplace_back(arguments[1]);

        /// We go back to the function that called us, but now with converted arguments
        return executeWithResultType<ResultType>(converted_arguments, input_rows_count);
    }

    template <typename ResultType, typename LeftType, typename RightType>
    ColumnPtr executeWithResultTypeAndLeftTypeAndRightType(
        const ColumnsWithTypeAndName & arguments, const size_t qbit_size, size_t input_rows_count) const
    {
        const ColumnPtr col_y = extractFromConst(arguments.back().column);
        const ColumnArray & array = *assert_cast<const ColumnArray *>(extractFromConst(col_y).get());
        return executeDistanceCalculation<ResultType, LeftType, RightType>(array, arguments, qbit_size, input_rows_count);
    }

    template <typename ResultType, typename LeftType, typename RightType>
    ColumnPtr executeDistanceCalculation(
        const ColumnArray & array, const ColumnsWithTypeAndName & arguments, const size_t qbit_size, size_t input_rows_count) const
    {
        const size_t precision = arguments.size() - 2;
        const auto & array_data = typeid_cast<const ColumnVector<RightType> &>(array.getData()).getData();
        const size_t bytes_per_fixedstring = DataTypeQBit::bitsToBytes(qbit_size);
        const size_t padded_array_size = bytes_per_fixedstring * 8;

        const typename Kernel::ConstParams kernel_params = initConstParams(arguments);
        auto col_res = ColumnVector<ResultType>::create(input_rows_count);
        auto & result_data = col_res->getData();

        std::vector<LeftType> untransposed_x(padded_array_size);

        using Word = std::conditional_t<sizeof(LeftType) == 2, UInt16, std::conditional_t<sizeof(LeftType) == 4, UInt32, UInt64>>;

        /// Pre-extract all FixedString columns from constants if needed to avoid repeated work in the loop below
        std::vector<ColumnPtr> extracted_columns;
        extracted_columns.reserve(precision);
        for (size_t bit = 0; bit < precision; ++bit)
            extracted_columns.emplace_back(extractFromConst(arguments[bit].column));

        /// Handle two cases for reference vector access:
        /// 1. Constant reference vector: All rows use the same reference vector, so array_start stays at 0
        /// 2. Non-constant reference vector: Each row has its own reference vector, so we advance by qbit_size elements after each row
        const auto reference_vector_shift = arguments.back().column->isConst() ? 0 : qbit_size;
        size_t array_start = 0;
        for (size_t row = 0; row < input_rows_count; row++)
        {
            memset(untransposed_x.data(), 0, padded_array_size * sizeof(LeftType));

            for (size_t bit = 0; bit < precision; ++bit)
            {
                const auto & col = assert_cast<const ColumnFixedString &>(*extracted_columns[bit]);
                const UInt8 * src = reinterpret_cast<const UInt8 *>(col.getChars().data()) + row * bytes_per_fixedstring;

                Word bit_mask = Word(1) << (sizeof(Word) * 8 - 1 - bit);
                SerializationQBit::untransposeBitPlane(src, reinterpret_cast<Word *>(untransposed_x.data()), padded_array_size, bit_mask);
            }

            /// Calculate distance, processing vectorized chunks, unless the array size is smaller than the minimum chunk size
            typename Kernel::template State<ResultType> state;
            static constexpr size_t VEC_SIZE = 16;
            size_t pos = 0;

            for (; pos + VEC_SIZE < qbit_size; pos += VEC_SIZE)
            {
                typename Kernel::template State<ResultType> states[VEC_SIZE];
                for (size_t s = 0; s < VEC_SIZE; ++s)
                    Kernel::template accumulate<ResultType>(
                        states[s],
                        static_cast<ResultType>(untransposed_x[pos + s]),
                        static_cast<ResultType>(array_data[array_start + pos + s]),
                        kernel_params);

                for (const auto & other_state : states)
                    Kernel::template combine<ResultType>(state, other_state, kernel_params);
            }

            /// Process remaining elements
            for (; pos < qbit_size; ++pos)
                Kernel::template accumulate<ResultType>(
                    state,
                    static_cast<ResultType>(untransposed_x[pos]),
                    static_cast<ResultType>(array_data[array_start + pos]),
                    kernel_params);

            result_data[row] = Kernel::finalize(state, kernel_params);
            array_start += reference_vector_shift;
        }

        return col_res;
    }

    typename Kernel::ConstParams initConstParams(const ColumnsWithTypeAndName &) const { return {}; }
};

template <>
size_t FunctionArrayDistance<L2DistanceTransposed>::getNumberOfArguments() const
{
    return 3;
}

template <>
ColumnNumbers FunctionArrayDistance<L2DistanceTransposed>::getArgumentsThatAreAlwaysConstant() const
{
    return {2};
}

template <>
L2DistanceTransposed::ConstParams
FunctionArrayDistance<L2DistanceTransposed>::initConstParams(const ColumnsWithTypeAndName & arguments) const
{
    if (arguments.size() < 3)
        throw Exception(ErrorCodes::LOGICAL_ERROR, "Function {} expects three or more arguments", getName());

    const UInt8 precision = arguments.size() - 2;

    if (precision == 0 || precision > 64)
        throw Exception(
            ErrorCodes::BAD_ARGUMENTS,
            "Second argument for function {} must be positive integer in range [1, 64], got {}",
            getName(),
            toString(precision));

    return L2DistanceTransposed::ConstParams{precision};
}


/// Used by TupleOrArrayFunction
FunctionPtr createFunctionArrayL2DistanceTransposed(ContextPtr context_)
{
    return FunctionArrayDistance<L2DistanceTransposed>::create(context_);
}
}
