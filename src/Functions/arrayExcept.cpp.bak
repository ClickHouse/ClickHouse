
#include <Columns/ColumnArray.h>
#include <DataTypes/DataTypeArray.h>
#include <Functions/FunctionFactory.h>
#include <Functions/FunctionHelpers.h>
#include <Common/HashTable/HashSet.h>
#include <Common/typeid_cast.h>

namespace DB
{

namespace ErrorCodes
{
    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
    extern const int SIZES_OF_ARRAYS_DONT_MATCH;
    extern const int TOO_FEW_ARGUMENTS_FOR_FUNCTION;
    extern const int ILLEGAL_COLUMN;
}

/// arrayExcept([1, 2, 3, 4], [3, 4, 5, 6]) = [1, 2]
class FunctionArrayExcept : public IFunction
{
public:
    static constexpr auto name = "arrayExcept";
    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionArrayExcept>(); }

    String getName() const override
    {
        return name;
    }

    bool isVariadic() const override { return false; }
    size_t getNumberOfArguments() const override { return 2; }
    bool useDefaultImplementationForConstants() const override { return true; }

    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }

    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
    {
        if (arguments.size() != 2)
            throw Exception(ErrorCodes::TOO_FEW_ARGUMENTS_FOR_FUNCTION,
                "Function {} needs exactly two arguments; passed {}." , getName(), arguments.size());

        for (size_t index = 0; index < arguments.size(); ++index)
        {
            const DataTypeArray * array_type = checkAndGetDataType<DataTypeArray>(arguments[index].type.get());

            if (!array_type)
                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Argument {} of function {} must be array. Found {} instead.",
                    toString(index + 1), getName(), arguments[index].type->getName());
        }

        return arguments[0].type;
    }

    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override
    {
        const ColumnArray * array_column_1 = checkAndGetColumn<ColumnArray>(arguments[0].column.get());
        const ColumnArray * array_column_2 = checkAndGetColumn<ColumnArray>(arguments[1].column.get());

        if (!array_column_1 || !array_column_2)
            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Arguments of function {} must be arrays.", getName());

        const IColumn & data_column_1 = array_column_1->getData();
        const IColumn & data_column_2 = array_column_2->getData();

        using Set = HashSet<UInt128, HashCRC32<UInt128>>;
        Set set;

        auto result_data_column = data_column_1.cloneEmpty();
        auto & result_data = static_cast<IColumn &>(*result_data_column);

        for (size_t row = 0; row < array_column_1->size(); ++row)
        {
            set.clear();
            for (size_t i = array_column_2->getOffsets()[row - 1], size = array_column_2->getOffsets()[row]; i < size; ++i)
            {
                set.insert(data_column_2.get64(i));
            }

            for (size_t i = array_column_1->getOffsets()[row - 1], size = array_column_1->getOffsets()[row]; i < size; ++i)
            {
                if (!set.has(data_column_1.get64(i)))
                {
                    result_data.insert(data_column_1.get64(i));
                }
            }
        }

        return ColumnArray::create(result_data_column, array_column_1->getOffsetsPtr());
    }

REGISTER_FUNCTION(ArrayExcept)
{
    factory.registerFunction<FunctionArrayExcept>();
}

}
